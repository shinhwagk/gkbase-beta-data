-- MySQL dump 10.13  Distrib 5.1.73, for redhat-linux-gnu (x86_64)
--
-- Host: localhost    Database: g_note
-- ------------------------------------------------------
-- Server version	5.1.73

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Current Database: `g_note`
--

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `g_note` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `g_note`;

--
-- Table structure for table `category`
--

DROP TABLE IF EXISTS `category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `category` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) DEFAULT NULL,
  `father_id` int(11) NOT NULL,
  `createdata` datetime NOT NULL,
  `updatedata` datetime NOT NULL,
  PRIMARY KEY (`id`),
  KEY `category_father_id` (`father_id`)
) ENGINE=InnoDB AUTO_INCREMENT=3707 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `category`
--

LOCK TABLES `category` WRITE;
/*!40000 ALTER TABLE `category` DISABLE KEYS */;
INSERT INTO `category` VALUES (2,'test',0,'2016-03-28 23:07:51','2016-03-28 23:07:51'),(4,'play',52,'2016-03-28 23:18:02','2016-03-28 23:18:02'),(5,'mysql',35,'2016-03-28 23:19:13','2016-03-28 23:19:13'),(6,'backup & recovery',5,'2016-03-28 00:00:00','2016-03-28 00:00:00'),(7,'backup',6,'2016-03-28 00:00:00','2016-03-28 00:00:00'),(8,'mysqldump',7,'2016-03-28 00:00:00','2016-03-28 00:00:00'),(9,'git & github',0,'2016-03-28 23:36:38','2016-03-31 00:00:00'),(11,'测试中文',2,'2016-03-28 00:00:00','2016-03-28 00:00:00'),(12,'linux',69,'2016-03-29 00:46:38','2016-03-29 00:46:38'),(13,'command',12,'2016-03-28 00:00:00','2016-03-28 00:00:00'),(14,'file',13,'2016-03-28 00:00:00','2016-03-28 00:00:00'),(16,'command',5,'2016-03-30 00:00:00','2016-03-30 00:00:00'),(17,'install',4,'2016-03-30 00:00:00','2016-03-30 00:00:00'),(18,'create app',17,'2016-03-30 00:00:00','2016-03-30 00:00:00'),(19,'conecpts',4,'2016-03-30 00:00:00','2016-03-30 00:00:00'),(20,'Action',19,'2016-03-30 00:00:00','2016-03-30 00:00:00'),(21,'sample',20,'2016-03-30 00:00:00','2016-03-30 00:00:00'),(22,'results',20,'2016-03-30 00:00:00','2016-03-30 00:00:00'),(23,'routing',19,'2016-03-30 00:00:00','2016-03-30 00:00:00'),(24,'ntpdate',13,'2016-03-30 00:00:00','2016-03-30 00:00:00'),(25,'yum',13,'2016-03-30 00:00:00','2016-03-30 00:00:00'),(26,'公共仓库',25,'2016-03-30 00:00:00','2016-03-30 00:00:00'),(27,'nslookup',13,'2016-03-30 00:00:00','2016-03-30 00:00:00'),(28,'lsof',13,'2016-03-30 00:00:00','2016-03-30 00:00:00'),(29,'nginx',39,'2016-03-30 14:43:06','2016-03-30 14:43:06'),(30,'install',29,'2016-03-30 00:00:00','2016-03-30 00:00:00'),(31,'language',0,'2016-03-30 15:31:39','2016-03-30 15:31:39'),(32,'php',31,'2016-03-30 00:00:00','2016-03-30 00:00:00'),(33,'scala',31,'2016-03-30 00:00:00','2016-03-30 00:00:00'),(34,'java',31,'2016-03-30 00:00:00','2016-03-30 00:00:00'),(35,'database',0,'2016-03-30 15:32:35','2016-03-30 15:32:35'),(36,'oracle',35,'2016-04-06 22:44:34','2016-04-06 22:44:34'),(38,'hive',60,'2016-03-31 09:38:43','2016-03-31 09:38:43'),(39,'webServer',0,'2016-03-31 11:29:55','2016-03-31 11:29:55'),(40,'函数',38,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(41,'ide',0,'2016-03-31 12:31:53','2016-03-31 12:31:53'),(42,'hql',38,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(43,'install',38,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(44,'python',31,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(45,'serviceDiscovery',0,'2016-03-31 12:58:46','2016-03-31 12:58:46'),(46,'php',31,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(47,'build tool',31,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(48,'maven',47,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(49,'sbt',47,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(50,'gradle',47,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(51,'public repo',47,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(52,'frame',0,'2016-03-31 13:03:13','2016-03-31 13:03:13'),(53,'apache',39,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(55,'character',5,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(56,'intellij',41,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(57,'快捷键',56,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(58,'win',57,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(59,'mac',57,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(60,'bigData',0,'2016-03-31 13:16:18','2016-03-31 13:16:18'),(61,'consul',45,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(62,'consul-template',61,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(63,'orm',52,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(64,'slick',63,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(65,'error',64,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(66,'akka',52,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(67,'kafka',60,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(68,'perl6',31,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(69,'OS',0,'2016-03-31 13:19:57','2016-03-31 13:19:57'),(70,'command',9,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(71,'zeppelin',60,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(72,'redis',35,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(73,'jvm',31,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(74,'parameter',73,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(75,'bin',73,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(76,' jstat',75,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(77,'jhat',75,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(78,'protocol',0,'2016-03-31 13:49:20','2016-03-31 13:49:20'),(79,'http',78,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(80,'Content-Type',79,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(81,'状态码',79,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(82,'results',19,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(83,'session & Flash',19,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(84,'函数式',33,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(85,'构造action',20,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(86,'dmesg',13,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(87,'concepts',33,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(88,'type system',87,'2016-03-31 00:00:00','2016-03-31 00:00:00'),(89,'ssh',13,'2016-04-01 00:00:00','2016-04-01 00:00:00'),(90,'apex',52,'2016-04-01 00:00:00','2016-04-01 00:00:00'),(91,'install',90,'2016-04-01 00:00:00','2016-04-01 00:00:00'),(93,'url',90,'2016-04-01 00:00:00','2016-04-01 00:00:00'),(94,'h2',35,'2016-04-01 00:00:00','2016-04-01 00:00:00'),(95,'database',4,'2016-04-01 00:00:00','2016-04-01 00:00:00'),(96,'h2',95,'2016-04-01 00:00:00','2016-04-01 00:00:00'),(111,'scp',13,'2016-04-01 00:00:00','2016-04-01 00:00:00'),(113,'短发短发',11,'2016-04-04 00:00:00','2016-04-04 00:00:00'),(114,'typscript',31,'2016-04-04 00:00:00','2016-04-04 00:00:00'),(115,'javascript',31,'2016-04-04 00:00:00','2016-04-04 00:00:00'),(116,'book',0,'2016-03-26 23:22:18','2016-03-26 23:22:18'),(117,'Javascript权威指南',116,'2016-04-04 00:00:00','2016-04-04 00:00:00'),(118,'第2章',117,'2016-04-04 00:00:00','2016-04-04 00:00:00'),(3236,'schema object',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3237,'tuning | database',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3238,'tuning | event',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3239,'net',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3240,'other',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3241,'concurrency',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3242,'database systems report(sql)',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3243,'encryption',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3244,'tuning | memory',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3245,'select',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3246,'user/privilege',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3247,'parallel execution',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3248,'advisor',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3249,'recovery',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3250,'structure storage',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3251,'search',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3252,'tuning | STATISTICS',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3253,'ha | rac',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3254,'tuning | session',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3255,'tuning | sql',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3256,'transaction',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3257,'tuning | instance',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3258,'audit',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3259,'sqlplus',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3260,'error',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3261,'ha | data guard',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3262,'instance',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3263,'plsql',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3264,'tuning | io',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3265,'scheduler',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3266,'view',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3267,'load/unload',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3268,'connect',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3269,'ha | asm',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3270,'ha | stream',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3271,'script',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3272,'secure',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3273,'sql',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3274,'tuning | tool',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3275,'integrity',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3276,'lock/latch',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3277,'monitor',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3278,'ogg',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3279,'install/upgrade',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3280,'parameter',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3281,'consumer',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3282,'database',36,'2016-04-06 22:44:47','2016-04-06 22:44:47'),(3283,'concepts | event',3238,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3284,'view | event',3238,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3285,'view',3237,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3286,'data type | concepts',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3287,'data type | parameter',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3288,'data type | select',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3289,'data type | view',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3290,'dimensions | concepts',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3291,'dimensions | dbms',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3292,'dimensions | parameter',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3293,'index | concepts',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3294,'index | operation',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3295,'index | select',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3296,'index | view',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3297,'materialized view | concepts',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3298,'materialized view | operation',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3299,'materialized view | parameter',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3300,'partition index | concepts',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3301,'partition index | operation',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3302,'partition index | view',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3303,'partition table | concepts',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3304,'partition table | operation',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3305,'partition table | select',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3306,'partition table | view',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3307,'synonym | operation',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3308,'table | concepts',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3309,'table | dbms',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3310,'table | operation',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3311,'table | select',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3312,'table | view',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3313,'view | view',3236,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3314,'concepts',3239,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3315,'dblink | o',3239,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3316,'dblink | s',3239,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3317,'listener | o',3239,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3318,'listener | parameter',3239,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3319,'operation',3239,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3320,'shard server | parameter',3239,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3321,'dbms',3240,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3322,'view',3240,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3323,'concepts',3241,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3324,'operation',3241,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3325,'database',3242,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3326,'tablespace',3242,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3327,'encryption',3243,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3328,'buffer cache | operation',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3329,'buffer cache | parameter',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3330,'buffer cache | select',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3331,'buffer cache | view',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3332,'event | view',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3333,'im column | operation',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3334,'im column | parameter',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3335,'im column | select',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3336,'im column | view',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3337,'instance | view',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3338,'large pool | parameter',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3339,'memory | parameter',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3340,'memory | view',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3341,'pga | parameter',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3342,'pga | select',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3343,'pga | view',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3344,'redo log buffer | parameter',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3345,'redo log buffer | select',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3346,'sga | concepts',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3347,'sga | parameter',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3348,'sga | select',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3349,'sga | view',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3350,'shared pool | concepts',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3351,'shared pool | dbms',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3352,'shared pool | operation',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3353,'shared pool | parameter',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3354,'shared pool | select',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3355,'shared pool | view',3244,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3356,'service',3245,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3357,'session',3245,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3358,'concepts',3246,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3359,'operation | privilege',3246,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3360,'operation | user',3246,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3361,'privilege | p',3246,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3362,'privilege | privilege list',3246,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3363,'privilege | role list',3246,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3364,'privilege | view',3246,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3365,'profile | limit list',3246,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3366,'profile | operation',3246,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3367,'select',3246,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3368,'user | p',3246,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3369,'user | select',3246,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3370,'user | view',3246,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3371,'concepts',3247,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3372,'operation',3247,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3373,'select',3247,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3374,'concepts',3248,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3375,'operation',3248,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3376,'parameter',3248,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3377,'view',3248,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3378,'flashback | V',3249,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3379,'flashback | o',3249,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3380,'flashback | p',3249,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3381,'flashback | parameter',3249,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3382,'flashback | s',3249,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3383,'instance | c',3249,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3384,'manual backup | o',3249,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3385,'recover | o | redo log file',3249,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3386,'rman | c',3249,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3387,'rman | c | backup',3249,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3388,'rman | c | duplicate',3249,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3389,'rman | o',3249,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3390,'rman | o | backup',3249,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3391,'rman | o | backup | dbms',3249,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3392,'rman | o | configure',3249,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3393,'rman | o | duplicate',3249,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3394,'rman | o | manage | archive log',3249,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3395,'rman | o | manage | list',3249,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3396,'rman | o | manage | report',3249,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3397,'rman | o | recover',3249,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3398,'rman | o | recover | spfile',3249,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3399,'rman | o | set',3249,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3400,'rman | p',3249,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3401,'rman | s',3249,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3402,'rman | v',3249,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3403,'archive log file | concepts',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3404,'archive log file | operation',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3405,'archive log file | parameter',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3406,'archive log file | select',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3407,'archive log file | view',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3408,'data file | operation',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3409,'data file | parameter',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3410,'data file | view',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3411,'fra | parameter',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3412,'redo log file | concepts',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3413,'redo log file | o',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3414,'redo log file | parameter',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3415,'redo log file | select',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3416,'rowid | conecpts',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3417,'select | extents',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3418,'select | segment',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3419,'tablespace | concepts',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3420,'tablespace | dbms',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3421,'tablespace | operation',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3422,'tablespace | parameter',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3423,'tablespace | select',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3424,'tablespace | view',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3425,'temp ts | view',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3426,'tuning | redo log',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3427,'undo ts | S',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3428,'undo ts | concepts',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3429,'undo ts | operation',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3430,'undo ts | parameter',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3431,'undo ts | view',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3432,'view | fra',3250,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3433,'search',3251,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3434,'index | select',3252,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3435,'concepts',3253,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3436,'operation',3253,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3437,'operation | ocr/olr',3253,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3438,'parameter',3253,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3439,'select',3253,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3440,'view',3253,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3441,'event | select',3254,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3442,'io | select',3254,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3443,'io | view',3254,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3444,'load | select',3254,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3445,'select',3254,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3446,'view',3254,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3447,'bind | select',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3448,'bind | view',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3449,'concepts | baseline',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3450,'concepts | bind variables',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3451,'concepts | hints',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3452,'concepts | profile',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3453,'concepts | statistics',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3454,'concepts | trace',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3455,'concepts | xplan',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3456,'cusour| view',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3457,'dbms | profile',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3458,'dbms | statistics',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3459,'dbms | trace',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3460,'dbms | tuning',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3461,'hint | o',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3462,'hint | v',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3463,'load | select',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3464,'load | view',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3465,'operation | baseline',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3466,'operation | profile',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3467,'operation | statistics',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3468,'operation | xplan',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3469,'parameter',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3470,'parameter | baseline',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3471,'parameter | bind variables',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3472,'parameter | profile',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3473,'privilege | profile',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3474,'script | xplan',3255,'2016-04-06 22:53:30','2016-04-06 22:53:30'),(3475,'select',3255,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3476,'select | baseline',3255,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3477,'select | bind',3255,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3478,'select | profile',3255,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3479,'select | statistics',3255,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3480,'select | trace',3255,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3481,'select | xplan',3255,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3482,'sts | concepts',3255,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3483,'sts | operation',3255,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3484,'sts | privilege',3255,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3485,'sts | view',3255,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3486,'tuning advisor | operation',3255,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3487,'tuning advisor | parameter',3255,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3488,'tuning advisor | select',3255,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3489,'tuning advisor | view',3255,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3490,'view',3255,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3491,'view | baseline',3255,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3492,'view | statistics',3255,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3493,'view | xplan',3255,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3494,'operation',3256,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3495,'select',3256,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3496,'dbms',3257,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3497,'operation | parameter',3257,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3498,'parameter',3257,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3499,'select | instance',3257,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3500,'select | user',3257,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3501,'view',3257,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3502,'operation',3258,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3503,'command',3259,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3504,'concepts',3259,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3505,'operation',3259,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3506,'parameter',3259,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3507,'script',3259,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3508,'set',3259,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3509,'show',3259,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3510,'alert.log',3260,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3511,'dia',3260,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3512,'ins',3260,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3513,'ora',3260,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3514,'other',3260,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3515,'rman',3260,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3516,'tns',3260,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3517,'concepts',3261,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3518,'logical | o',3261,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3519,'logical | s',3261,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3520,'operation',3261,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3521,'parameter',3261,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3522,'phy | o',3261,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3523,'phy | p',3261,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3524,'phy | s',3261,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3525,'select',3261,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3526,'view',3261,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3527,'checkpoint | concepts',3262,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3528,'control file | operation',3262,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3529,'dbms',3262,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3530,'operation',3262,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3531,'operation | parameter',3262,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3532,'orapwd | concepts',3262,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3533,'orapwd | parameter',3262,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3534,'parameter',3262,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3535,'parameter | concepts',3262,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3536,'parameter | control file',3262,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3537,'parameter | redo',3262,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3538,'select',3262,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3539,'select | parameter',3262,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3540,'select | redo log',3262,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3541,'select | redo log file',3262,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3542,'tool',3262,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3543,'trace | dbms',3262,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3544,'trace | operation',3262,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3545,'trace | parameter',3262,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3546,'trace | view',3262,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3547,'view',3262,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3548,'view | control file',3262,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3549,'view | redo log',3262,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3550,'dbms',3263,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3551,'declare',3263,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3552,'plsql',3263,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3553,'plsql function',3263,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3554,'plsql | exception',3263,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3555,'plsql | key',3263,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3556,'plsql | parameter',3263,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3557,'plsql | pragma',3263,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3558,'plsql | s',3263,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3559,'plsql | syntax | functin',3263,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3560,'plsql | view',3263,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3561,'trigger | o',3263,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3562,'data file | select',3264,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3563,'data file | view',3264,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3564,'O',3265,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3565,'job | o',3265,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3566,'job | parameter',3265,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3567,'job | s',3265,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3568,'job | v',3265,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3569,'scheduler | dbms',3265,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3570,'scheduler | operation',3265,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3571,'scheduler | privile',3265,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3572,'scheduler | scheduler',3265,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3573,'scheduler | select',3265,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3574,'scheduler | view',3265,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3575,'select',3265,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3576,'instance',3266,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3577,'io tuning',3266,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3578,'parameter',3266,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3579,'rac',3266,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3580,'rac | service',3266,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3581,'redo',3266,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3582,'select',3266,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3583,'session',3266,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3584,'sql',3266,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3585,'temp',3266,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3586,'transaction',3266,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3587,'tuning',3266,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3588,'data pump | c',3267,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3589,'data pump | o | expdp',3267,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3590,'data pump | o | impdp',3267,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3591,'data pump | s',3267,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3592,'dir | o',3267,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3593,'dir | v',3267,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3594,'external table',3267,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3595,'plsql',3267,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3596,'sqlldr',3267,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3597,'connect',3268,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3598,'db link',3268,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3599,'listener',3268,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3600,'asmiostat | o',3269,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3601,'concepts',3269,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3602,'dbms',3269,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3603,'operation',3269,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3604,'parameter',3269,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3605,'select',3269,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3606,'view',3269,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3607,'operation',3270,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3608,'select',3270,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3609,'abc',3271,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3610,'script',3271,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3611,'authenticate | concetps',3272,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3612,'orapwd | operation',3272,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3613,'orapwd | parameter',3272,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3614,'orapwd | view',3272,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3615,'plsql',3272,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3616,'curosr',3273,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3617,'join',3273,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3618,'script',3273,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3619,'select',3273,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3620,'sequence',3273,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3621,'sequence | view',3273,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3622,'sql',3273,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3623,'sql function',3273,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3624,'sql function | group by',3273,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3625,'sql function | 分析函数',3273,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3626,'sql function | 字符函数',3273,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3627,'sql function | 数字函数',3273,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3628,'sql function | 日期函数',3273,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3629,'sql function | 正则表达式',3273,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3630,'sql function | 聚合函数',3273,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3631,'sql function | 转换函数',3273,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3632,'sql tuning',3273,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3633,'sys_context',3273,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3634,'伪列 | view',3273,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3635,' statspack',3274,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3636,'addm | D',3274,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3637,'addm | O',3274,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3638,'addm | P',3274,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3639,'addm | V',3274,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3640,'awr | o',3274,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3641,'awr | p',3274,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3642,'awr | select',3274,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3643,'awr | v',3274,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3644,'operation | adrci',3274,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3645,'parameter | adrci',3274,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3646,'parameter | awr',3274,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3647,'select',3274,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3648,'tom | runtats',3274,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3649,'FOREIGN KEY | O',3275,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3650,'FOREIGN KEY | S',3275,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3651,'operation',3275,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3652,'primary key | o',3275,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3653,'test',3275,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3654,'view',3275,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3655,'dbms',3276,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3656,'latch',3276,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3657,'lock',3276,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3658,'operation | lock',3276,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3659,'parameter | lock',3276,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3660,'select',3276,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3661,'tablespace',3277,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3662,'undo',3277,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3663,'error',3278,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3664,'install',3279,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3665,'operation | install',3279,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3666,'upgrade | concepts',3279,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3667,'concepts',3280,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3668,'connect',3280,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3669,'latch',3280,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3670,'lock',3280,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3671,'rac',3280,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3672,'recovery',3280,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3673,'test',3280,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3674,'view | consumer',3281,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3675,'AUTHEN | parameter',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3676,'characters | parameter',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3677,'characters | v',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3678,'concepts',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3679,'database | parameter',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3680,'database | view',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3681,'date | parameter',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3682,'dbca | c',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3683,'dbms | database',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3684,'ma | cdb em | operation',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3685,'ma | cdb em | privileg',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3686,'ma | cdb | concepts',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3687,'ma | cdb | select',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3688,'ma | concepts',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3689,'ma | parameter',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3690,'ma | pdb | operation',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3691,'ma | privilge',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3692,'ma | view',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3693,'parameter | select',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3694,'process | concepts',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3695,'process | parameter',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3696,'process | view',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3697,'select | database',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3698,'session | operation',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3699,'session | parameter',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3700,'session | select',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3701,'session | view',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3702,'support',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3703,'sysaux | select',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3704,'view | operation',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3705,'view | other',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31'),(3706,'view | view',3282,'2016-04-06 22:53:31','2016-04-06 22:53:31');
/*!40000 ALTER TABLE `category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `content`
--

DROP TABLE IF EXISTS `content`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `content` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `content_1` varchar(2000) DEFAULT NULL,
  `content_2` varchar(5000) DEFAULT NULL,
  `category_id` int(11) NOT NULL,
  `createdata` datetime NOT NULL,
  `updatedata` datetime NOT NULL,
  `document_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `category_id` (`category_id`),
  KEY `document_id` (`document_id`)
) ENGINE=InnoDB AUTO_INCREMENT=3802 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `content`
--

LOCK TABLES `content` WRITE;
/*!40000 ALTER TABLE `content` DISABLE KEYS */;
INSERT INTO `content` VALUES (1,'test','test',2,'2016-03-28 23:08:22','2016-03-28 23:08:22',NULL),(3,'file -i','-i 查看文件字符集',14,'2016-03-28 00:00:00','2016-03-28 00:00:00',NULL),(6,'Action {\r\n  Ok(\"Hello world\")\r\n}','???',20,'2016-03-30 00:00:00','2016-03-30 00:00:00',NULL),(7,'Action { request =>\r\n  Ok(\"Got request [\" + request + \"]\")\r\n}','',20,'2016-03-30 00:00:00','2016-03-30 00:00:00',NULL),(8,'Action { implicit request =>\r\n  Ok(\"Got request [\" + request + \"]\")\r\n}','使用implicit关键字，当其他api需要隐式的调用request',20,'2016-03-30 00:00:00','2016-03-30 00:00:00',NULL),(9,'Action(parse.json) { implicit request =>\r\n  Ok(\"Got request [\" + request + \"]\")\r\n}','???',20,'2016-03-30 00:00:00','2016-03-30 00:00:00',NULL),(10,'Action的作用','play.api.mvc.Action 的作用是把 play.api.mvc.Request 变成 play.api.mvc.Result 返回给cliect\r\n也就是收到请求，并给出结果，返回给客户端',20,'2016-03-30 00:00:00','2016-03-30 00:00:00',NULL),(11,'Action(parse.json) { implicit request =>\r\n  Ok(\"Got request [\" + request + \"]\")\r\n}','',20,'2016-03-30 00:00:00','2016-03-30 00:00:00',NULL),(13,'val ok = Ok(\"Hello world!\")\r\nval notFound = NotFound\r\nval pageNotFound = NotFound(<h1>Page not found</h1>)\r\nval badRequest = BadRequest(views.html.form(formWithErrors))\r\nval oops = InternalServerError(\"Oops\")\r\nval anyStatus = Status(488)(\"Strange response type\")','???',22,'2016-03-30 00:00:00','2016-03-30 00:00:00',NULL),(14,'import play.api.http.HttpEntity\r\n\r\ndef index = Action {\r\n  Result(\r\n    header = ResponseHeader(200, Map.empty),\r\n    body = HttpEntity.Strict(ByteString(\"Hello world!\"), Some(\"text/plain\"))\r\n  )\r\n}','直接定义结果',22,'2016-03-30 00:00:00','2016-03-30 00:00:00',NULL),(15,'play.api.mvc.Results','play提供的结果都在这个特质里面',22,'2016-03-30 00:00:00','2016-03-30 00:00:00',NULL),(16,'Redirect(\"/user/home\")\r\nRedirect(\"/user/home\", MOVED_PERMANENTLY)','转跳',22,'2016-03-30 00:00:00','2016-03-30 00:00:00',NULL),(17,'def index(name:String) = TODO','TODO dummy page',20,'2016-03-30 00:00:00','2016-03-30 00:00:00',NULL),(18,'提供的方法','GET, PATCH, POST, PUT, DELETE, HEAD',23,'2016-03-30 00:00:00','2016-03-30 00:00:00',NULL),(19,'GET   /clients/all          controllers.Clients.list()','静态路径',23,'2016-03-30 00:00:00','2016-03-30 00:00:00',NULL),(20,'GET   /clients/:id          controllers.Clients.show(id: Long)','动态路径',23,'2016-03-30 00:00:00','2016-03-30 00:00:00',NULL),(21,'GET   /files/*name          controllers.Application.download(name)','假设url是GET /files/images/logo.png\r\n那么就捕获images/logo.png ',23,'2016-03-30 00:00:00','2016-03-31 00:00:00',NULL),(22,'GET   /items/$id<[0-9]+>    controllers.Items.show(id: Long)','使用正则表达式',23,'2016-03-30 00:00:00','2016-03-30 00:00:00',NULL),(24,'yum install -y ntpdate','???',24,'2016-03-30 00:00:00','2016-03-30 00:00:00',NULL),(25,'时间服务器','time.windows.com',24,'2016-03-30 00:00:00','2016-03-30 00:00:00',NULL),(27,'???','yum -y install yum-utils\r\n使用yum-utils中的yumdownloader工具\r\n#查看工具是否存在\r\nrpm -ql yum-utils| grep yumdownloader\r\n#使用工具下载rpm,例子:下载gcc,他默认是放在当前目录\r\nyumdownloader gcc',25,'2016-03-30 00:00:00','2016-03-30 00:00:00',NULL),(28,'group','#列出所有可以安装的GroupList\r\n yum grouplist\r\n#查看\r\n yum groupinfo <groupname>\r\n#安装\r\n yum groupinstall <groupname>\r\n#更新\r\n yum groupupdate <groupname>\r\n#移除\r\n yum groupremove <groupname>',25,'2016-03-30 00:00:00','2016-03-30 00:00:00',NULL),(29,'查看系统中启动的yum资源','yum repolist { enabled | disabled | all }',25,'2016-03-30 00:00:00','2016-03-30 00:00:00',NULL),(30,'EPEL','	\r\nyum install epel-release\r\n',26,'2016-03-30 00:00:00','2016-03-30 00:00:00',NULL),(31,'WANdiscoSVN','/etc/yum.repos.d/wandisco-svn.repo:\r\nname=WANdisco SVN Repo 1.8\r\nenabled=1\r\nbaseurl=http://opensource.wandisco.com/centos/6/svn-1.8/RPMS/$basearch/\r\ngpgcheck=1\r\ngpgkey=http://opensource.wandisco.com/RPM-GPG-KEY-WANdisco',26,'2016-03-30 00:00:00','2016-03-30 00:00:00',NULL),(32,'yum install bind-utils','',27,'2016-03-30 00:00:00','2016-03-30 00:00:00',NULL),(33,'lsof（list open files）是一个列出当前系统(进程)打开文件的工具。','???',28,'2016-03-30 00:00:00','2016-03-30 00:00:00',NULL),(34,'编译安装','yum install -y gcc zlib-devel pcre-devel make wget tar\r\nwget http://nginx.org/download/nginx-1.6.2.tar.gz\r\ntar zxvf nginx-1.6.2.tar.gz\r\ncd nginx-1.6.2 && ./configure --prefix=/usr/local/nginx && make && make install\r\n/usr/local/nginx/sbin/nginx',30,'2016-03-30 00:00:00','2016-03-30 00:00:00',NULL),(35,'nginx 1.9 tcp负载','???',30,'2016-03-30 00:00:00','2016-03-30 00:00:00',10000),(36,'concat','合并2个列为一个字符串\r\nselect concat(a,\'-\',b) from',40,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(37,'substr','截取字符串',40,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(38,'创建表，并使用orc存储','create table Addresses (\r\n  name string,\r\n  street string,\r\n  city string,\r\n  state string,\r\n  zip int\r\n) stored as orc tblproperties (\"orc.compress\"=\"NONE\");',42,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(39,'配置mysql作为元数据存储','???',43,'2016-03-31 00:00:00','2016-03-31 00:00:00',10001),(40,'执行shell','import os\r\ntasks = os.popen(\'curl -X GET -H \"Accept: application/json\" http://192.168.12.40:8080/v2/apps/nginx421a/tasks\').read()',44,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(41,'https://repo.typesafe.com/typesafe/releases/\r\nhttps://repository.apache.org/content/groups/public/\r\nhttps://github.com/InMobi/mvn-repo/raw/master/snapshots/\r\nhttps://repo.maven.apache.org/maven2/\r\nhttps://repository.cloudera.com/artifactory/cloudera-repos/\r\nhttp://repo.spring.io/ext-release-local\r\nhttp://repo.spring.io/libs-release\r\nhttp://repository.apache.org/snapshots','???',51,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(42,'使用socks5代理','在jvm参数中添加\r\n-DsocksProxyHost=127.0.0.1  -DsocksProxyPort=9700',47,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(43,'http://repos.fedorapeople.org/repos/dchen/apache-maven/epel-apache-maven.repo','???',51,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(44,'安装apache 2.4.12','centos6.5 64',53,'2016-03-31 00:00:00','2016-03-31 00:00:00',10002),(45,'5.6版本','修改/etc/my.cnf配置文件\r\n\r\n[mysqld]\r\ncharacter-set-server=utf8\r\n\r\n[mysql]\r\ndefault-character-set=utf8\r\n查看\r\n\r\nmysql> show variables like \'character%\';',55,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(46,'alt + command + l','格式化代码',59,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(47,'ctrl+j','生成常规函数，比如main',58,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(48,'快捷键列表(mac)','???',59,'2016-03-31 00:00:00','2016-03-31 00:00:00',10003),(49,'debug','	\r\nF9            resume programe 恢复程序\r\nAlt+F10       show execution point 显示执行断点\r\nF8            Step Over 相当于eclipse的f6      跳到下一步\r\nF7            Step Into 相当于eclipse的f5就是  进入到代码\r\nAlt+shift+F7  Force Step Into 这个是强制进入代码\r\nShift+F8      Step Out  相当于eclipse的f8跳到下一个断点，也相当于eclipse的f7跳出函数\r\nAtl+F9        Run To Cursor 运行到光标处\r\nctrl+shift+F9   debug运行java类\r\nctrl+shift+F10  正常运行java类\r\nalt+F8          debug时选中查看值',58,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(50,'Ctrl + Alt + O ','优化import自动去除无用的import语句，蛮不错的一个功能。 ',58,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(51,'Ctrl + Alt + Shift + L','格式化当前文件代码',58,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(52,'CTRL + SHIFT + U','大小写切换',58,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(53,'编译consul-template','???',62,'2016-03-31 00:00:00','2016-03-31 00:00:00',10004),(54,'检查表是否存在','println(Await.result(db.run(MTable.getTables), Duration.Inf).toList)',64,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(55,'can\'t find method result on TableQuery with slick 3.0.0-RC1','I did hit the same problem and here is what I did to get rid of it:\r\n\r\nUpdated IntelliJ to version 14.1.3\r\nUsed Scala Plugin version 1.5\r\nMy scala version is 2.11.6\r\n\r\nI hope this helps somebody who might run into the same problem!',65,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(57,'zeppelin配置--yarn','zeppelin-env.sh\r\n  MASTER=yarn-client\r\n  HADOOP_CONF_DIR=/xxx/etc/hadoop\r\nbin/zeppelin-daemon.sh start',71,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(58,'在某个项目中，使用自己的仓库\r\n','在build.gradle文件中添加如下:\r\nrepositories {\r\n    maven {\r\n        url \"http://repo.mycompany.com/maven2\"\r\n    }\r\n}',50,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(59,'dir','内存dump到磁盘的位置\r\n可以在cli中用save手动刷,或shutdown save',72,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(60,'???','???',73,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(61,'-Xmx100m','最大head内存',74,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(62,'jconsole.exe','图形化用户界面的监测工具，主要用于监测并显示运行于Java平台上的应用程序的性能和资源占用等信息。',75,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(63,'jstat -gcutil','',76,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(64,'1. jmap -dump:live,file=a.map \r\n2. jhat a.map ','???',77,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(66,'application/java-archive','???',80,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(67,'400','Bad Request\r\nHTTP 1.1 中头缺失HOST协议，就回报400',81,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(68,'# The version parameter is optional. E.g. /api/list-all?version=3.0\r\nGET   /api/list-all         controllers.Api.list(version: Option[String])','可选参数',23,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(69,'routes.Application.hello','把action方法作为url',23,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(70,'Ok(\"Hello World!\")','Content-Type 自动设置为 text/plain',82,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(71,'Ok(<message>Hello World!</message>.as(\"application/xml\")','xml',82,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(72,'Ok(<h1>Hello World!</h1>).as(\"text/html\")\r\nOk(<h1>Hello World!</h1>).as(HTML)','使用HTML和使用text/html区别是使用HTML play会自动设置为text/html; charset=utf-8',82,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(73,'改变http responses text的charset 值','class Application extends Controller {\r\n\r\n  implicit val myCustomCharset = Codec.utf_8\r\n//  implicit val myCustomCharset = Codec.javaSupported(\"iso-8859-1\")\r\n\r\n  def index = Action {\r\n    Ok(<h1>Hello World!</h1>).as(HTML)\r\n  }\r\n\r\n}',82,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(74,'Ok(\"Welcome!\").withSession(\"connected\" -> \"user@gmail.com\")','设置session的值',83,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(75,'Ok(\"Hello World!\").withSession(request.session + (\"saidHello\" -> \"yes\"))','在session中添加值',83,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(76,'Ok(\"Theme reset!\").withSession(request.session - \"theme\")','移除session的值',83,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(77,'def index = Action { request =>\r\n  request.session.get(\"connected\").map { user =>\r\n    Ok(\"Hello \" + user)\r\n  }.getOrElse {\r\n    Unauthorized(\"Oops, you are not connected\")\r\n  }\r\n}','从action中读取session的值',83,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(78,'Ok(\"Bye\").withNewSession','开启一起新的session，等价于开启一个无值的session，等价于丢失上一个session保存的值',83,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(79,'text/plain','当设置为此值时，浏览器不会对body中的数据做处理，只是简单的当作文本展示出来',80,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(80,'text/html','浏览器把body的内容作为html数据解析后展示出来',80,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(81,'ActionBuilder','在Action中添加逻辑',85,'2016-03-31 00:00:00','2016-03-31 00:00:00',10005),(82,'dmesg','查看系统启动信息',13,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(83,'ActionTransformer','在request中添加信息\r\n具体来说就是你想在request中点出你自定义的属性：比如:request.user',85,'2016-03-31 00:00:00','2016-03-31 00:00:00',10006),(84,'ActionFilter','想在某些条件下过滤请求，并立即返回结果',85,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(85,'ActionRefiner','在某些条件下，增加一些定制的信息到request中',85,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(86,'泛型类','class Pair[T, S](val first: T, val second: S)\r\nval abc = new Pair(\"a\", 1)\r\nval abc2 = new Pair[String,Int](\"a\",1)  //显示的指定类型',88,'2016-03-31 00:00:00','2016-03-31 00:00:00',NULL),(87,'泛型函数','def getFun[T](a: Array[T]) = a.length\r\nval a1 = Array(1,2,3);\r\ngetFun(a1);\r\ngetFun[Int](a1);\r\nval a2 = Array(\"1\",\"2\",\"3\");\r\ngetFun(a1)\r\ngetFun[String](a2)',88,'2016-03-31 00:00:00','2016-04-01 00:00:00',NULL),(88,' yum -y install openssh-clients','???',89,'2016-04-01 00:00:00','2016-04-01 00:00:00',NULL),(89,'apexins.sql 	\r\n','--安装apex\r\n例子：@apexins.sql USERS USERS TEMP /i/',91,'2016-04-01 00:00:00','2016-04-01 00:00:00',NULL),(90,'apxremov.sql\r\n','--删除apex',91,'2016-04-01 00:00:00','2016-04-01 00:00:00',NULL),(91,'admin','http://hostname:port/ords/apex_admin',93,'2016-04-01 00:00:00','2016-04-01 00:00:00',NULL),(92,'开发\r\n','http://hostname:port/ords/apex',93,'2016-04-01 00:00:00','2016-04-01 00:00:00',NULL),(93,'打开web控制台','java -cp h2-1.4.187.jar  org.h2.tools.Server',94,'2016-04-01 00:00:00','2016-04-01 00:00:00',NULL),(94,'打开H2控制台(web)','$TYPESAFE_HOME//activator.bat h2-browser\r\n$TYPESAFE_HOME//activator h2-browser',96,'2016-04-01 00:00:00','2016-04-01 00:00:00',NULL),(95,'类型变量界定 T<:Comparable[T]，界定T是Comparable的子类型','class A\r\nclass A1 extends A\r\ndef fun[R <: A](a: R) = println(a.getClass)\r\nfun(new A1)\r\n\r\n',88,'2016-04-01 00:00:00','2016-04-01 00:00:00',NULL),(96,'类型变量界定 下界\r\n定义T是R的子类','class Pair[T](val first: T, val second: T) {\r\n  def replaceFirst[R >: T](newFirst: T) = new Pair[R](newFirst, second)\r\n  //或者 def replaceFirst[R >: T](newFirst: T) = new Pair(newFirst, second)\r\n}\r\nor\r\nclass A\r\nclass A1 extends A\r\ndef fun[R >: A1](a: R) = println(a.getClass)\r\nfun(new A)',88,'2016-04-01 00:00:00','2016-04-01 00:00:00',NULL),(97,'视图界定','???',88,'2016-04-01 00:00:00','2016-04-01 00:00:00',NULL),(98,'型变 +','class A\r\nclass A1 extends A\r\nclass P[+T]\r\ndef fun[R <: P[A]](a: R) = println(a.getClass)\r\nfun(new P[A1])\r\n\r\nps:如果P[T]不用P[+T]，那么fun执行会报错,因为A1是A的子类，但是P[A1]不是P[A]的子类,+T意思跟着一起变\r\n',88,'2016-04-01 00:00:00','2016-04-01 00:00:00',NULL),(99,'型变 -','class A\r\nclass A1 extends A\r\nclass Friend[-T]\r\ndef fun(f: Friend[A1]) = println(f.getClass)\r\nfun(new Friend[A])',88,'2016-04-01 00:00:00','2016-04-01 00:00:00',NULL),(100,'scp -P','指定端口',111,'2016-04-01 00:00:00','2016-04-01 00:00:00',NULL),(101,'scp -v ','显示进度',111,'2016-04-01 00:00:00','2016-04-01 00:00:00',NULL),(102,'2.1 字符集','js是用unicode字符集编写',118,'2016-04-04 00:00:00','2016-04-04 00:00:00',NULL),(103,'2.1.1 区分大小写','javascript是区分大小写的',118,'2016-04-04 00:00:00','2016-04-04 00:00:00',NULL),(104,'2.1.2 空格、换行符和格式控制符','在js中可以随意使用空格和换行，在2.5中有一种意外情况',118,'2016-04-04 00:00:00','2016-04-04 00:00:00',NULL),(105,'2.1.3 unicode转义序列','',118,'2016-04-04 00:00:00','2016-04-04 00:00:00',NULL),(106,'2.1.4 标准化','???',118,'2016-04-04 00:00:00','2016-04-04 00:00:00',NULL),(107,'2.2 注释','// 单行注释\r\n/*...*/ 多行注释',118,'2016-04-04 00:00:00','2016-04-04 00:00:00',NULL),(108,'2.3 直接量','直接量的意思，直接使用数据值，如:\r\n12 //数字\r\ntrue //布尔值',118,'2016-04-04 00:00:00','2016-04-04 00:00:00',NULL),(109,'2.4 标识符和保留字','标识符就是一个名字，用于对变量和函数进行命名，或者用作某些循环语句中的跳转位置的标记。\r\njs标识符必须以字母，下划线或美元符开始。后续的字符可以是字母、数字、下划线或美元符(数字是不允许作为首字符出现的)',118,'2016-04-04 00:00:00','2016-04-04 00:00:00',NULL),(110,'2.4 标识符和保留字','保留字:\r\n  break delete function return typeof case do if switch var catch else \r\n  in this void continue false instanceof throw while debugger finally \r\n  new true with default for null try\r\nECMAScript5中的保留字:\r\n  class const enum export extends import super\r\n以下关键字在严格模式下是保留字:\r\n  implements let private public yield interface package protected static\r\n严格模式下对下列标识符做了严格限制，不能用作变量名、函数名或参数名\r\n  arguments eval\r\nECMAScript3保留字:\r\n',118,'2016-04-04 00:00:00','2016-04-04 00:00:00',NULL),(1918,'v$system_event','--',3501,'2016-04-06 23:26:39','2016-04-06 23:26:39',NULL),(2081,'V$SYSTEM_EVENT','--',3526,'2016-04-06 23:26:40','2016-04-06 23:26:40',NULL),(2221,'V$SQL_PLAN_STATISTICS_ALL','V$SQL_PLAN_STATISTICS_ALL contains memory usage statistics for row sources that use SQL memory (sort or hash-join). This view concatenates information in V$SQL_PLAN with execution statistics from V$SQL_PLAN_STATISTICS and V$SQL_WORKAREA.',3584,'2016-04-06 23:26:41','2016-04-06 23:26:41',NULL),(2287,'BACKGROUND_DUMP_DEST',NULL,3604,'2016-04-06 23:26:41','2016-04-06 23:26:41',NULL),(2299,'Buffer Busy Waits','\"检查和处理方法\"',3283,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2300,'db file scattered read','分散读',3283,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2301,'db file sequential read','连续读',3283,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2302,'direct path read and direct path read temp','直接路径读/直接路径临时读',3283,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2303,'direct path write and direct path write temp','直接路径写/直接路径临时写',3283,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2304,'enqueue (enq) waits','等待一个lock',3283,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2305,'free buffer waits','空余buffer等待',3283,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2306,'virtual circuit wait','--由于客户端连接共享服务器所致\nhttp://blog.chinaunix.net/uid-116213-id-3730088.html',3283,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2307,'cache buffer chains','cache chain争用',3283,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2308,'CACHE BUFFER LRU CHAIN','lru争夺',3283,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2309,'PX Deq Credit: send blkd','--说明在执行的sql语句中的表开启了并行，但是他不适合并行，导致并行进程之间交换数据产生性能问题。',3283,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2310,'events in waitclass Other','http://www.itpub.net/thread-1403458-1-1.html',3283,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2311,'v$system_event','整个instance级别的event和time.\n当time_statistics设置为true时，这个试图包含时间统计\n',3284,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2312,'v$session_history','显示连接中的session中，最后10个等待的event.',3284,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2313,'v$session_event','显示连接中的session.累计的event。如果用于exit，那么这个session在这个视图中event，被移除',3284,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2314,'V$SESS_TIME_MODEL ','--',3285,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2315,'V$SYS_TIME_MODEL','--',3285,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2316,'BINARY_FLOAT和BINARY_DOUBLE','简介/使用DOC-1861/1862/1863',3286,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2317,'char/varchar2/nvarchar2/nchar','\"使用说明\"',3286,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2318,'systimestamp','--NUMTODSINTERVAL(1,\'DAY\'),\nNUMTODSINTERVAL(1,\'hour\'),\nNUMTODSINTERVAL(1,\'MINUTE\'),\nNUMTODSINTERVAL(1,\'SECOND\'),\n',3286,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2319,'ROWID','--10个字节的地址。\n定位一行的地址',3286,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2320,'UROWID','--用于IOT，没有固定rowID的表示方式，\n他是行主键值的表示',3286,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2321,'raw','--',3286,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2322,'BFILE','--在DB中存储一个oracle目录对象(操作系统目录的一个指针)和一个文件名，并读取这个文件',3286,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2323,'BLOB','--允许存储4GM数据\n在10G以上版本，可以存储4GB*10（db_block size）。\n存储二进制',3286,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2324,'clob','--存储4GB数据，\n在10G以上版本，可以存储4GB*10（db_block size）。',3286,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2325,'NCLOB','--4GB数据',3286,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2326,'nls_length_semantics','--默认定义数据类型，以字节，还是字符来定义\n',3287,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2327,'查看数据在数据库中如何存储','--select dump(column_name)  dump from dual;',3288,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2328,'NLS_CHARACTERSET','--',3289,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2329,'维度','重要概念',3290,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2330,'验证维度有效性','dbms_dimension来验证',3291,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2331,'star_transformation_enabled','--设置是否开启，允许优化器重写将事实表的维度联结在一起的查询',3292,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2332,'基于函数的索引---可以为指定key建立索引\n从而缩小index size','例如表T上processed_flag列内有很多值，我只为值为N的值，建立索引',3293,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2333,'b*tree---反向键索引测试','反向键索引和正常索引的区别主要在buffer BUSY WANITS上.',3293,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2334,'b*tree---降序索引的概念和用户/测试','#降序索引，用于减少排序操作，在执行计划中。',3293,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2335,'B*TREE---B*TREE索引适用在哪种情况','1.只有当访问表中很少一部分行的情况下.\n2.可以只用索引来回答查询，而不需要使用表的情况下,那这样的查询访问表中多少行都没有关系。\n',3293,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2336,'B*TREE---性能相关---物理组织(INDEX RANGE SCAN)','如何物理的组织列的数据，非常影响INDEX RANGE SCAN的性能',3293,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2337,'BITMAP---DML语句相互限制实验','INSERT/UPDATE/DELETE/相互作用，查看阻塞情况。',3293,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2338,'B*TREE---性能相关---聚簇因子2','主要是针对RANGE SCAN有影响。',3293,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2339,'基于函数的索引---ORA-04150','#创建自建函数的基于函数的索引碰到的错误。\n#如果index 的key的长度超过block的限制，就会报这个错。这个错误的起因是函数的返回值，返回的类型是VARCHAR2(4000);',3293,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2340,'基于函数的索引---ORA-01743','ORA-01743警告,关于创建基于函数索引的不确定性所引发的错误',3293,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2341,'B*TREE---概念:视图是不能建立索引的','#你可以建立在表上。',3293,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2342,'b*tree---压缩键索引的概念和实验','#压缩键索引概念\n#查看压缩效果，和，过度压缩的效果。',3293,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2343,'BITMAP---适用环境','BITMAP适用于查询环境，不适用于插入或UPDATE频繁的环境。',3293,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2344,'几种不走索引的原因',NULL,3293,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2345,'索引BLOCK空间可以被重用','如果一个索引BLOCK上有1~10个KEY，其中5被删除掉了，那么这个5不会被11或13或100给重用，这是肯定的，如果这个BLOCK上的KEY全被删除了，那么整个BLOCK可以被其他KEY重用。',3293,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2346,'建立索引时，不同的列的前后顺序的区别.','一般认为，列上的重复值少的应该排在前面，多的排在后面，但是未必一样要这样。',3293,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2347,'b*tree---B*TREE的一些感念','#B*TREE索引的结构概念\n#对于INDEX RANGE SCAN，如SELECT * FROM T WHERE BETWEEN 20 AND 30，索引的查找方式\n#B*TREE索引中不存在非唯一(NONUIQUE)条目',3293,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2348,'b*tree---反向键索引的概念','#反向键索引\n#观察反向键索引如何存储的?\n#反向键索引的限制',3293,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2349,'B*TREE---性能相关---聚簇因子(clustering factor)','影响 INDEX RANGE SCAN',3293,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2350,'基于函数的索引---使用自建的函数','#使用自建的函数，必须在函数中加入deterministic。\n#测试自建函数使用和不适用deterministic的性能差异\n#测试使用和不使用基于函数的索引的差别。\n#测试insert到有基于函数索引的表的性能差别。',3293,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2351,'基于函数的索引---实现有选择的唯一性','#始终保持表中某一个状态的命名，只有一个。具体见文档',3293,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2352,'B*TREE---和NULL的关系','#B*TREE索引不是不存储NULL，而是不存储完全为NULL的条目。',3293,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2353,'B*TREE---外键应该和不应该加索引的情况','1.加索引的情况\n2.不加索引的情况\n3.测试某个子表由于外键未加索引，而被锁住.',3293,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2354,'不可见索引(INVISITBLE INDEX):','#概念\n#不可见索引的使用例子',3293,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2355,'对Null创建索引','--SELECT * FROM T_XIFENFEI WHERE OBJECT_ID IS NULL;\ncreate index ind_object_id on t_xifenfei(object_id,0);',3293,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2356,'索引操作','\"create/alter/drop\"',3294,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2357,'建立自定义的索引','当索引的索引类型都达不到要求的情况下，自己来创建一个表，作为索引.\n比如where like \'%XXXX%\';就是什么索引都无法起作用。',3294,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2358,'开启索引监控\n','SQL> ALTER INDEX index_name MONITORING USAGE;\n--开启有可以在V$OBJECT_USAGE查看',3294,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2359,'CREATE INDEX','--CREATE INDEX [SCHEMA.] index_name ON [SCHEMA.] table_name(column_name) [online]  [TABLESPACE TABLESPACE_NAME] [NOLOGGING] [parallel n];',3294,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2360,'rebuild index','--alter index idx_name rebuild [online] [nologging] [parallel n];\n',3294,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2361,'查看索引是否为不可见索引','SELECT INDEX_NAME ,VISIBILITY FROM DBA_INDEXES WHERE INDEX_NAME =\'XXX\';',3295,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2362,'查看表上的索引的聚簇因子和BLOCK','SELECT A.INDEX_NAME,B.NUM_ROWS,B.BLOCKS,A.CLUSTERING_FACTOR \nFROM USER_INDEXES A, USER_TABLES B WHERE A.TABLE_NAME IN(\'DISORGANIZED\',\'COLOCATED\')\nAND A.TABLE_NAME = B.TABLE_NAME;',3295,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2363,'查询某个索引，索引了哪个表的哪些列','select table_name,index_name,column_name,column_position from user_ind_columns \n	where index_name=\'xxx\' order by column_position;\n',3295,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2364,'查询表所使用的索引','select table_name,index_name from dba_indexes where table_name=\'xxx\';',3295,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2365,'OPTIMIZER_USE_INVISIBLE_INDEXES','#当值为TRUE时使得优化器把不可见索引视作普通索引看待。\n#session/system',3296,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2366,'DBA_INDEXES','ALL_INDEXES DESCRIBES THE INDEXES ON THE TABLES ACCESSIBLE TO THE CURRENT USER. \n使用DBMS_STATS包可以收集统计信息，放在这个视图中\n\nRELATED VIEWS\n•DBA_INDEXES DESCRIBES ALL INDEXES IN THE DATABASE.\n\n•USER_INDEXES DESCRIBES THE INDEXES OWNED BY THE CURRENT USER. THIS VIEW DOES NOT DISPLAY THE OWNER COLUMN.\n\nNOTE:\nCOLUMN NAMES FOLLOWED BY AN ASTERISK ARE POPULATED ONLY IF YOU COLLECT STATISTICS ON THE INDEX USING THE DBMS_STATS PACKAGE.',3296,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2367,'DBA_OBJECT_USAGE','监控索引\nDBA_OBJECT_USAGE displays statistics about index usage gathered from the database for all the indexes in the database. You can use this view to monitor index usage. All indexes that have been used at least once can be monitored and displayed in this view.\n\nRelated View\nUSER_OBJECT_USAGE displays statistics about index usage gathered from the database for the indexes owned by the current user.',3296,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2368,'v$object_usage','监控索引\nV$OBJECT_USAGE displays statistics about index usage gathered from the database for the indexes owned by the current user. You can use this view to monitor index usage. All indexes that have been used at least once can be monitored and displayed in this view.\n\nNote:\nThe V$OBJECT_USAGE view is deprecated in Oracle Database 12c Release 1 (12.1) and maintained for backward compatibility. Support for this view may be removed in a future release. Oracle recommends that you use the USER_OBJECT_USAGE view instead of the V$OBJECT_USAGE view.',3296,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2369,'DBA_IND_COLUMNS','--',3296,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2370,'index_stats','--',3296,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2371,'物化视图不执行的一种解决方法','--执行以下的前提，是检查alert没有错误，也看不出基表和物化视图两者有什么问题的前提下。\n--1.V$LOCK.TYPE(JI)，表示这个锁是锁住了一个物化视图，所以当我手动执行刷新的时候，hang住不动。\n--2.停止自动刷新的job(doc-2606)\n--3.kill掉执行自定刷新的session\n--4.如果kill的session没有释放object，那么去OS级别kill掉SPID\n--4.1可以尝试手动刷新,看看是否有问题，有的话执行5\n--5.启动job就可以了',3297,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2372,'现象','--创建物化视图，会创建一个和物化视图名字一样的表.',3297,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2373,'创建物化视图基本语法','\"参数等解释\"',3298,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2374,'创建分区的物化视图','--',3298,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2375,'QUERY_REWRITE_ENABLED',NULL,3299,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2376,'局部前缀索引和局部非前缀索引都可以来进行分区消除',NULL,3300,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2377,'分区索引分区种类/局部索引分类',NULL,3300,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2378,'全局索引概念','全局索引的索引键一定从该索引的索引分区键开始.',3300,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2379,'全局索引在线维护---以一种数据仓库技术来示范','数据仓库技术是:把新数据导入分区表，把老的分区导出到新的表，然后删除老的分区，在这个操作中的任何步骤，都会使得全局索引不可用。',3300,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2380,'局部索引和唯一性约束','如果要在分区索引上建立唯一性约束unipue/primary key，那么分区键必须包含在索引中，否则无法创建针对局部分区索引的唯一性约束',3300,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2381,'局部分区索引对OLTP性能影响','索引散列分区',3300,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2382,'全局索引\n--OLTP中使用全局索引同样可以带来分区消除\n--同时使用全局索引在OLTP中和非分区表性能同样好','关键在于,你的查询到底需不需要访问表，是否只要索引就可以回答你的查询。\ntom总结:使用全局索引，你同样可以得到、快速访问(不必非分区表读块多)/完整性(约束)/可用性(分区消除)。',3300,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2383,'局部索引和全局索引的使用范围','--1.局部更倾向与数据仓库\n2.全局索引更倾向于OLTP',3300,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2384,'hash分区索引','--CREATE INDEX IND_PART_INDEX_ID\n    ON T_PART_INDEX (ID) GLOBAL\n    PARTITION BY HASH (ID)\n    PARTITIONS 16;',3301,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2385,'重建分区索引','--alter index i_id_global rebuild partition p1  [online] [nologging] [parallel n] [tablespace ts_name];',3301,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2386,'全局索引--创建','--craete index g_idx1 on rang3l(data);',3301,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2387,'局部索引--前缀','--create index idx_name on part_name(col_name1,col_name2) local online TABLESPACE TS_NAME;\n--col_name1必须是分区表的分区键\n--1.选择表空间，同时查看这个TSextent的扩展是否符合即将要建立的index的大小\n--2.使用并行',3301,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2388,'局部索引--非前缀','--create index idx_name on part_name(col_name1,col_name2) local online;\n--col_name1不是是分区表的分区键，后面的col_namex是不是无所谓\n--1.选择表空间，同时查看这个TSextent的扩展是否符合即将要建立的index的大小\n--2.使用并行',3301,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2389,'散列分区索引','--create index t_idx on t(owner,object_type,object_name) \nglobal\npartition by hash(owner) partitions 16;\n',3301,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2390,'本地索引--创建','--create index g_idx1 on range1（data)LOCAL',3301,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2391,'DBA_PART_INDEXES','--',3302,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2392,'dba_ind_partitions','--',3302,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2393,'TOM对分区使用的建议','如果可以按照某个属性自然的对数据完成区间分区,那么就是用区间分区,而不是散列分区或列表分区。散列列表和列表分区能够提供优点，但是在分区消除方面不如区间分区。如果你像使用PDML功能或对一个区间分区使用并行索引扫描，则建议区间分区中再使用列表分区或散列分区。',3303,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2394,'分区对于OLAP系统的作用','TOM:分区非常适合OLAP系统，他可以消除扫描大的SEGMENT,而且可以频繁的使用并行查询。',3303,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2395,'分区对于OLTP系统的作用','TOM:OLTP很难在分区中得到性能的提高，而且使用分区要非常小心，但是分区对于OLTP而言可以得到管理负担减轻和更高可用性。',3303,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2396,'HASH PARTITION为什么分区数一定是2的幕','如果不是的话，数据分布将不均匀,例子见本文档',3303,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2397,'分区消除','--演示',3303,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2398,'分区表的row移动','--分区表row移动会改变rowid',3303,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2399,'分区表--允许行移动','ALTER TABLE TABLE_NAME ENABLE ROW MOVEMENT;	\n1.如果一个分区的行因为更新，而导致它不再属于这个分区，需要换分区，如果这个表不能行移动那么就会报错\n2.行移动的同时ROWID也会变化\n3.执行行移动(分区表),实际是删除一行，在插入一行。\n',3304,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2400,'区间分区','根据分区表定义的界限,这些分区的界限都是事先定义好的,然后把数据放入不同的分区下,他与间隔分区不同，区间分区不会自己创建(扩展)分区数\n--可以把不同的分区存放在一个TS下',3304,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2401,'散列分区','把数据平均分布到,创建分区表时定义的分区中,注意创建HASH 分区时分区数一定是2的幕.',3304,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2402,'组合分区','就是把不同的分区组合在一起.',3304,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2403,'间隔分区','类似于区间分区,不过他不用事先定义好各个分区,因为他可以自己根据情况创建分区.\n#为间隔分重命名.改为有意义的名字\nnumtoyminterval ( n, { \'YEAR\'|\'MONTH\'})\nnumtodsinterval ( n, { \'DAY\'|\'HOUR\'|\'MINUTE\'|\'SECOND\'})',3304,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2404,'列表分区','根据分区表中用来分区的列事先定义值,然后把匹配定义的值的数据放入相应的分区。',3304,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2405,'引用分区','--这是一个父子关系,是对父表进行分区，而子表是根据父表来分区，但是子表在创建时创建语句是没有分区子句的,而只是增加了一个外键的完整性约束,而且这个外键与父表的分区键无关。\n--当在父表中增加一个分区时，子表也会自动增加一个与之对应的分区。',3304,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2406,'创建分区表','各个分区表创建示例',3304,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2407,'区间分区--间隔转区间分区','--alter table 分区表名 set interval();--不用写间隔内容即转为区间分区。',3304,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2408,'区间分区--增加(拆分)分区','--ALTER TABLE rangel SPLIT PARTITION P4 AT (to_date(\'10/10/2018\',\'dd/mm/yyyy\')) \n   INTO (PARTITION t_range_p6, PARTITION t_range_pmax);\n--当要创建的分区的范围，已经属于某个分区的范围时，需要使用拆分，如果要创建的分区，不属于任何范围(包括不数据MAXVALUE)，只需要增加分区就可以了\n--指定所属的分区的范围的上限的分区，设置区间键值，insert到新的分区，并建立分区名。',3304,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2409,'区间分区--增加分区','--ALTER TABLE rangel ADD PARTITION P4 VaLUES LESS THAN(MAXVALUE) TABLESPACE ts0;\n--alter table orders add partition part_11 values less than(to_date(\'01-01-2012\',\'dd-mm-yyyy\'));',3304,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2410,'间隔分区--重命名分区名','--Alter table xxx rename partition partition_name to new_partition_name;',3304,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2411,'分区表--drop 分区','--alter table t_pe_r drop partition p3;',3304,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2412,'间隔分区--区间转间隔分区','--alter table 分区表名 set interval (numtoyminterval(1,\'month\'));  --根据分区列每月一个分区\n--alter table 分区表名 set interval (numtodsinterval (1,\'day\')); --根据分区列每天一个分区\n--转换范围到间隔分区需要把范围分区的maxvalue分区取消才能转换',3304,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2413,'分区表--移动分区','--alter table TAB_NAME move partition PART_NAME [tablespace xxx][update global indexes] ;\n',3304,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2414,'分区表--查询某个分区的数据','--SQL> select xxx from table_name partition(partiton_name);',3304,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2415,'组合分区','--',3304,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2416,'间隔分区--增加表空间','--alter table xxx set store in(TS_NAME_1[,TS_NAME_2]);',3304,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2417,'分区表--truncate 分区','--alter table sales3 truncate partition sp1 [update indexes]\n--[update indexes]如果这个在分区表上的索引是全局索引，那么就需要update indexes来维护索引，不然索引会不可用',3304,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2418,'查看分区对应的分区名','select partition_name,partition_position,num_rows\nfrom user_tab_partitions\nwhere table_name =\'T\' order by partition_position;',3305,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2419,'查看数据库中每个分区表的最大的分区','--select a1.table_owner,a1.table_name,a1.high_value \nfrom ALL_TAB_PARTITIONS a1,\n	(select table_owner,table_name,max(PARTITION_POSITION) PARTITION_POSITION \n		from ALL_TAB_PARTITIONS \n		where TABLE_OWNER not in(\'SYS\',\'SYSTEM\',\'SYSMAN\') \n		group by table_owner,table_name \n		order by 3\n	) a2 \nwhere a1.table_owner=a2.table_owner \nand a1.table_name=a2.table_name \nand a1.PARTITION_POSITION=a2.PARTITION_POSITION;',3305,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2420,'查系统中每个分区最新的3个分区','--select * from (\n		select table_owner,\n			table_name,\n			PARTITION_POSITION,\n			HIGH_VALUE,\n			rank()over(partition by table_owner,table_name order by partition_position desc) rn,\n                        INTERVAL\n		from ALL_TAB_PARTITIONS \n		where table_owner not in(\'SYS\',\'SYSTEM\',\'SYSMAN\') \n) where rn <4;',3305,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2421,'查看分区的大小','--select bytes/1024/1024,PARTITION_NAME,SEGMENT_NAME from dba_segments where segment_name=\'XXX\';',3305,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2422,'查看DB中的分区表','col owner for a20\ncol table_name for a20\nselect owner,table_name from dba_tables\n  WHERE OWNER NOT IN(\'SYS\',\'SYSTEM\',\'SYSMAN\') and partitioned=\'YES\' order by 1,2;',3305,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2423,'ALL_TAB_PARTITIONS','--ALL_TAB_PARTITIONS displays partition-level partitioning information, partition storage parameters, and partition statistics generated by the DBMS_STATS package for the partitions accessible to the current user.\n\nRelated Views\n\nDBA_TAB_PARTITIONS displays such information for all partitions in the database.\n\nUSER_TAB_PARTITIONS displays such information for the partitions of all partitioned objects owned by the current user. This view does not display the TABLE_OWNER column.\n\nNote:\nColumns marked with an asterisk (*) are populated only if you collect statistics on the table with the DBMS_STATS package.\nNote:\nThe following is true for the columns below that include double asterisks (**) in the column description:\nThe column can display information about segment-level attributes (for simple partitioned tables) or metadata (for composite partitioned tables). In a simple partitioned table, the partition physically contains the data (the segment) in the database. In a composite partitioned table, the partition is metadata and the data itself is stored in the subpartitions.',3306,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2424,'ALL_PART_TABLES','--ALL_PART_TABLES displays the object-level partitioning information for the partitioned tables accessible to the current user.\n\nRelated Views\n\n•DBA_PART_TABLES displays the object-level partitioning information for all partitioned tables in the database.\n\n•USER_PART_TABLES displays the object-level partitioning information for the partitioned tables owned by the current user. This view does not display the OWNER column.\n',3306,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2425,'创建同义词','--Create public synonym table_name for user.table_name;',3307,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2426,'设置不同的pctthreshold参数的实验',NULL,3308,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2427,'dbms_rowid.rowid_block_number(rowid)','通过rowid计算block号',3309,'2016-04-06 23:27:44','2016-04-06 23:27:44',NULL),(2428,'dbms_metadata.get_dll','--查看表的定义\n--set long 999999\n--select dbms_metadata.get_ddl(\'TABLE\',\'XXXXXX\',\'SCHEMA\') FROM DUAL;',3309,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2429,'index cluster table',NULL,3310,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2430,'index organized table',NULL,3310,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2431,'重命名表','sql>rename customer1 to customer;',3310,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2432,'虚拟列','#创建/增加/约束虚拟列。\n#虚拟列的注意事项\n',3310,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2433,'TEMP TABLE',NULL,3310,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2434,'hash cluster table','\"创建HASH table\"',3310,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2435,'table','\"一般操作\"',3310,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2436,'恢复set_unused的列','2013-07-13的知识水平，不建议使用，而且需要重启DB才能起效',3310,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2437,'操作文档','创建',3310,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2438,'修改表的字段长度','--alter table  表名   modify 字段名   varchar2(长度);',3310,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2439,'truncate table','--SQL> truncate table TAB_NAME [ { drop | reuse } storage ];\n--drop:默认选项，释放extent\n--reuse:删除数据，而不释放extent',3310,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2440,'回收为使用的extent','--SQL> ALTER TABLE tab_name DEALLOCATE UNUSED;',3310,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2441,'注释 | COLUMN','--COMMENT ON COLUMN [schema.]tab_name.col_name IS \'xxx\';\n',3310,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2442,'注释 | table','--COMMENT ON TABLE [schema.]tab_name IS \'xxx\';',3310,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2443,'修改column 默认值','----alter table sword1129.USERROLE MODIFY col_name DEFAULT 1;',3310,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2444,'复制表结构','--CREATE TABLE tab_name AS SELECT * FROM tab_name WHERE 1=0;\n--column的默认值，是不会被定义到新的table中的。',3310,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2445,'移动表','--ALTER TABLE table_name MOVE [TABLESPACE ts_name] [PARALLEL int]\n--move表中，insert，delete，update，drop，truncate中DML都会被堵塞,DDL会被报ora-00054的错误。\n--同时有dml操作时不能move table',3310,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2446,'限制每个block的行数','--alter table abc minimize records per block;',3310,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2447,'移动lob字段','--alter table t321 move lob(en) store as (tablespace users);',3310,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2448,'重命名列','--alter table mon_module_list rename column ITEM_NAME to module;',3310,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2449,'查询分区表所在的表空间的容量使用情况','SELECT B.TABLESPACE_NAME,\n	MBYTES_ALLOC,\n	MBYTES_FREE\nFROM(SELECT ROUND(SUM(BYTES)/1024/1024) MBYTES_FREE,\n			TABLESPACE_NAME\n		FROM DBA_FREE_SPACE\n		GROUP BY TABLESPACE_NAME) A,\n	(SELECT ROUND(SUM(BYTES)/1024/1024) MBYTES_ALLOC,\n			TABLESPACE_NAME\n		FROM DBA_DATA_FILES\n		GROUP BY TABLESPACE_NAME) B\nWHERE   A.TABLESPACE_NAME(+) = B.TABLESPACE_NAME \n	AND B.TABLESPACE_NAME IN(\'TS1\',\'TS0\')\n	/\n',3311,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2450,'查看表的pctfree/pctused','select pct_free,pct_used from dba_tables where table_name = \'table_assm2\'',3311,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2451,'查看表的存储属性','select dbms_metadata.get_ddl(\'table\',\'t\') from dual;',3311,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2452,'查看表是否是分区表','select table_name,partitioned from dba_tables;',3311,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2453,'查看clob对应的表','--SELECT A.TABLE_NAME,  A.COLUMN_NAME, B.SEGMENT_NAME, B.SEGMENT_TYPE, \n         B.TABLESPACE_NAME,  B.BYTES / 1024 / 1024,  B.BLOCKS, B.EXTENTS  \nFROM USER_LOBS A, USER_SEGMENTS B \n        WHERE A.SEGMENT_NAME = B.SEGMENT_NAME \n       ORDER BY B.BYTES DESC',3311,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2454,'查看表的并行度','--select table_name,degree from user_tables;',3311,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2455,'dba_tab_columns','--ALL_TAB_COLUMNS describes the columns of the tables, views, and clusters accessible to the current user. To gather statistics for this view, use the DBMS_STATS package.\n\nRelated Views\n\n•DBA_TAB_COLUMNS describes the columns of all tables, views, and clusters in the database.\n\n•USER_TAB_COLUMNS describes the columns of the tables, views, and clusters owned by the current user. This view does not display the OWNER column.\n',3312,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2456,'ALL_TAB_MODIFICATIONS','--ALL_TAB_MODIFICATIONS describes tables accessible to the current user that have been modified since the last time statistics were gathered on the tables.\n\nRelated Views\n\nDBA_TAB_MODIFICATIONS describes such information for all tables in the database.\n\nUSER_TAB_MODIFICATIONS describes such information for tables owned by the current user. This view does not display the TABLE_OWNER column.\n\nNote:\nThese views are populated only for tables with the MONITORING attribute. They are intended for statistics collection over a long period of time. For performance reasons, the Oracle Database does not populate these views immediately when the actual modifications occur. Run the FLUSH_DATABASE_MONITORING_INFO procedure in the DBMS_STATS PL/SQL package to populate these views with the latest information. The ANALYZE_ANY system privilege is required to run this procedure.',3312,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2457,'ALL_COL_COMMENTS','--查看表中列的注释',3312,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2458,'DBA_TABLES','--ALL_TABLESALL_TABLES describes the relational tables accessible to the current user. To gather statistics for this view, use the DBMS_STATS package.\n--标有*(星号)的column表示只有在DBMS_STATS收集之后才显示\n',3312,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2459,'dba_views','--',3313,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2460,'SHARED SERVER连接过程','见文档',3314,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2461,'创建DB link','--create database link geelyin96 connect to geelyin identified by geelyinpassword using \'192.168.1.1:1521/s216\'',3315,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2462,'直行远端DDL','--exec dbms_utility.EXEC_DDL_STATEMENT@mika(\'drop table t\')',3315,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2463,'查看dblink的信息','col owner for a20\ncol db_link for a20\ncol host for a30\nselect owner,db_link,HOST from dba_DB_LINKS where db_link=\'W210\';',3316,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2464,'set log_status [on | off]','--打开或关闭listener log\n--位置:/u01/app/diag/tnslsnr/localhost/listener/trace',3317,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2465,'remote_listener','--设置转调listener监听',3317,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2466,'remote_listener','--instance注册到另一台PC上的侦听器地址。',3318,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2467,'local_listener','--配置动态listener注册',3318,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2468,'动态注册','代码示例',3319,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2469,'注册DB到listener','SQL> alter system register;',3319,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2470,'静态注册','代码示例',3319,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2471,'shared_servers','--共享服务器进程数量',3320,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2472,'UTL_SMTP','发送MAIL,见文档',3321,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2473,'dbms_random.random','生成一个随机数',3321,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2474,'dbms_utility.get_hash_value','计算hash值/dbms_utility.get_hash_value（1,2,1024)\n1. 要被计算的位置是1\n2. 2是计算出来的hash值的起始值\n3. 1024是hash值的上限，是指，计算出来的hash本身不超过1024，不算和2号位置的相加。\nps其实计算出来的hash值本身而言，只和1和1024位置的值有关系，2号位置的意思，比如1号位置计算出来的值是100，而2个位置值是0，那么最后得到的值就是100，如果2号位置是5，那么得到的值就是105，看你需要的值了\"\n',3321,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2475,'dbms_lob.substr','相当于to_char，是不过to_char不能处理超过4000个字节的数据。/select dbms_lob.substr(\'aaa\') from dual;',3321,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2476,'dbms_utility.get_parameter_value','--获得参数',3321,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2477,'tab','--',3322,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2478,'col','--',3322,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2479,'多版本控制示例--plsql循环插入','通过t表本身做循环插入t表。',3323,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2480,'多版本控制示例--游标open','通过打开游标后，删除数据来观察多版本控制。',3323,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2481,'并发和多版本控制_01','脏读/不可重复读/幻像读; \nread uncommitted\nread committed\nrepeatable read\nserializable\nread only',3323,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2482,'并发和多版本控制_02','\"一种会失败的数据仓库技术\"',3323,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2483,'并发和多版本控制_04','\"写一致性。一致读会对update的影响。重启动update\"',3323,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2484,'并发和多版本控制_05','\"update会触发重启动，以及触发器对重启动的影响\"',3323,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2485,'查看块的事务槽是否满足块内行的并发修改数量','\"procedure.tom.201页\"',3324,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2486,'是否是Rac DB','--select value from v$system_parameter where name=\'cluster_database\';',3325,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2487,'segment管理方式','--select tablespace_name,segment_space_management from dba_tablespaces;',3326,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2488,'创建钱夹','\"创建和查看钱夹\"',3327,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2489,'列级加密','\"创建列级加密 | 加密列的限制 | 非列级加密改为列级加密 |对CLOB/BLOB加密\"',3327,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2490,'创建加密表空间','\"注意事项\"',3327,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2491,'列级加密效果试验','\"insert和select的效果\"',3327,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2492,'tom演示的手动加密方法','\"同时测试了手动加密和不加密的cpu时间。注:tom严重不推荐这个方法，只是用于了解\"',3327,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2493,'手动实现加密','\"见t-1048\"',3327,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2494,'测试列级加密的开销/副作用','\"cpu时间和redo生成量/副作用就是获取数据的基数变多，会使执行计划改变\"',3327,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2495,'测试表空间加密的性能影响','\"测试:普通插入，直接插入，plsql循环插入，主键读取等\"',3327,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2496,'DIY加密和列级加密和表空间加密的选择','\"tom解释什么情况下用什么.\"',3327,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2497,'将表移动到keep池','ALTER TABLE STATE_LIST STORAGE(buffer_pool keep);',3328,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2498,'将表移动到recycle池','alter table abc storage(buffer_pool recycle);',3328,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2499,'创建表在keep buffer pool','CREATE table abc(a int) storage(buffer_pool keep);',3328,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2500,'DB_BLOCK_SIZE',NULL,3329,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2501,'BUFFER_POOL_RECYCLE','设置回收池大小(不能使用)',3329,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2502,'_DB_AGING_TOUCH_TIME','再次递增touch计数所需要的秒数',3329,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2503,'DB_BLOCK_LRU_LATCHES','LRU链表作为一个内存对象，对它的访问是需要进行锁(latch)控制的，以防止多个用户进程同时使用一个空闲缓存块。DB_BLOCK_LRU_LATCHES设置了LUR latch的数量范围。Oracle通过一系列的内部检测来决定是否使用这个参数值。如果这个参数没有设置，Oracle会自动为它计算出一个值。一般来说，oracle计算出来的值是比较合理，无需再去修改。\n9i以后这个参数是隐含参数。对于隐含参数，我建议在没有得到Oracle支持的情况下不要做修改，否则，如果修改了，Oracle是可以拒绝为你做支持的。',3329,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2504,'_DB_AGING_HOT_CRITERIA','从8I开始,LRU上的BUFFER不在因为访问量高而移动，只要大于这个参数就是热块。\n把buffer移到LRU链的MRU端的阈值。',3329,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2505,'_DB_PERCENT_HOT_DEFAULT','PERCENT OF DEFAULT BUFFER POOL CONSIDERED HOT.\n新的BLOCK被读入DATA BUFFER中的BUFFER时，是先读入这个参数的LRU百分比的位置，默认为50%,也就是LRU的一半。\n热点区域里的缓冲区比例\n这个参数设置的低可以增加原缓冲区的悬置时间，如果设置的高会使其快速被清除。',3329,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2506,'_DB_BLOCK_WRITE_BATCH','1.这个参数在ORACLE 8.0.6还存在，在之后的版本没有了。他的作用是脏BUFFER达到多少时，通知DBWR来写他们到DATA FILE。这个值就是这个参数的值的一半。\n2.同时DBWR每次可写的块数也由这个参数来指定。\n3.如果DBWR在3秒内未有任何动作，那么DBWR对LRU列表查找指定数目的buffer，并将找到的脏buffer写到data file中，这个值就是这个参数的两倍。',3329,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2507,'_DB_BLOCK_MAX_SCAN_CNT','这个参数ORACLE 8.1.7还存在，之后的版本没有了.这个参数的表示，数据库进程需要data buffer中的buffer时，找了多少个buffer，还是没有找到可用的buffer，就通知dbwr来写脏buffer，这个值就是这个参数。',3329,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2508,'_DB_BLOCK_HASH_BUCKETS','DATA BUFFER中BUCKETS的数量',3329,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2509,'db_keep_cache_size','设置保留池大小',3329,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2510,'db_recycle_cache_size','设置回收池大小',3329,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2511,'db_cache_advice','开启buffer cache顾问',3329,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2512,'DB_CACHE_SIZE',NULL,3329,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2513,'DB_BLOCK_CHECKING','blokc检查',3329,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2514,'_DB_AGING_STAY_COUNT','当移到MRU端时把touch计数充值为该值',3329,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2515,'BUFFER_POOL_KEEP','设置保留池大小(不能使用)',3329,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2516,'_DB_AGING_COOL_COUNT','当移到LRU端时把touch计数充值为该值',3329,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2517,'_db_block_max_cr_dba','--设置databuffer中cr块的最大数量',3329,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2518,'DB_BLOCK_CHECKSUM','--',3329,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2519,'db_ultra_safe','--',3329,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2520,'buffer cache命中率','select metric_name,value from v$sysmetric where metric_name =\'Buffer Cache Hit Ratio\';',3330,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2521,'buffer cache命中率','select sum(decode(name,\'physical reads\',value,0)) Physical_Reads,\n	sum(decode(name,\'db block gets\',value,0)) DB_Block_Gets,\n	sum(decode(name,\'consistent gets\',value,0)) Consistent_Gets,\n	(1-sum(decode(name,\'physical reads\',value,0)) /\n	(sum(decode(name,\'db block gets\',value,0))+\n	sum(decode(name,\'consistent gets\',value,0))))*100 hit_ratio\nfrom v$sysstat;\n#命中率应该大于95%',3330,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2522,'查看buffer cache中的各buffer类型的情况','select name,block_size,resize_state,current_size,buffers from v$buffer_pool;',3330,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2523,'查看keep池中的磁盘和内存读取情况','select physical_reads ,db_block_gets+consistent_gets \nfrom v$buffer_pool_statistics \nwhere name=\'KEEP\';',3330,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2524,'查看keep pool中的表','select * from dba_tables where Buffer_POOL=\'KEEP\' ;',3330,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2525,'查询free buffer inispected次数','select name,value from v$sysstat where name=\'free buffer inspected\';\n--free buffer inispected是通过搜索多少个data buffer中的buffer,还是没有找到需要的buffer',3330,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2526,'查看buffer cache的竞争情况','select event,total_waits \nfrom v$system_event \nwhere event in(\'free buffer waits\',\'buffer busy waits\');\n--buffer busy waits说明对某个块,有竞争,同时需要修改,等待的次数,争抢哪些block可以通过v$event_name视图来查看,结合v$session的P1,P2,P3列。\n--free buffer waits说明找不到free块,需要淘汰一些块才能获得新的free block的次数。\nselect name,parameter1,parameter2,parameter3 from v$event_name where name =\'buffer busy waits\';\n--得到的值,可以在v$session_wait进一步获得（file,block,id）信息。',3330,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2527,'v$buffer_pool_statistics','V$BUFFER_POOL_STATISTICS displays statistics about all buffer pools available for the instance.',3331,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2528,'v$db_cache_advice','data buffer cache顾问/使用顾问必须开启参数db_cache_advice\nV$DB_CACHE_ADVICE contains rows that predict the number of physical reads for the cache size corresponding to each row. The rows also compute a \"physical read factor,\" which is the ratio of the number of estimated reads to the number of reads actually performed by the real buffer cache during the measurement interval.',3331,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2529,'v$buffer_pool','V$BUFFER_POOL displays information about all buffer pools available for the instance.',3331,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2530,'v$event_name',NULL,3332,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2531,'v$segment_statistics','V$SEGMENT_STATISTICS displays information about segment-level statistics.',3332,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2532,'关闭表的inmemory','--ALTER TABLE oe.product_information NO INMEMORY;',3333,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2533,'压缩','--ALTER TABLE oe.product_information INMEMORY [ MEMCOMPRESS FOR CAPACITY LOW ];\n--NO MEMCOMPRESS\n--MEMCOMPRESS FOR DML\n--MEMCOMPRESS FOR QUERY LOW\n--MEMCOMPRESS FOR QUERY HIGH\n--MEMCOMPRESS FOR CAPACITY LOW\n--MEMCOMPRESS FOR CAPACITY HIGH\n',3333,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2534,'创建表并添加到inmemory','--CREATE TABLE test_inmem (id NUMBER(5) PRIMARY KEY) INMEMORY;\n',3333,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2535,'开启表的inmemory','--ALTER TABLE oe.product_information INMEMORY;',3333,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2536,'INMEMORY_QUERY','--是否开启inmemory查询',3334,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2537,'INMEMORY_SIZE','--',3334,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2538,'INMEMORY_FORCE','--是否开启表和物化视图的inmemory选项。',3334,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2539,'INMEMORY_CLAUSE_DEFAULT','--',3334,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2540,'查询哪些object在im column中','--SELECT OWNER, SEGMENT_NAME, INMEMORY_PRIORITY, INMEMORY_COMPRESSION FROM V$IM_SEGMENTS;\n',3335,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2541,'V$IM_SEGMENTS','--',3336,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2542,'查看inmemory使用情况','--select INMEMORY_SIZE,BYTES  from V_$IM_SEGMENTS where owner=\'GOKU\';\n',3336,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2543,'V$INSTANCE_RECOVERY','V$INSTANCE_RECOVERY monitors the mechanisms available to users to limit recovery I/O. Those mechanisms are:\n\nSet the LOG_CHECKPOINT_TIMEOUT initialization parameter\nSet the LOG_CHECKPOINT_INTERVAL initialization parameter\nSet the FAST_START_MTTR_TARGET initialization parameter\nSet the size of the smallest redo log',3337,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2544,'_LARGE_POOL_MIN_ALLOC',NULL,3338,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2545,'LARGE_POOL_SIZE',NULL,3338,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2546,'MEMORY_TARGET','--',3339,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2547,'MEMORY_MAX_TARGET','--',3339,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2548,'V$MEMORY_DYNAMIC_COMPONENTS','V$MEMORY_DYNAMIC_COMPONENTS displays information about the dynamic SGA components. This view summarizes information based on all completed SGA resize operations since instance startup. All sizes are expressed in bytes.',3340,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2549,'V$MEMORY_TARGET_ADVICE','MEMORY顾问',3340,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2550,'HASH_AREA_SIZE',NULL,3341,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2551,'PGA_AGGREGATE_TARGET','--',3341,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2552,'SPRT_AREA_SIZE',NULL,3342,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2553,'SGA_MAX_SIZE','*Dynamic:N',3342,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2554,'SGA_TARGET','*Dynamic:Y\n#大于0就是开启自动内存管理，为0就是关闭.',3342,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2555,'MEMORY_TARGET','大于0就是开启自动内存管理，为0就是关闭.\n*Dynamic:N',3342,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2556,'MEMORY_MAX_TARGET','*Dynamic:N',3342,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2557,'PGA_AGGREGATE_TARGET',NULL,3342,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2558,'WORKAREA_SIZE_POLICY',NULL,3342,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2559,'查看pga顾问得到最小的且比较好的pga设置值','SELECT min(pga_target_for_estimate) FROM V$PGA_TARGET_ADVICE where estd_pga_cache_hit_percentage>95;\n',3342,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2560,'查看pga最大分配和当前分配','--select name,value/1024/1024 from v$pgastat where name in(\'maximum PGA allocated\',\'total PGA allocated\');',3342,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2561,'v$pga_target_advice','pga顾问;',3343,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2562,'v$pga_target_advice_histogram;','pga顾问;',3343,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2563,'LOG_BUFFER',NULL,3344,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2564,'查询当前无法找到redo buffer存放数据的重试次数','--select statistic#,name,class,value from v$sysstat where name like \'redo buffer%\'; \n#这个值应该为0',3345,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2565,'查询当前redo log buffer的大小','--select * from v$sgastat where name=\'log_buffer\';',3345,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2566,'instance granule分配准则','SGA_MAX_SIZE小于128M,_ksm_granule_size就等于4M;\nSGA_MAX_SIZE大于等于128M,_ksm_granule_size就等于16M;\n_ksm_granule_size的大小，意味着SGA中各个组件的大小，都已_ksm_granule_size为倍数增加',3346,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2567,'_KSM_GRANULE_SIZE','设置instance granule大小',3347,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2568,'SGA_MAX_SIZE',NULL,3347,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2569,'SGA_TARGET','--',3347,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2570,'查看sga组件的大小和变化','SELECT * from v$sga_dynamic_components;',3348,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2571,'v$memory_resize_ops','--',3348,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2572,'V$SYSMETRIC','V$SYSMETRIC displays the system metric values captured for the most current time interval for both the long duration (60-second) and short duration (15-second) system metrics.\n显示系统度量值(有各个pool的命中率)，这个值捕获当前时间前推60秒和前推15秒的统计。',3349,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2573,'V$SGA_DYNAMIC_FREE_MEMORY','V$SGA_DYNAMIC_FREE_MEMORY displays information about the amount of SGA memory available for future dynamic SGA resize operations.\nsga未来可用，但现在还未分配给sga的内存数量。',3349,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2574,'V$SGA_DYNAMIC_COMPONENTS','V$SGA_DYNAMIC_COMPONENTS displays information about the dynamic SGA components. This view summarizes information based on all completed SGA resize operations since instance startup. All sizes are expressed in bytes.',3349,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2575,'v$sga',NULL,3349,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2576,'v$sgastat','V$SGA displays summary information about the system global area (SGA).',3349,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2577,'使用PL/SQL来优化sql text使之统一格式化','PL/SQL执行sql语句会统一把SQL语句改为大写，多余的空格合并为一个空格。\n出自--Oracle Database 10g 性能调整与优化(122页 4.5.1)',3350,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2578,'library cache概念','Library cache 查找sql的计算基于构建词语句的字符的ASCII值，所以SELECT（大写）和select（小写），是不同的语句，需要再次解析。',3350,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2579,'两个不同的sql语句，但是object可以共享解析','select * from orders;和select sum(order_amount) from orders虽然是不同的语句，但是DD cache中，orders这个对象已经缓存在DD中了。',3350,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2580,'存储的PLSQL比匿名PLSQL执行要快','因为存储的plsql是存储数据字典中的，而匿名不是所以，对于再次执行而言，不能被cache 和重用。',3350,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2581,'DD与library cache调优优先级','SGA中分配内存算是首先分配字典缓存，所以，如果library cache正确无误，DD cache也必然正确。',3350,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2582,'dbms_shared_pool.purge','--dbms_shared_pool.purge(\'1EFB91B8, 3642190903\',\'C\');\n--ADDRESS和HASH_VALUE,C是cursor的意思\n--把某条sql语句从shared pool中flush掉',3351,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2583,'清除shared pool中的对象','ALTER SYSTEM FLUSH SHARED_POOL;',3352,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2584,'CURSOR_SHARING',NULL,3353,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2585,'SHARED_POOL_SIZE','#设置asm sga中 shard pool的大小。',3353,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2586,'SHARED_POOL_RESERVED_SIZE','设置保留池的大小',3353,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2587,'cursor_space_for_time','弃用',3353,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2588,'data dictionary--查看数据字典中命中率详单','select parameter,gets,getmisses,modifications,flushes,\n	(getmisses/decode(gets,0,1,gets)) getmiss_ratio,\n	(case when(getmisses/decode(gets,0,1,gets))>0.1 then \'*\'else\' \'end) \" \" \nfrom v$rowcache \nwhere gets+getmisses<>0;\n--当最后一列为*时，说明此行的数据字典区域命中率低于90%',3354,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2589,'library cache--查看命中率','select sum(pins) \"Hits\",sum(reloads) \"Misses\",(sum(pins)/(sum(reloads)+sum(pins))*100) \"HIT RATIO%\" from v$librarycache;',3354,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2590,'library cache--查看各个namespace命中率详单','select namespace,\n    GETHITRATIO*100 GETHITRATIO,--get命中率\n    PINHITRATIO*100 PINHITRATIO,--pin命中率\n    reloads,--reload次数\n    reloads/decode(pins,0,1,pins)*100 reloadratio --reload和pin的比率\nfrom v$librarycache;\n--get命中率和pin名中应该接近1',3354,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2591,'data dictionary--查看data dictionary命中率','select ((1-(sum(getmisses)/(sum(gets)+sum(getmisses))))*100) \"Hit Rate\" from v$rowcache where gets+getmisses<>0;\n--命中率应该在95%以上.',3354,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2592,'library cache--查看librarycache的整体reload率','select  sum(pins) \"Hits\",sum(reloads) \"Misses\",((sum(reloads)/sum(pins)) *100) \"Reload %\" from v$librarycache;\n',3354,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2593,'shared pool--查看的当前大小/空余空间/百分比','select S.CURRENT_SIZE/1024/1024 \"Current Shared Pool MB\",g.bytes/1024/1024 as \"Free MB\",g.bytes/s.current_size  \"Percent Free\" from V$SGA_DYNAMIC_COMPONENTS s,v$sgastat g where s.component=\'shared pool\' and g.name=\'free memory\' and g.pool=\'shared pool\';',3354,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2594,'shared pool--查看shared pool命中率','select ((1-(sum(getmisses) / (sum(gets) + sum(getmisses))))*100) hit_rate \nfrom v$rowcache \nwhere gets+getmisses<>0;\n',3354,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2595,'shared pool--查看各个组件的内存大小','SELECT POOL,NAME,BYTES FROM V$SGASTAT WHERE POOL=\'shared pool\';\n',3354,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2596,'shared pool--查看Hard parser次数和total parser次数:','select * from v$sysstat where name like  \'parse count%\';',3354,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2597,'hard parser占total parser的百分比','select (select value from  v$sysstat where name=\'parse count (hard)\')/(select value from  v$sysstat where name=\'parse count (total)\')*100 as \"parse%\" from dual;',3354,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2598,'查看哪些用户正在占用shared pool的哪个对象','SELECT A.SID,A.USERNAME,B.OWNER,B.OBJECT,B.TYPE \nFROM V$SESSION A,V$ACCESS B\nWHERE A.SID=B.SID;',3354,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2599,'shared pool--查看library cache中每一个chunk的类型','SELECT sum(ksmchsiz) bytes,ksmchcls status FROM X$KSMSP group by ksmchcls;\n--ksmchcls字段解释:\n    free:可用的连续空闲内存值\n    freeabl:当前使用的可释放但不能清空的共享内存\n    perm:这是永久分配和不可释放的内存:但是在测试时，它其实表现为没有被移到空闲区域的可用内存。\n    reor:已经分配的内存，当内存中的共享池较少时，可以清空该内存\n    R-free:就是shared_pool_reserved_size(默认是SP的5%)\n    R-freea:可能预留的内存，它可以被释放但不能清空\n    r-recr:预留池中可以重新创建的内存块\n    r-perm:预留池中的永久内存块。',3354,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2600,'shared pool--查看shared pool命中率(awr)','select *  from v$sysmetric where metric_name=\'Library Cache Hit Ratio\';',3354,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2601,'x$ksmsp','[k]ernal [S]torage [M]emory Management [S]GA Hea[p], 其中每一行都代表着shared pool中的一个chunk.',3355,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2602,'v$rowcache','V$ROWCACHE displays statistics for data dictionary activity. Each row contains statistics for one data dictionary cache.\nV$ROWCACHE显示数据字典活动的统计信息。每个row包含一个数据字典cache的统计信息。',3355,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2603,'v$db_object_cache','V$DB_OBJECT_CACHE displays database objects that are cached in the library cache. Objects include tables, indexes, clusters, synonym definitions, PL/SQL procedures and packages, and triggers.\n--可以查看尚未固定且需要的空间较大，可能会引起问题的对象。',3355,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2604,'v$librarycache',NULL,3355,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2605,'V$SHARED_POOL_ADVICE','shared pool顾问',3355,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2606,'V$ACCESS','V$ACCESS displays information about locks that are currently imposed on library cache objects. The locks are imposed to ensure that they are not aged out of the library cache while they are required for SQL execution.',3355,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2607,'查看当前rac中的service','col network_name for a10\nselect name,network_name,creation_date,goal,dtp,aq_ha_notification,clb_goal from v$services;\n',3356,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2608,'查看session是SHARED 还是DEDICATED，专有还是共享','SQL> SELECT SERVER FROM   V$SESSION WHERE  SID = (SELECT DISTINCT SID FROM V$MYSTAT);\n',3357,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2609,'sysdba和sysoper权限区别',NULL,3358,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2610,'撤销权限','SQL> REVOKE privilege_name FROM username;',3359,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2611,'赋予权限','SQL> GRANT privilege_name TO username;',3359,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2612,'user相关操作','\"增加、删除等等\"',3360,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2613,'O7_DICTIONARY_ACCESSIBILITY','--参数-布尔-是否可以授权sys的特权，建议不开启',3361,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2614,'delete any table','删除任何表',3362,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2615,'all privilege','\"所有相关权限及解释\"',3362,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2616,'RECOVERY_CATALOG_OWNER ','连接recovery catalog权限',3362,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2617,'read, write on directory DATA_PUMP_DIR','--赋予读写权限',3362,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2618,'UNLIMITED TABLESPACE','--',3362,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2619,'on commit refresh','--',3362,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2620,'RESTRICTED SESSION','--登录RESTRICT模式的权限',3362,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2621,'PDB_DBA','--SET CONTAINER\n',3363,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2622,'PDB_DBA','--CREATE PLUGGABLE DATABASE',3363,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2623,'CONNECT','--CREATE SESSION',3363,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2624,'PDB_DBA','--CREATE SESSION\n',3363,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2625,'DBA_SYS_PRIVS','查看DB中所有的权限。',3364,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2626,'dba_tab_privs','对象权限',3364,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2627,'dba_role_privs','--',3364,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2628,'ALL_TAB_PRIVS_MADE','--',3364,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2629,'session_per_user','--限制每个用户可以连接上来的数量。',3365,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2630,'修改profile','--alter profile <profile_name> limit <profile_limit_parameter>;',3366,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2631,'修改用户profile','--alter user <username> profile <profilename>;',3366,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2632,'查看role拥有的权限','select privilege from role_sys_privs where role=\'aq_administrator_role\';',3367,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2633,'select','\"用户和权限相关查询\"',3367,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2634,'OS_AUTHENT_PREFIX','--默认字符串[OPS$],也可以自定义，用于OS系统用户认证',3368,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2635,'查看用户具有的对象权限','--select * from dba_tab_privs where grantee=\'HR\';',3369,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2636,'查看角色具有的系统权限','--select * from dba_sys_privs where grantee=\'DBA\';',3369,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2637,'查看user拥有的objects','--select  GRANTEE ,table_name  from dba_tab_privs where GRANTEE=\'GOKU\';\n--包括可以select的表，视图，字典，以及可以执行的dbms包',3369,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2638,'查看user拥有的role','--select * from dba_role_privs where grantee = \'GOKU\';',3369,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2639,'查看当前session的权限','--select * from session_privs',3369,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2640,'查看哪些没有被锁的user','--select username,ACCOUNT_STATUS from dba_users where  ACCOUNT_STATUS = \'OPEN\';',3369,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2641,'DBA_TS_QUOTAS;','--查看用户对表空间的限额',3370,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2642,'DBA_USERS_WITH_DEFPWD','--查看DB中哪些用户还是用缺省密码',3370,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2643,'并行加载对extent截断的影响','\"uniform和autoallocate在并行加载中的extent截断区别\"',3371,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2644,'plsql并行化执行','\"通过dbms_parallel_exectue包来处理plsq并行\"',3372,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2645,'parallel select','\"并行查询相关\"',3373,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2646,'Segment Advisor','基本概念',3374,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2647,'启动/关闭 所有自动任务','EXEC DBMS_AUTO_TASK_ADMIN.DISABLE/ENABLE;',3375,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2648,'undo advisor','--',3375,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2649,'DBA_ADVISOR_TEMPLATES','--查看DB中所有关于模板的信息',3375,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2650,'DBA_ADVISOR_USAGE','--db中每个顾问的使用信息',3376,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2651,'DBA_AUTOTASK_TASK','查看数据库中自动任务的名称和状态',3377,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2652,'DBA_AUTOTASK_SCHEDULE','查看所有的预定义的维护时间窗',3377,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2653,'DBA_AUTOTASK_OPERATION',NULL,3377,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2654,'查看free list是否够用','select ((a.count / (b.value + c.value)) * 100) pct\n  from v$waitstat a, v$sysstat b, v$sysstat c\n where a.class = \'free list\'\n   and b.statistic# =\n       (select statistic# from v$statname where name = \'db block gets\')\n   and c.statistic# =\n       (select statistic# from v$statname where name = \'consistent gets\');;\n--应该在1以下',3377,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2655,'DBA_RECYCLEBIN','回收站信息',3378,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2656,'v$flash_recovery_area_usage','查看闪回区的空间使用情况',3378,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2657,'v$recovery_file_dest','查看闪回区的空间使用情况，可回收空间数量/已用空间/总空间。',3378,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2658,'USER_FLASHBACK_ARCHIVE_TABLES','查询被作用的闪回数据归档的表.',3378,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2659,'DBA_FLASHBACK_ARCHIVE_TS','查看闪回数据归档所使用的表空间。',3378,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2660,'V$RESTORE_POINT','查看DB的还原点，包括是不是永久被保留的还原点。',3378,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2661,'DBA_FLASHBACK_ARCHIVE','查询有哪些闪回数据归档.查看默认的闪回数据归档。',3378,'2016-04-06 23:27:45','2016-04-06 23:27:45',NULL),(2662,'FLASHBACK DROP','闪回被删除的表',3379,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2663,'flashback SCN in an Abandoned Incarnation Branch','flashback到DB之前某个化生中的某个位置',3379,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2664,'flashback open resetlogs','flashback到当前database化生开始的位置',3379,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2665,'FLASHBACK TABLE','Flashback table需要的权限/FLASHBACK TABLE先决条件/FLASHBACK TABLE操作/在FLASHBACK TABLE保持triggers enabled',3379,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2666,'FLASHBACK DATABASE',NULL,3379,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2667,'Flashback','\"使用说明\"',3379,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2668,'FLASHBACK ON object_name','闪回某个对象权限',3380,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2669,'SELECT ANY DICTIONARY','查询任何字典,用于恢复点的使用',3380,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2670,'FLASHBACK ANY TABLE','可以闪回任何表',3380,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2671,'FLASHBACK ARCHIVE ADMINISTER','可以管理闪回数据库归档,开启表的闪回数据归档.',3380,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2672,'recyclebin','--设置是否开启回收站。',3381,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2673,'db_recovery_file_dest','--',3381,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2674,'db_recovery_file_dest_size','--',3381,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2675,'查看当前DB scn','SELECT CURRENT_SCN FROM V$DATABASE;',3382,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2676,'查看回收站',' SHOW RECYCLEBIN;',3382,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2677,'查看回收站','SELECT object_name AS recycle_name, original_name, type \nFROM   recyclebin;\n',3382,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2678,'查看DB的化身号(受resetlogs影响)','SELECT PRIOR_INCARNATION# FROM V$DATABASE_INCARNATION WHERE  STATUS = \'CURRENT\';\n',3382,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2679,'查看恢复点','SELECT NAME, SCN, TIME FROM V$RESTORE_POINT;',3382,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2680,'查看表是否有依赖','SELECT other.owner, other.table_name\n    FROM sys.all_constraints this, sys.all_constraints other\n    WHERE  this.owner = schema_name\n    AND    this.table_name = table_name\n    AND    this.r_owner = other.owner\n    AND    this.r_constraint_name = other.constraint_name\n    AND    this.constraint_type=\'R\';\n#schema_name/table_name需要替换',3382,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2681,'V$INSTANCE_recovery','--',3383,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2682,'手动备份','\"操作说明\"',3384,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2683,'STATUS:INACTIVE | LOSE:MEMBER | INSTANCE:ONLINE','--',3385,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2684,'STATUS:CURRENT  | LOSE:MEMBER | INSTANCE:ONLINE','--',3385,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2685,'STATUS:INACTIVE | LOSE:ALL    | INSTANCE:ONLINE','--',3385,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2686,'STATUS:CURRENT  | LOSE:ALL    | INSTANCE:ONLINE','--',3385,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2687,'对restore database preview显示结果的思考',NULL,3386,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2688,'配置备份加密',NULL,3386,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2689,'备份保留策略/设置和维护','1.基于窗口\n2.基于冗余\n3.无保留策略',3386,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2690,'备份原则 01','--In addition to regularly scheduled backups, you should always back up your database immediately after implementing changes to the database structure.',3387,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2691,'复制数据库的三种类型','1.使用rman备份复制并访问目标数据库\n2.使用rman备份复制并无需访问目标数据库\n3.不适用备份复制，复制活动的数据库\n',3388,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2692,'迁移DB，在不同平台之间','http://www.itpub.net/forum.php?mod=viewthread&tid=1775009\nhttp://tech.it168.com/db/2007-12-19/200712191131170_2.shtml\n<<rman备份与恢复>>359页14.5',3389,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2693,'删除DB','SQL>alter system enable restricted session;\nRMAN> DROP DATABASE INCLUDING backups;',3389,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2694,'登录rman','connect\n指定log/指定脚本',3389,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2695,'manage rman','*VALIDATE:验证备份文件的是否可以完整回复，是否有坏块。检测中的错误，会被记录在V$BACKUP_CORRUPTION/V$COPY_CORRUPTION\n*LIST\n*REPORT / \n*CROSSCHECK:验证备份文件是否存在于备份时的位置，也就是控制文件中记录的位置。\n*DELETE',3389,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2696,'修复backup set','1.LIST FAILURE;--查看损坏的backup set\n2.ADVISE FAILURE;--执行修复顾问\n3.手动执行修复/或者执行 command:REPAIR FAILURE;',3389,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2697,'检查rman语法错误','见文档\nLinux>rman CHECKSYNTAX\n然后输入rman命令这里面输入的命令，只检查语法,不执行.',3389,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2698,'模板','--show all;\nCONFIGURE DEVICE TYPE DISK PARALLELISM 6 BACKUP TYPE TO COMPRESSED BACKUPSET;\nCROSSCHECK BACKUP;\nDELETE EXPIRED BACKUP;\nBACKUP INCREMENTAL LEVEL 0 DATABASE FORMAT \'/opt/oracle/rman/backup/s217/d0-%n-%I-%T-%p-%U.bak\' TAG=\'DBF0\';\nDELETE OBSOLETE;\nBACKUP ARCHIVELOG ALL not backed up 1 times FORMAT \'/opt/oracle/rman/backup/s217/a9-%n-%I-%T-%h-%p-%U.bak\' delete input TAG=\'ARCH\';\nDELETE OBSOLETE;\nbackup spfile format \'/opt/oracle/rman/backup/s217/s9-%n-%I-%T-%p-%U.bak\' tag=\'spf\';\nbackup current controlfile format \'/opt/oracle/rman/backup/s217/c9-%n-%I-%T-%p_%U.bak\' tag=\'ctl\';\nbackup current controlfile format \'/opt/oracle/rman/backup/s217/c9-%n-%I-%T-%p_%U.bak\' tag=\'ctl\';\nSQL \"ALTER DATABASE BACKUP CONTROLFILE TO TRACE AS \'\'/opt/oracle/rman/backup/s217/c9-bak_#DATABASE_ALIAS#_ctl_trc_dup_1.trc\'\' REUSE\";\nSQL \"ALTER DATABASE BACKUP CONTROLFILE TO TRACE AS \'\'/opt/oracle/rman/backup/s217/c9-bak_#DATABASE_ALIAS#_ctl_trc_dup_2.trc\'\' REUSE\";\nCONFIGURE DEVICE TYPE DISK CLEAR;\nlist backup summary;',3389,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2699,'增量备份','差异性/累积性增量备份/跟踪文件的配置',3390,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2700,'backup','操作说明',3390,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2701,'block change tracking','--',3390,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2702,'backup | crontab file(trace)','--alter database backup controlfile to trace as \'xxx\' [reuse] [ RESETLOGS | NORESETLOGS ];\n--RMAN> sql \"alter database backup controlfile to trace as\'\'/opt/oracle/rman/backup/bak_ctl_trc\'\' reuse\";',3390,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2703,'管道备份','--rman pipe p1 target /\n	\nDECLARE\n V_INPUT VARCHAR2(32767) := \'SHOW ALL;\';\n V_OUT NUMBER;\n BEGIN\n DBMS_PIPE.PACK_MESSAGE(V_INPUT);\n V_OUT := DBMS_PIPE.SEND_MESSAGE(\'ORA$RMAN_P1_IN\');\n DBMS_OUTPUT.PUT_LINE(V_OUT);\n COMMIT;\n END;\n /\n \n \n DECLARE\n V_OUTPUT VARCHAR2(32767);\n V_OUT NUMBER := 0;\n BEGIN\n WHILE (V_OUT = 0) LOOP\n V_OUT := DBMS_PIPE.RECEIVE_MESSAGE(\'ORA$RMAN_P1_OUT\', 5);--注意大小写\n IF V_OUT = 0 THEN\n DBMS_PIPE.UNPACK_MESSAGE(V_OUTPUT);\n DBMS_OUTPUT.PUT_LINE(V_OUTPUT);\n END IF;\n END LOOP;\n COMMIT;\n END;\n/\n\n\n\nCREATE OR REPLACE PROCEDURE add_dept IS\nBEGIN\n    DBMS_OUTPUT.PUT_LINE(\' Inserted \');\nEND;\n/',3391,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2704,'rman configure','rman配置信息',3392,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2705,'rman 时间显示','--export NLS_DATE_FORMAT=\'yyyymmdd hh24:mi:ss\';',3392,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2706,'远程数据库复制',NULL,3393,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2707,'删除N天之前的archivelog','--delete archivelog all completed before \'sysdate - 1\';\n--delete [noprompt] archivelog all completed before \'sysdate\';--删除所有的归档日志\n--delete noprompt archivelog all;--删除所有的归档日志',3394,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2708,'删除log sequence为16及16之前的所有归档日志','--delete archivelog until sequence 16;   ',3394,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2709,'手动删除archivelog','--1、rm -f archivelog \n--2、进入RMAN (connect target sys/***@ORCL)\n--3、crosscheck archivelog all; \n--4、delete expired archivelog all;',3394,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2710,'删除系统时间1天以内到现在的归档日志(注意这个命令)\n','--delete archivelog from time \'sysdate-1\';  ',3394,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2711,'列出备份集','RMAN> list backupset 3\nRMAN> list backupset of datafile 1',3395,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2712,'列出适合恢复的备份','RMAN> list recoverable backup of database',3395,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2713,'列出archive log,不是备份','RMAN> list archivelog all',3395,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2714,'列出备份\n列出archive log备份\n列出spfile和controlfile备份\nby file:根据文件类型列出备份\nsummary:概述备份信息','RMAN> list backup \n      [\n       [of {archivelog {all | from sequence 9} | controlfile | database | tablespace user}] [summary]\n           |\n       [by file]\n           |\n       [tag\'xxx\']\n      ]',3395,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2715,'列出对应物','RMAN> list incarnation of database',3395,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2716,'list查看control file和恢复目录中的备份信息。','list',3395,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2717,'列出相应的映像副本','RMAN> list copy [of {database | archivelog {all | from sequence 9} | controlfile | DATAFILE 1,2,..}]',3395,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2718,'查看到期的备份集\nsummary解释:doc-2185','RMAN> list expired {backup | copy}\n      [of {archivelog all | datafile 3}]\n      [summary]',3395,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2719,'查看最近30天没有备份的datafile','report need backup days=30;',3396,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2720,'查看需要应用多少增量备份才能恢复的datafile\n    这里为大于2个增量备份才能恢复的datafile','report need backup incremental=2;',3396,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2721,'查看不满足指定冗余数量的datafile','report need backup redundancy 1;',3396,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2722,'report schema','查看数据文件/数据文件号/数据文件大小/数据文件是否含有回滚段/所属的tablespace/',3396,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2723,'查看不满足恢复时间的data file','report need backup recovery window of 2 day;',3396,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2724,'查看拥有不可恢复对象的datafile','report unrecoverable',3396,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2725,'查看过时的备份\n    针对保留策略','RMAN> report obsolete',3396,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2726,'基于controlfile恢复','-- recover database using backup controlfile until cancel;',3396,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2727,'不完全恢复','基于恢复点/时间点/SCN/ARCHIVELOG的不完全恢复',3397,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2728,'只读表空间','默认情况下，即使丢失了制度的数据文件，RMAN也不会在执行完全数据库还原操作时还原只读的数据文件。',3397,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2729,'archive log',NULL,3397,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2730,'数据文件copy',NULL,3397,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2731,'损坏的数据块',NULL,3397,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2732,'不完全恢复---12c_doc',NULL,3397,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2733,'不完全恢复---恢复到之前的化生','恢复到之前的化身',3397,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2734,'recovery','操作说明',3397,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2735,'恢复datafile到不同的目录','--run{\n	SET NEWNAME FOR DATAFILE 1 to \'/u01/app/oradata/goku/system01.dbf\';\n	restore tablespace system;\n	switch datafile 1;\n	recover tablespace system;\n}\n',3397,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2736,'检测坏块(逻辑)','--RMAN> run\n        {\n         set  maxcorrupt for datafile 1,2,3,4 to 5;\n         restore database check logical validate;\n        }',3397,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2737,'检测坏块(物理)','--RMAN> validate backupset n;',3397,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2738,'不完全恢复','--recover database [using backup controlfile] allow 1 corruption;',3397,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2739,'验证备份可恢复性，不实际备份(只会使用最新的备份)','--RMAN> restore database [check logical ] validate;\n#可选增加逻辑检查',3397,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2740,'显示恢复需要的备份(不实际恢复)','--RMAN> restore database preview;',3397,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2741,'异机恢复','--1.restore spfile;\n2.restore conrtolfile;\n3.restore database;\n4.recover database;\n5.recover database using backup controlfile until cancel;\n6.alter database open resetlogs;\n',3397,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2742,'recover database命令区别','--1. recover database using backup controlfile\n2. recover database until cancel\n3. recover database using backup controlfile until cancel;\n4. recover database until cancel using backup controlfile;\n区别：\n1. 如果丢失丢失当前控制文件，用冷备份中的控制文件恢复的时候。用来告诉Oracle，不要以controlfile中的scn作为恢复的终点；\n2. 如果丢失current/active redo的时候。手动指定终点。\n3. 如果 丢失当前controlfile并且current/active redo都丢失，会先去 自动 应用归档日志,可以实现最大的恢复；\n4. 如果 丢失当前controlfile并且current/active redo都丢失，以旧的redo中的scn为恢复终点。因为没有应用归档日志，所有会丢失数据。',3397,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2743,'使用指定位置的备份','--1.startup nomount #startup之前删除$ORACLE_HOME/dbs/下的spfile或pfile(也就是不使用ORACLE_SID所制定的参数文件启动instance)\n--2.restore spfile from \"xxx\"\n--注意事项:1.删除$ORACLE_HOME/dbs/目录下的文件(将要恢复的SID的文件);2.确保ORACLE有对备份文件读的权限',3398,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2744,'分配通道','ALLOCATE CHANNEL c1 DEVICE TYPE DISK;',3399,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2745,'_ALLOW_RESETLOGS_CORRUPTION','强制启动数据库，设置此参数之后，在数据库Open过程中，Oracle会跳过某些一致性检查，从而使数据库可能跳过不一致状态。',3400,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2746,'BACKUP_TAPE_IO_SLAVES','开启异步I/O.默认false，如果设备支持异步I/O那么建议开启。如果开启这个参数，那么可以在allocate channel和configure channel命令的parms参数来定义内存cache的大小。',3400,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2747,'DBWR_IO_SLAVES',NULL,3400,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2748,'CONTROL FILE_RECORD_KEEP_TIME','控制文件内容保留天数，包括有关rman的信息',3400,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2749,'查看channel对应的server sessions','select sid,username,client_info from v$session where client_info is not null;',3401,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2750,'查看RMAN备份时正在使用的sid','select sid,spid,client_info\nfrom v$process p,v$session s\nwhere p.addr=s.paddr\nand client_info like \'%rman%\';\n',3401,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2751,'查看备份进度','SELECT SID,SERIAL#,opname,CONTEXT,SOFAR,TOTALWORK,\n		ROUND(SOFAR/TOTALWORK*100,2) \"%_COMPLETE\"\nFROM V$SESSION_LONGOPS \nWHERE OPNAME LIKE \'RMAN%\'\nAND OPNAME NOT LIKE \'%AGGREGATE%\'\nAND TOTALWORK !=0\nAND SOFAR <>TOTALWORK order by 7 desc;',3401,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2752,'监控RMAN的所有操作或输出','SELECT * FROM (SELECT * FROM V$RMAN_OUTPUT ORDER BY STAMP DESC) WHERE ROWNUM <10;\n#这里只显示了最后10行的操作或输出',3401,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2753,'v$backup_archivelog_details','包含所有可还原归档日志的信息',3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2754,'v$backup_async_io','提供正在进行的和最近完成的RMAN备份的还原的性能信息。',3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2755,'v$backup_controlfile_details','提供可还原控制文件的信息。',3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2756,'v$backup_copy_details','提供可用的控制文件和数据文件副本的相关信息。',3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2757,'v$backup_corruption','提供从控制文件获得的关于数据文件备份损坏的相关信息。',3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2758,'v$backup_datafile','提供所有的rman备份(包括映像副本和备份集)的信息。',3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2759,'v$backup_piece_details','提供所有可用的备份片信息。',3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2760,'v$backup_redolog','提供从控制文件获得的在备份集中的归档日志的信息。',3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2761,'v$backup_set','提供从控制文件获得的备份集的信息',3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2762,'v$backup_set_details','提供从控制文件获得备份集的详细信息。',3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2763,'v$backup_spfile','提供从控制文件获得的在备份集中的spfile信息。',3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2764,'v$backup_sync_io','提供正在进行的和最近完成的RMAN备份和还原的性能信息。',3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2765,'v$recovery_file','包含需要进行截至恢复的文件的状态信息。',3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2766,'v$recover','提供与恢复区有关的信息',3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2767,'v$rman_backup_job_details','提供备份工作的详细信息',3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2768,'v$rman_backup_type','提供rman备份类型的信息。',3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2769,'v$rman_configuration','提供rman的持久性配置设置有关的信息/显示的设置的rman configure',3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2770,'v$rman_status','提供rman完成的和正在进行的工作的信息。',3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2771,'V$ARCHIVED_LOG',NULL,3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2772,'v$block_change_tracking','跟踪block文件相关信息',3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2773,'V$BACKUP_CORRUPTION','坏块的历史视图',3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2774,'V$DATABASE_BLOCK_CORRUPTION','当前的坏块视图',3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2775,'v$backup_piece','提供从控制文件获得的备份片的信息。',3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2776,'v$backup_spfile_details','提供从控制文件获得的在备份集中的spifle的详细信息。',3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2777,'v$rman_output','提供由rman报告的消息',3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2778,'v$backup_files',NULL,3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2779,'V$COPY_CORRUPTION',NULL,3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2780,'v$recover_file','显示当前需要被media recovery的files的status',3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2781,'V$BACKUP_PIECE',NULL,3402,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2782,'开启主键附加日志','alter database add supplemental log data(primary key) columns;',3403,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2783,'手动归档','alter system archive log current;',3403,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2784,'开启附加日志','alter database add supplemental log data;',3403,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2785,'将数据库处于归档模式 （5步）','1.shutdown normal/immediate/transactional\n2.startup mount\n3.alter database archivelog;#alter database noarchivelog;处于非归档状态.\n4.alter database open\n5.全备数据库（还要关闭db）\n',3404,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2786,'LOG_ARCHIVE_DEST_N','可以指定31个归档路径.另外设置归档路径(本地，远程),包括一些归档参数.',3405,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2787,'LOG_ARCHIVE_FORMAT','设置archive log file的命名格式，具体见本文档。',3405,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2788,'LOG_ARCHIVE_MAX_PROCESSES','specifies the maximum number of ARCn processes that can be created.',3405,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2789,'log_archive_min_succeed_dest','指定至少需要完成多少个归档路径(log_archive_dest_n)，才能确认归档成功。',3405,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2790,'LOG_ARCHIVE_DEST_STATE','此参数是对每一个log_archive_dest_n参数的设置，可以设置为可用，和不可用等3个选项。',3405,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2791,'列出archive信息','archive log list;（这个是sqlplus的命令）',3406,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2792,'查看当前db是否为archive mode','select log_mode from v$database;\n',3406,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2793,'查看是否开启附加日志','select log_mode,supplemental_log_data_min from v$database;',3406,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2794,'v$archived_log','v$archived_log displays archived log information from the control file, including archive log names. an archive log record is inserted after the online redo log is successfully archived or cleared (name column is null if the log was cleared). if the log is archived twice, there will be two archived log records with the same thread#, sequence#, and first_change#, but with a different name. an archive log record is also inserted when an archive log is restored from a backup set or a copy and whenever a copy of a log is made with the rman copy command.\n\n从control file显示被归档的archive log file，包括archive log name.',3407,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2795,'v$archive_dest_status','v$archive_dest_status displays runtime and configuration information for the archived redo log destinations. the information in this view does not persist across an instance shutdown.',3407,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2796,'v$archive_processes','v$archive_processes displays the state of the various arch processes for the instance.',3407,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2797,'v$archive_dest','v$archive_dest displays, for the current instance, all of the destinations in the data guard configuration, including each destination\'s current value, mode, and status.',3407,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2798,'v$archive','v$archive displays information about redo log files in need of archiving. each row displays information for one thread. this information is also available in v$log. oracle recommends that you use v$log.',3407,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2799,'v$archive_gap','v$archive_gap displays information about archive gaps on a standby database. this view can be used to find out the current archive gap that is blocking recovery for the current recovery incarnation.',3407,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2800,'DBA_HIST_LOG','回荡日志空间使用的情况。',3407,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2801,'ONLINE/OFFLINE DATA FILE','ALTER DATABASE DATAFILE \'FILE_NAME\' OFFLINE/ONLINE;\n#recovery需要用到。',3408,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2802,'检查DATA FILE的有效性','ALTER SYSTEM CHECK DATAFILES;',3408,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2803,'移动data file位置','见文档。',3408,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2804,'移动data file','#note:这是一个初级步骤不建议使用，建议使用doc-1430\n1.sql> alter tablespace ts_name offline;\n2.linux> cp /disk1/oraders1.dbf /db2/orders1.dbf\n3.sql> alert tablespace orders rename datafile \'/disk1/oraders1.dbf\' to \'/db2/orders1.dbf\';\n4.sql> alter tablespace orders online;\n5.删除old data file',3408,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2805,'drop datafile','--',3408,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2806,'DB_CREATE_FILE_DEST','创建data file/temp file/redo log file/control file的默认位置指定,遵循OMF标准.\n可以指定asm group，或asm group 加上template,或OS路径\n+data/+data(template)',3409,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2807,'DB_FILES','#If the value of DB_FILES is too low, you cannot add data files beyond the DB_FILES limit without first shutting down the database.\n#If the value of DB_FILES is too high, memory is unnecessarily consumed.\n',3409,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2808,'V$DATAFILE','V$DATAFILE displays datafile information from the control file.',3410,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2809,'DBA_EXTENTS','--',3410,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2810,'v$datafile_header;','--',3410,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2811,'DB_RECOVERY_FILE_DEST','该参数定义redo log file/control file/rman backup file/archive log file/fashback log的默认位置。\n定义了这个参数他会推翻DB_CREATE_FILE_DEST的设置',3411,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2812,'块清除--实验','\"块清除导致select语句会产生redo\"',3412,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2813,'块清除','\"概念\"',3412,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2814,'redo log?????3??????','\"?��???????????��????????????????��?��?????????��?��???????-??-?\"',3413,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2815,'清除redo group','--ALTER DATABASE CLEAR LOGFILE GROUP 2;',3413,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2816,'重新创建redo log组','--ALTER DATABASE CLEAR UNARCHIVED LOGFILE GROUP 2;\n--如果没有文件系统上没有相应的redo file文件的话，会重新创建',3413,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2817,'DB_CREATE_ONLINE_LOG_DEST_N','定义control file的位置,并且推翻db_recovery_file_dest和db_create_file_dest对于control file的设置。',3414,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2818,'查看REDO FILE的状态/组/大小','SELECT GROUP#,SEQUENCE#,STATUS,BYTES FROM V$LOG;',3415,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2819,'查看REDO FILE的位置','SELECT GROUP#,MEMBER FROM V$LOGFILE;',3415,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2820,'查看当前session的redo生成量','select b.value\n from v$statname a, v$mystat b\n where a.statistic# = b.statistic#\n and a.name = \'redo size\';',3415,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2821,'rowid以下情况会改变','--1.分区表开启row移动后，row从一个分区移到另一个分区\n2.IOT的主键update\n3.flasback table\n4.alter table shrink',3416,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2822,'查看表所在的TS,EXTENT_ID,EXTENT大小,FILE ID,EXTENT起始BLOCKID','SELECT TABLESPACE_NAME,EXTENT_ID,BYTES,FILE_ID,BLOCK_ID FROM DBA_EXTENTS WHERE SEGMENT_NAME=\'GOKU_DOC\';',3417,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2823,'查询SEGMENT所在TS的位置','SELECT BLOCK_SIZE * BLOCK_ID FROM DBA_TABLESPACES WHERE TABLESPACE_NAME=TS_NAME;\n#BLOCK_ID,为SEGMENT的第一个EXTENT的起始ID.文档1581',3418,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2824,'TS extent设置优化','对于并发insert的优化',3419,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2825,'SMALIFILE TBLESPACE','--可以包含1022个data file或temp data file，其中每个data file可以达到4百万个block(2^22).\n',3419,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2826,'Bigfile tablespace','--只有一个datafile 或 temp data file，datafile的大小接近四十亿个block(2^32)。最大的单个datafile在block 32k情况下是128TB，在block8K情况下是32TB.',3419,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2827,'dbms_space_admin.tablespace_migrate_to_local','--字典管理tablespace迁移到本地管理tablespace\n--建议转换之前先做备份',3420,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2828,'TEMP TS 管理',NULL,3421,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2829,'常用操作','\"create/alter/plsql\"',3421,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2830,'DROP TABLESPACE','--?|?????????o????????��?o?OMF(db_create_file_dest)???��?��?1?drop????����???��?a??��???��?��??��????????????????1?????????��???????o?datafile\'XXXX\'????������??��|??????��???��?��???',3421,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2831,'重命名Tablespace','--SQL> ALTER TABLESPACE <ts_name> RENAME TO <ts_name>;\n--system和sysaux不能重命名',3421,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2832,'CREATE TABLESPACE',NULL,3421,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2833,'设置db的默认表空间','--ALTER DATABASE DEFAULT TABLESPACE root_tbs;\n',3421,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2834,'ROLLBACK_SEGMENTS','ROLLBACK_SEGMENTS allocates one or more rollback segments by name to this instance. If you set this parameter, the instance acquires all of the rollback segments named in this parameter, even if the number of rollback segments exceeds the minimum number required by the instance (calculated as TRANSACTIONS / TRANSACTIONS_PER_ROLLBACK_SEGMENT).\n\nYou cannot change the value of this parameter dynamically, but you can change its value and then restart the instance. Although this parameter usually specifies private rollback segments, it can also specify public rollback segments if they are not already in use.\n\nTo find the name, segment ID number, and status of each rollback segment in the database, query the data dictionary view DBA_ROLLBACK_SEGS.\n\n当undo_management是设置为auto，rollback_segment是被忽略',3422,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2835,'DB_nK_CACHE_SIZE ','--',3422,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2836,'常用查询','\"P/undo/TEMP表空间\"',3423,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2837,'查看表空间空间使用情况','set line 200\ncol tablespace_name for a20\ncol Use_Ratio for a20\ncol free_mb for a10\ncol file_mb for 99999\ncol maxsize for 99999\ncol extend for a15\nselect df.tablespace_name,\n      df.file_id,\n      round(sum(decode(fs.bytes,null,0,fs.bytes))/1024/1024,0)||\' MB\' free_mb ,\n      round((df.BYTES-sum(decode(fs.bytes,null,0,fs.bytes)))/df.BYTES*100,0)||\' %\' Use_Ratio,\n      df.INCREMENT_BY*8/1024||\' MB\' extend,\n      round(df.BYTES/1024/1024,0) file_mb,\n      round(df.maxbytes/1024/1024/1024,0) maxsize\nfrom  dba_data_files df,dba_free_space fs \nwhere df.file_id=fs.file_id(+) group by df.file_id,df.tablespace_name,df.BYTES,df.maxbytes,df.INCREMENT_BY order by 6;',3423,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2838,'查看表空间extent管理方式和分配方式(auto OR 统一分配)','select tablespace_name,extent_management,allocation_type,segment_space_management\n    from dba_tablespaces;',3423,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2839,'查看系统使用的TEMP TS','--select * from database_PROPERTIES where PROPERTY_NAME like \'%TEMP%\';',3423,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2840,'查看表空间中的segment数量','--col file_name for a100\n  set line 180\n   select d.tablespace_name,nvl(s.jishu,0) ,d.file_name\n    from dba_data_files d,(select tablespace_name,count(*) jishu from dba_segments group by tablespace_name) s \n    where  s.tablespace_name(+)=d.tablespace_name order by 2 desc;\n--这里我查看0，因为要删除不用的TS',3423,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2841,'DBA_TEMP_FILES ','--DBA_TEMP_FILES describes all temporary files (tempfiles) in the database.\n查看临时表空间的DATA FILE',3424,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2842,'DBA_TEMP_FREE_SPACE','查看TEMP TS的空间使用情况。',3424,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2843,'ts_pitr_objects_to_be_dropped','查看在表空间中所创建的对象的时间和名字。',3424,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2844,'V$UNDOSTAT','V$UNDOSTAT displays a histogram of statistical data to show how well the system is working. The available statistics include undo space consumption, transaction concurrency, and length of queries executed in the instance. You can use this view to estimate the amount of undo space required for the current workload. Oracle uses this view to tune undo usage in the system. The view returns NULL values if the system is in manual undo management mode.\n\nEach row in the view keeps statistics collected in the instance for a 10-minute interval. The rows are in descending order by the BEGIN_TIME column value. Each row belongs to the time interval marked by (BEGIN_TIME, END_TIME). Each column represents the data collected for the particular statistic in that time interval. The first row of the view contains statistics for the (partial) current time period. The view contains a total of 576 rows, spanning a 4 day cycle.',3424,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2845,'V$TEMPFILE','查看正在使用的TEMP FILE的路径/大小',3424,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2846,'dba_tablespaces','DBA_TABLESPACES describes all tablespaces in the database.\nhttp://docs.oracle.com/cd/E16655_01/server.121/e17633/tablecls.htm#CNCPT89198',3424,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2847,'DBA_FREE_SPACE','--DBA_FREE_SPACE describes the free extents in all tablespaces in the database.\n\nNote that if a datafile (or entire tablespace) is offline in a locally managed tablespace, you will not see any extent information. If an object has extents in an online file of the tablespace, you will see extent information about the offline datafile. However, if the object is entirely in the offline file, a query of this view will not return any records.\n\nRelated View\n\nUSER_FREE_SPACE describes the free extents in the tablespaces accessible to the current user.',3424,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2848,'DBA_DATA_FILES','--DBA_DATA_FILES describes database files.',3424,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2849,'v$temp_extent_pool','--V$TEMP_EXTENT_POOL displays the state of temporary space cached and used for the instance. Note that loading of the temporary space cache is lazy and that instances can be dormant.',3425,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2850,'dba_temp_files','--DBA_TEMP_FILES describes all temporary files (tempfiles) in the database.',3425,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2851,'redo调优一般概念','粗略的概念',3426,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2852,'计算undo TS的所需大小','--select (select value from v$parameter where name=\'undo_retention\')*\n         (select value/1024 from v$parameter where name=\'db_block_size\')*\n         (select max(undoblks / ((end_time - begin_time)*24*3600)) \n          from v$undostat) undo_ts_size \n  from dual;',3427,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2853,'查看操作的UNDO 信息','--SELECT s.username,\n  2         rs.segment_id,\n  3         r.usn,\n  4         rs.segment_name,      \n  5         r.rssize/1024/1024,\n  6         sq.sql_text\n  7    FROM v$transaction t, v$session s, v$rollstat r, dba_rollback_segs rs ,v$sql  sq,v$process pr\n  8  WHERE s.saddr = t.ses_addr\n  9     AND t.xidusn = r.usn \n 10     AND rs.segment_id = t.xidusn\n 11     AND s.sql_address=sq.address\n 12     AND s.sql_hash_value = sq.hash_value\n 13     AND s.PADDR=pr.ADDR\n 14  ORDER BY t.used_ublk DESC;\n',3427,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2854,'undo使用率','--SELECT \nseg.tablespace_name \"Tablespace Name\", \nts.bytes/1024/1024 \"TS Size(MB)\",   \nue.status \"UNDO Status\", \ncount(*)  \"Used Extents\",   \nround(sum(ue.bytes)/1024/1024, 2) \"Used Size(MB)\",   \nround(sum(ue.bytes)/ts.bytes*100, 2) \"Used Rate(%)\"\nFROM dba_segments seg, DBA_UNDO_EXTENTS ue,   \n(SELECT tablespace_name, sum(bytes) bytes     \n   FROM dba_data_files GROUP BY tablespace_name) ts\n    WHERE ue.segment_NAME=seg.segment_NAME and seg.tablespace_name=ts.tablespace_name \n    GROUP BY seg.tablespace_name, ts.bytes, ue.status ORDER BY seg.tablespace_name;',3427,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2855,'查看每十分钟undo保留的时间','--select to_char(begin_time, \'DD-MON-RR HH24:MI\') begin_time,\nto_char(end_time, \'DD-MON-RR HH24:MI\') end_time, tuned_undoretention\nfrom v$undostat order by end_time;\n',3427,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2856,'调优--UNDO_RETENTION','--undo保留的保留时间可以参考V$UNDOSTAT.TUNED_UNDORETENTION',3428,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2857,'undo的一些概念','--',3428,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2858,'一个transaction在undo_tablespace中分配空间的步骤','--',3428,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2859,'UNDO TS 管理','--',3429,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2860,'显示undo TS自动扩展','--ALTER DATABASE DATAFILE \'/oracle/dbs/undotbs.dbf\' RESIZE 300M;\nALTER DATABASE DATAFILE \'/oracle/dbs/undotbs.dbf\' AUTOEXTEND OFF;\n',3429,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2861,'UNDO_RETENTION','Parameter type	Integer\nDefault value	900\nModifiable	ALTER SYSTEM\nRange of values	0 to 231 - 1\nBasic	No\nOracle RAC	Oracle recommends that multiple instances have the same value.',3430,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2862,'UNDO_TABLESPACE','Parameter type	String\nSyntax	UNDO_TABLESPACE = undoname\nDefault value	The first available undo tablespace in the database.\nModifiable	ALTER SYSTEM\nRange of values	Legal name of an existing undo tablespace\nBasic	Yes\nOracle RAC	Each instance must have a unique value for this parameter, when it is set.',3430,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2863,'undo_management','Parameter type	String\nSyntax	UNDO_MANAGEMENT = { MANUAL | AUTO }\nDefault value	AUTO\nModifiable	No\nBasic	No\nOracle RAC	Multiple instances must have the same value.',3430,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2864,'TEMP_UNDO_ENABLED','Parameter type	Boolean\nDefault value	false\nModifiable	ALTER SESSION, ALTER SYSTEM\nRange of values	true | false\nBasic	No\nOracle RAC	Each session of each instance can have its own value or not set any value at all',3430,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2865,'v$rollname','V$ROLLNAME lists the names of all online rollback segments. It can only be accessed when the database is open.',3431,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2866,'v$rollstat','V$ROLLSTAT contains rollback segment statistics.',3431,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2867,'v$transaction',NULL,3431,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2868,'V$UNDOSTAT','--Contains statistics for monitoring and tuning undo space. Use this view to help estimate the amount of undo space required for the current workload. The database also uses this information to help tune undo usage in the system. This view is meaningful only in automatic undo management mode.',3431,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2869,'DBA_ROLLBACK_SEGS','--DBA_ROLLBACK_SEGS describes rollback segments.',3431,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2870,'TEMP_UNDO_ENABLED','--',3431,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2871,'DBA_HIST_UNDOSTAT','--',3431,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2872,'V$TEMPUNDOSTAT','--',3431,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2873,'DBA_UNDO_EXTENTS','--',3431,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2874,'DBA_OUTSTANDING_ALERTS','FRA添加或删除文件，这些事件会被记录到alert日志中。比如空间不够。',3432,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2875,'V$RECOVERY_FILE_DEST','查看FRA区域的使用情况（概况）',3432,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2876,'V$FLASH_RECOVERY_AREA_USAGE','具体查看某类文件使用FRA区域的大小。\n某类文件可能是ARCHIVE LOG/DATA FILE/BACKUP FILE/and so on',3432,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2877,'Search','Search',3433,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2878,'1','SELECT INDEX_NAME, BLEVEL, LEAF_BLOCKS AS \"LEAFBLK\", DISTINCT_KEYS AS \"DIST_KEY\",\n       AVG_LEAF_BLOCKS_PER_KEY AS \"LEAFBLK_PER_KEY\",--平均每个distinct indexed key的leaf block数\n       AVG_DATA_BLOCKS_PER_KEY AS \"DATABLK_PER_KEY\" --平均每个distinct indexed key的data block数\nFROM   DBA_IND_STATISTICS\nWHERE  OWNER = \'SH\'\nAND    INDEX_NAME IN (\'CUST_LNAME_IX\',\'CUSTOMERS_PK\');\n',3434,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2879,'crs','--',3435,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2880,'rac 工具 tool','clsfmt =>在安装GRID infrastructure二进制文件之后，root.sh脚本在内部执行这个工具，已设定，OCR和voting disk的格式\nolsnodes => 用于检测节点\ndiagcollention => 集群诊断集合工具，用来一次性收集有关所有必须组建的诊断信息.\ngpnptool => 管理GPnP配置文件\noifcfg => 接口配置工具，确定网卡在RAC中的使用。\nclscfg => 这个工具在CRS安装期间使用，建议不用使用，\ncemutlo => 输出cluster名称信息，\naddnode.sh => 添加节点脚本\ndeletenode.sh => 删除节点脚本',3436,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2881,'instance','--srvctl start database -db db_unique_name\nsrvctl start database -db db_unique_name -startoption nomount\nsrvctl start database -db db_unique_name -startoption mount\nsrvctl start database -db db_unique_name -startoption restrict\nsrvctl start database -db db_unique_name -startoption force',3436,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2882,'instance(shutdown)','--srvctl stop database -db db_unique_name -stopoption normal\nsrvctl stop database -db db_unique_name -stopoption immediate\nsrvctl stop database -db db_unique_name -stopoption transactional\nsrvctl stop database -db db_unique_name -stopoption abort\n#For SRVCTL, if the -stopoption option is omitted, the shutdown operation proceeds according to the stop options stored in the Oracle Restart configuration for the database. The default stop option is immediate.',3436,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2883,'管理ocr/olr','检查/备份/恢复/增加/移动/等',3437,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2884,'GLOBAL_TXN_PROCESSES','GLOBAL_TXN_PROCESSES specifies the initial number of GTXn background processes (GTX0, ... GTX9 and GTXa, ... GTXj) per instance to support global (XA) transactions in an Oracle RAC environment.\n这个参数指定GTXn后台进程的初始数量.rac中支持分布式事务。\n\nIf you want to disable the GTXn background processes, then you must set GLOBAL_TXN_PROCESSES to 0 in your parameter file. Setting this parameter to 0 will disable the XA support on an Oracle RAC database. Error ORA-55712 will be returned if you try to run XA transactions on an Oracle RAC database with this parameter set to zer0. You can change the setting to a nonzero value at run time to turn on the support for XA.\n\nGLOBAL_TXN_PROCESSES is useful for systems that process global (XA) transactions heavily. You do not need to specify a value for this parameter since Oracle Database automatically determines the number of processes and autotunes them, as necessary. GTXn background processes are only seen in an Oracle RAC environment.\n\nSee Also:\nOracle Database Development Guide for more information about this parameter',3438,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2885,'REMOTE_LISTENER','REMOTE_LISTENER specifies a network name that resolves to an address or address list of Oracle Net remote listeners (that is, listeners that are not running on the same system as this instance). The address or address list is specified in the TNSNAMES.ORA file or other address repository as configured for your system.\n',3438,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2886,'INSTANCE_NAME','在rac环境中，多个instance可疑访问到一个DB service.客户端可以压倒oracle connect load balancing 通过制定一个明确的instance，来链接这个instance。instance_name指定这个instance 的唯一名字。\n\n在单instance system，通常instance name 等于database name.\n\nrac手册:提到整个参数最好不要指定在参数文件中，让他默认。因为很多view的column的instance_name和inst_name是根据ORACLE_SID来的，而不是INSTANCE_NAME这个参数而来的.',3438,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2887,'ASM_PREFERRED_READ_FAILURE_GROUPS','ASM_PREFERRED_READ_FAILURE_GROUPS指定failure groups，这个failure groups包含优先的读取磁盘。优先的磁盘是instance指定的。\n\n这个参数只有效在oracle ASM instance中。\n\n这个参数一般被用在rac中，在每个node可以有不同的值。',3438,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2888,'LOCAL_LISTENER','LOCAL_LISTENER specifies a network name that resolves to an address or address list of Oracle Net local listeners (that is, listeners that run on the same system as this instance). The address or address list is specified in the TNSNAMES.ORA file or other address repository as configured for your system.\n\nLOCAL_LISTENER指定一个network name，这个network name解析了一个或多个Oracle net local listener address。\n这address或address list是指定在TNSNAME.ORA文件中，或者配置在你的系统中。',3438,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2889,'cluster_database','--CLUSTER_DATABASE is an Oracle RAC parameter that specifies whether or not Oracle RAC is enabled.',3438,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2890,'查看instance是不是rac instance','select parallel from v$instance;',3439,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2891,'gv$instance','--',3440,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2892,'查看当前系统中在线的某个用户的event','select event from v$session_event where sid =(select sid from V$SESSION where username=\'HR\');',3441,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2893,'查看当前系统用用户的一致读/物理读等','select a.username,b.block_gets,b.consistent_gets,\n	b.physical_reads,b.block_changes,b.consistent_changes\nfrom v$session a,v$sess_io b\nwhere a.sid=b.sid and username is not null \norder by 1;\n',3442,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2894,'v$sess_io','查看当前系统中用户的I/O使用和内存使用',3443,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2895,'V$SESSMETRIC','V$SESSMETRIC displays the metric values for all sessions.',3444,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2896,'查看每个session的负载和当前的sql text','select s.sql_id ,m.* from  v$sessmetric m,v$session s where  m.session_id=s.sid and m.session_serial_num=s.serial# order by 1,2,3;',3444,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2897,'查看某个用户当前正在执行的sql','select a.sid,a.username,s.sql_text\nfrom v$session a,v$sqltext s\nwhere a.sql_address = s.address;',3444,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2898,'查看session打开的游标数','--select o.sid,o.name ,o.value from 	   \n(select sid,n.name,s.value\n     from\n       sys.v_$statname  n,\n       sys.v_$sesstat  s\n     where\n       n.name in (\'opened cursors current\') and\n       s.statistic# = n.statistic#\n) o ,v$session s \nwhere s.sid=o.sid;',3445,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2899,'v$session_wait','V$SESSION_WAIT displays the current or last wait for each session\nThe P1RAW, P2RAW, and P3RAW columns display the same values as the P1, P2, and P3 columns, except that the numbers are displayed in hexadecimal.',3446,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2900,'V$SESSION_WAIT_CLASS','V$SESSION_WAIT_CLASS displays the time spent in various wait event operations on a per-session basis.',3446,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2901,'V$ACTIVE_SESSION_HISTORY','ASH取样database中活跃的session。他每秒执行一次快照。一个session在cpu上，或者等待一个event(这个event等待不包括idle等待)。\nThis view contains one row for each active session per sample and returns the latest session sample rows first. A majority of the columns describing the session in the active session history are present in the V$SESSION view.\n\nThe P1RAW, P2RAW, and P3RAW columns display the same values as the P1, P2, and P3 columns, except that the numbers are displayed in hexadecimal.',3446,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2902,'V$SESSION_EVENT','当前在线的session的event信息',3446,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2903,'v$session_wait_history','--session最近十次等待事件',3446,'2016-04-06 23:27:46','2016-04-06 23:27:46',NULL),(2904,'dba_hist_active_sess_history','--',3446,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2905,'查看执行过且有绑定变量的sql语句','select sql_id from v$sql_bind_capture;',3447,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2906,'v$sql_bind_capture','V$SQL_BIND_CAPTURE displays information on bind variables used by SQL cursors. Each row in the view contains information for one bind variable defined in a cursor. This includes:\n\nReference to the cursor defining the bind variable\n\n(hash_value, address) for the parent cursor and (hash_value, child_address) for the child cursor.\n\nBind metadata\n\nName, position, data type, character set ID, precision, scale, and maximum length of the bind variable.\n\nBind data\n\nOne of the bind values used for the bind variable during a past execution of its associated SQL statement. Bind values are not always captured for this view. Bind values are displayed by this view only when the type of the bind variable is simple (this excludes LONG, LOB, and ADT data types) and when the bind variable is used in the WHERE or HAVING clauses of the SQL statement.\n\n如果参数STATISTICS_LEVEL参数设置为BASIC那么Bind捕获关闭. This view can be joined with V$SQLAREA on (HASH_VALUE, ADDRESS) and with V$SQL on (HASH_VALUE, CHILD_ADDRESS).',3448,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2907,'SQL基线的概念','什么是SQL基线/以及作用.\nsql基线是存储在sysaux表空间中的，并且是有限额的，限额可以看select中的select语句，来查询',3449,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2908,'注入式攻击示例,不使用绑定变量的下场','见文档。',3450,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2909,'使用和不使用绑定变量的区别',NULL,3450,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2910,'HINT的几个概念','*HINT有效域\n*用HINT来为SQL语句起别名\n*等等',3451,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2911,'PROFILE的文本标准化','是否消除字面量对SQL语句签名的影响。',3452,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2912,'PROFILE使用的注意事项','1.SQL PROFILE会影响，相同文本的两条SQL语句，他们有相同的签名，即使引用的对象在不同的模式下，profile同样会影响到他们.',3452,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2913,'查看PROFILE使用被语句使用到','1.EXPLAIN PLAN FOR SELECT * FROM T ORDER BY ID;\n2.SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,\'BASIC+NOTE\'));\n3.会出现NOTE/SQL PROFILE \"IMPORT_SQL_PROFILE\" USED FOR THIS STATEMENT提示',3452,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2914,'PROFILE一些概念和创建概述','PROFILE主要的一点，是当你无法修改SQL语句(因为他被封装在软件中)时，你可以通过PROFILE来改变这个SQL语句原有的执行计划。',3452,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2915,'1.系统统计信息概念和操作','系统统计信息的概念/收集系统统计信息/删除系统统计信息等等',3453,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2916,'设置sql标识和trace','1.设置客户端标记/设置客户端信息/设置模块名称/设置操作名称\n2.开启SQL TRACE',3454,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2917,'PARTITION GANGE INLIST','访问多个分区，并且这些分区在解析时知道需要访问那些分区',3455,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2918,'PARTITION RANGE OR','对OR的谓语执行分区消除',3455,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2919,'PARTITION RANGE SINGEL','访问单个分区',3455,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2920,'PARTITION GANGE ITERATOR','访问多个分区，并且这些分区在解析时是不确定要访问哪些分区',3455,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2921,'PARTITION RANGE ALL','访问所有分区',3455,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2922,'PARTITION RANGE EMPTY','查询的数据不存在分区中',3455,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2923,'Full Table Scans','\"详细解释每个计划的含义\"',3455,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2924,'count stopkey','停止操作，返回给父',3455,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2925,'V$SQL_SHARED_CURSOR','--查看子游标为什么不能共享',3456,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2926,'DBMS_SQLTUNE.ACCEPT_SQL_PROFILE','接受SQL TUNING建议',3457,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2927,'DBMS_SQLTUNE.ALTER_SQL_PROFILE','更改profile',3457,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2928,'DBMS_STATS','统计信息相关操作。',3458,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2929,'DBMS_STATS.GATHER_SCHEMA_STATS','收集SCHEMA下的所有对象的统计信息。',3458,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2930,'DBMS_STATS.GATHER_TABLE_STATS','收集表的统计信息。',3458,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2931,'DBMS_STATS.GATHER_INDEX_STATS','收集索引的统计信息',3458,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2932,'DBMS_STATS.GATHER_FIXED_OBJECTS_STATS','收集动态性能视图的统计信息。',3458,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2933,'DBMS_STATS.GATHER_DICTIONARY_STATS','收集数据字典的对象统计信息.',3458,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2934,'DBMS_STATS.GATHER_DATABASE_STATS','收集整个数据库的对象统计信息',3458,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2935,'DBMS_STATS.CREATE_EXTENDED_STATS','扩展的统计信息。\n创建函数的索引，会自动创建扩展的统计信息。',3458,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2936,'DBMS_STATS.DELETE_TABLE_STATS','删除统计信息',3458,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2937,'DBMS_STATS.LOCK_SCHEMA_STATS','锁定SCHEMA下的对象的统计信息。',3458,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2938,'DBMS_STATS.LOCK_TABLE_STATS','锁定表的统计信息。',3458,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2939,'DBMS_STATS.DROP_EXTENDED_STATS','删除扩展的统计信息。\n删除函数的索引会自动删除扩展的统计信息，而且如果函数的索引没有删除，是不能通过这个DBMS来删除扩展的统计信息，如果执行会报ORA-20000错误',3458,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2940,'DBMS_STATS.UNLOCK_SCHEMA_STATS','解锁SCHEMA下的对象的统计信息。',3458,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2941,'DBMS_STATS.UNLOCK_TABLE_STATS','解锁定表的统计信息。',3458,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2942,'DBMS_MONITOR.CLIENT_ID_TRACE_ENABLE','开启trace，在client identifier(客户端标识符)级别，只要session被表示为某个client identifier,那么如果针对这个client identifier开启了trace，就会跟踪，注意这个过程，根据连接DB时OS进程号不同，会产生多个trace.',3459,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2943,'DBMS_SQLTUNE.CREATE_TUNING_TASK','创建一个调优任务\n',3460,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2944,'DBMS_SQLTUNE.REPORT_TUNING_TASK','查看调优报告',3460,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2945,'DBMS_SQLTUNE.EXECUTE_TUNING_TASK','执行调优任务',3460,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2946,'index_join','合并index',3461,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2947,'V$SQL_HINT','--查看DB中所有可用的HINT，包括hint可以用于的DB版本',3462,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2948,'查看最占用资源的sql语句，并排名','select * from (select sql_text,rank() over(order by buffer_gets desc) as rank_bufgets,\n to_char(100*ratio_to_report(buffer_gets) over (),\'999.99\') pct_bufegts,buffer_gets from v$sql)\nwhere rank_bufgets<11;',3463,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2949,'查找物理多的sql语句，以及执行它的用户','select b.username username,\n    a.disk_reads reads,\n    a.executions execute,\n    a.disk_reads/decode(a.executions,0,1,a.executions) rds_exec_ration,--每一次执行的disk read数量\n    a.command_type,\n    a.sql_text statement\nfrom v$sqlarea a,dba_users b\nwhere a.parsing_user_id=b.user_id and a.disk_reads>1000\norder by 3;\n--这里物理读是大于1000',3463,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2950,'V$SQL','--V$SQL列出shared sql area中的sql统计，不使用group by，因为需要列出原始sql text的每一个子游标。正常情况下，每个查询执行完成后就会更新这个视图，但是对于查询超过5秒的查询，这个查询的统计会每5秒一次更新这个视图。',3464,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2951,'DBA_HIST_SQLSTAT','DBA_HIST_SQLSTAT displays historical information about SQL statistics. This view captures the top SQL statements based on a set of criteria and captures the statistics information from V$SQL. The total value is the value of the statistics since instance startup. The delta value is the value of the statistics from the BEGIN_INTERVAL_TIME to the END_INTERVAL_TIME in the DBA_HIST_SNAPSHOT view.\n这个视图显示关系sql统计的历史信息。这个视图从V$SQL视图中捕获TOP SQL.\nThis view is used with the DBA_HIST_OPTIMIZER_ENV, DBA_HIST_SQLTEXT, and DBA_HIST_SQL_PLAN views to provide a complete picture of historical SQL statistics.',3464,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2952,'DBA_HIST_SQL_PLAN','用于检索DBA_HIST_SQLSTAT中sql语句的执行计划',3464,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2953,'DBA_HIST_SQLTEXT','用于检索DBA_HIST_SQLSTAT中sql_id变为sql_text',3464,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2954,'手动建立SQL基线','1.通过SQL语句来建立基线。\n2.通过SQL_ID来建立基线',3465,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2955,'手动替换基线','在语句不改变的情况，依旧执行FULL HINT，但是却是用INDEX语句的执行计划。',3465,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2956,'修改基线占用SYSAUX表空间的比例','DBMS_SPM.CONFIGURE(PARAMETER_NAME=>\'SPACE_BUDGET_PERCENT\',PARAMETER_VALUE=>5);\n这里设置的是50%',3465,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2957,'移动PROFILE到另一个数据库','1.通过CREATE_STGTAB_SQLPROF创建舞台表\n2.通过PACK_STGTAB_SQLPROF从数据字典中将SQL概要复制到舞台表\n3.通过REMAP_STGTAB_SQLPROF改变存储在舞台表中SQL概要的名称和类别\n4.通过UNPACK_STGTAB_SQLPROF将舞台表中的SQL概要复制到数据字典中。',3466,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2958,'修改PROFILE','*修改状态\n*修改描述',3466,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2959,'删除PROFILE','DBMS_SQLTUNE.DROP_SQL_PROFILE(NAME =>\'FIRST_ROWS\',IGNORE=>\'TRUE\');',3466,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2960,'手动创建PROFILE，而不通过SQL顾问','DBMS_SQLTUNE.IMPORT_SQL_PROFILE(\n	NAME 		=>	\'IMPORT_SQL_PROFILE\',\n	DESCRIPTION	=>	\'SQL PROFILE CREATED MANUALLY\',\n	CATEGORY	=>	\'TEST\',\n	SQL_TEXT	=>	\'SELECT * FROM T ORDER BY ID\',\n	PROFILE		=>	SQLPROF_ATTR(\'FIRST_ROWS()\',\'OPTIMIZER_FEATRUES_ENABLE(DEFAULT)\'),\n	REPLACE		=> 	FALSE,\n	FURCE_MATCH	=>	FALSE\n)；',3466,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2961,'statistics','\"统计相关操作\"',3467,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2962,'查看执行计划---dbms_xplan.cursor','--方法1(查看上一次执行的sql的执行计划):\n  --SELECT * from table(dbms_xplan.display_cursor(null,null,\'BASIC LAST ALLSTATS\'));\n--方法2(通过sql_id查看执行计划):\n  --select * from table(dbms_xplan.display_cursor(\'a67wqmkfb9j65\',null,\'typical -predicate -rows\'));',3468,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2963,'查看执行计划---指标',NULL,3468,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2964,'查看执行计划---dbms_xplan.display','显示plan_table$表中的执行计划:\n    step1:EXPLAIN PLAN FOR SELECT last_name FROM employees;\n    step2:SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY());\n    DISPLAY():中可以设置3个参数，见文档。',3468,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2965,'查看执行计划---通过视图','select id,lpad(\' \',2*(level-1))||operation||\' \'||options||\' \'||\n	object_name||\' \'||decode(id,0,\'cost=\'||cost) \"query plan_table\"\nfrom v$sql_plan\nstart with id=0\n		and sql_id =\'\'\n		and plan_hash_value =\nconnect by prior id = parent_id\n		and sql_id =\'\'\n		and plan_hash_value=\n',3468,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2966,'查看执行计划---dbms_xplan.DISPLAY_AWR','--',3468,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2967,'DB_FILE_MULTIBLOCK_READ_COUNT','设置多块读的数量。\n以下三种情况会导致，多块读的数目少于这个参数指定的数量,(换句话说,这个参数是怎么进行多块读的)\n1.读segment heard时是单块读\n2.物理读不能跨越extent\n3.部分数据块已经被cache，除非直接读，否则不会从I/O子系统重新读取。如果一个多块读被发出，要求读block 1 到block 10，但是block 5已经在buffer cache中，那么多块读会被分成2次第一次是block 1 到block 4 第二次是block 6 到block 10.\nps:此外如果有系统统计是，这个参数被系统统计的mbrc的值取代。\n',3469,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2968,'_SERIAL_DIRECT_READ ','直接路径读/direct path read\n值:TRUE/FLASE',3469,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2969,'OPTIMIZER_INDEX_COST_ADJ','设置优化器，在执行时偏向索引还是偏向全表扫描。',3469,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2970,'OPTIMIZER_INDEX_COST_ADJ---参数设置例子','例子:把本该索引扫描的执行，变成全表扫描。',3469,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2971,'OPTIMIZER_MODE','OPTIMIZER_MODE ESTABLISHES THE DEFAULT BEHAVIOR FOR CHOOSING AN OPTIMIZATION APPROACH FOR THE INSTANCE.',3469,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2972,'OPTIMIZER_FEATURES_ENABLE','限制优化器的版本，用于禁用最新的优化器特性.\n查询当前系统可设置的优化器版本。\nselect value from v$parameter_valid_values where name=\'optimizer_features_enable\';',3469,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2973,'DB_FILE_MULTIBLOCK_READ_COUNT---TEST','测试不同的参数设置，对多块读性能的影响',3469,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2974,'DB_FILE_MULTIBLOCK_READ_COUNT---TEST','以下情况会用到这个参数设置的值\n1.FULL SCAN TABLE\n2.INDEX FAST FULL SCAN\n以下情况不会用到这个参数设置的值(做过实验)\n1.index range scan(大范围的范围扫描，增大或缩小不会对成本有影响)。',3469,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2975,'DB_FILE_MULTIBLOCK_READ_COUNT---ORACLE_DOC','文档',3469,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2976,'OPEN_CURSORS','单个会话能够打开的最大游标数.',3469,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2977,'SESSION_CACHED_CURSORS','每个SESSION可以被缓存的游标数.',3469,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2978,'OPTIMIZER_DYNAMIC_SAMPLING',NULL,3469,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2979,'CONTROL_MANAGEMENT_PACK_ACCESS','--',3469,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2980,'OPTIMIZER_CAPTURE_SQL_PLAN_BASELINES','SQL基线是否打开参数。\n可以在session和system级别使用。',3470,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2981,'_OPTIM_PEEK_USER_BINDS','是否开启绑定变量窥探.',3471,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2982,'SQLTUNE_CATEGORY','激活SQL PROFILE\n可以使用的值:true/false/sql概要指定类别的名称。\n一个会话在一定时期内只能激活单个类别的sql概要。',3472,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2983,'ADMINISTER SQL MANAGEMENT OBJECT','创建/删除/更改SQL概要',3473,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2984,'创建计划表','UTLXPLAN.SQL',3474,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2985,'查看系统总的hard parse和总parse数量','select sum(s.value )\nfrom v$sesstat s,v$statname n \nwhere s.statistic#=n.statistic#  and\n    n.name in(\'parse count (hard)\',\'parse count (total)\') \ngroup by n.name',3475,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2986,'显示基线信息','SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_SQL_PLAN_BASELINE(SQL_HANDLE =>\'XXXXXXXX\'));',3476,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2987,'查看基线可以占用SYSAUX表空间的空间','SELECT PARAMETER_VALUE FROM DBA_SQL_MANAGEMENT_CONFIG WHERE PARAMETER_NAME=\'SPACE_BUDGET_PERCENT\';\n',3476,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2988,'查看sql的绑定变量','select sql_id,count(*) bind_count from v$sql_bind_capture where child_number =0 group by sql_id having count(*) >20 order by count(*);\n--还有一个需要注意的地方是，这个视图中记录的绑定变量只对where条件后面的绑定进行捕获，这点需要使用的时候注意。',3477,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2989,'查看SQL PROFILE','SELECT * FROM DBA_SQL_PROFILES',3478,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2990,'查看表的直方图','SELECT ENDPOINT_NUMBER,ENDPOINT_VALUE FROM DBA_HISTOGRAMS \n    WHERE OWNER=\'HR\' AND TABLE_NAME=\'T\' AND COLUMN_NAME =\'ID\';',3479,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2991,'查看扩展的统计信息','SELECT * FROM ALL_STAT_EXTENSIONS WHERE OWNER=\'HR\' AND TABLE_NAME=\'T\';',3479,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2992,'查看系统统计信息','select pname,pval1 from sys.aux_stats$;',3479,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2993,'查看当前session的trace file位置','select value from v$diag_info where name=\'default trace file\';',3480,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2994,'通过sql语句text来查看sql_id','select sql_id from v$sqlarea where sql_text like \'select * %\';',3481,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2995,'查看子游标','select status,sql_id,sql_child_number from v$session where username=\'xxx\';',3481,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2996,'查看子游标','SELECT SQL_ID,CHILD_NUMBER,SQL_TEXT FROM V$SQL WHERE SQL_TEXT LIKE \'XXX\';',3481,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2997,'sts概念','1.创建STS\n2.传输STS\n由12c doc:19 Managing SQL Tuning Sets提供',3482,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2998,'使用STS',NULL,3483,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(2999,'ADMINISTER SQL TUNING SET','使用DBMS_SQLTUNE管理自己的STS',3484,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3000,'ADMINISTER ANY SQL TUNING SET','使用DBMS_SQLTUNE管理任何STS',3484,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3001,'ALL_SQLSET','显示用户可见的STS相关的信息',3485,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3002,'tuning sql text','手动调用sql tuning advisor，来调优sql text',3486,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3003,'Automatic SQL Tuning Task(Enabling | Disabling)','--exec DBMS_AUTO_TASK_ADMIN.ENABLE (client_name => \'sql tuning advisor\',operation => NULL,window_name => NULL);\nexec DBMS_AUTO_TASK_ADMIN.DISABLE (client_name => \'sql tuning advisor\',operation => NULL,window_name => NULL);',3486,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3004,'STATISTICS_LEVEL ','--需要设置为basic才能开启sql 调优顾问',3487,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3005,'查看sql truning adviosr是否开启','--SELECT CLIENT_NAME, STATUS FROM   DBA_AUTOTASK_CLIENT WHERE  CLIENT_NAME = \'sql tuning advisor\';\n',3488,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3006,'DBA_ADVISOR_TASKS','这个视图显示database中所有的task。其中每一个task有一行row。每个task有一个唯一的名字给到拥有者。Task names are just informational and no uniqueness is enforced within any other namespace.\nRelated View:USER_ADVISOR_TASKS displays information about the tasks owned by the current user. This view does not display the OWNER column.',3489,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3007,'V$ADVISOR_PROGRESS',NULL,3489,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3008,'DBA_ADVISOR_LOG','显示database中所有task的状态，包括进程监视和完成状态。这个view中每个task有一个row。\nRelated View:USER_ADVISOR_LOG displays information about the current state of the tasks owned by the current user. This view does not display the OWNER column.\n',3489,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3009,'v$sqlarea','v$sqlarea displays statistics on shared sql areas and contains one row per sql string. it provides statistics on sql statements that are in memory, parsed, and ready for execution.',3490,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3010,'V$SQLSTATS','--',3490,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3011,'DBA_SQL_PLAN_BASELINES','查看SQL基线',3491,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3012,'DBA_TAB_STATISTICS','表的统计信息',3492,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3013,'ALL_TAB_COL_STATISTICS','列的统计信息',3492,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3014,'ALL_IND_STATISTICS','索引统计信息',3492,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3015,'ALL_PART_COL_STATISTICS','分区的列和直方图的信息',3492,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3016,'ALL_SUBPART_HISTOGRAMS','子分区的直方图信息。',3492,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3017,'ALL_IND_PARTITIONS','索引的分区统计信息',3492,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3018,'ALL_IND_SUBPARTITIONS','索引子分区的统计信息',3492,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3019,'ALL_STAT_EXTENSIONS','扩展的统计信息。',3492,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3020,'ALL_TAB_HISTOGRAMS','表的直方图信息',3492,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3021,'ALL_PART_HISTOGRAMS','分区的直方图信息。',3492,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3022,'ALL_SUBPART_COL_STATISTICS','子分区的列的统计信息和直方图信息。',3492,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3023,'PLAN_TABLE','计划表，存放执行计划',3493,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3024,'V$SQL_WORKAREA',NULL,3493,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3025,'V$SQL_PLAN',NULL,3493,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3026,'V$SQL_PLAN_STATISTCS',NULL,3493,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3027,'V$SQL_PLAN_STATISTICS_ALL','V$SQL_PLAN_STATISTICS_ALL contains memory usage statistics for row sources that use SQL memory (sort or hash-join). This view concatenates information in V$SQL_PLAN with execution statistics from V$SQL_PLAN_STATISTICS and V$SQL_WORKAREA.',3493,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3028,'dba_hist_sql_plan','--',3493,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3029,'commit/rollback/隔离级别','\"参数/操作说明\"',3494,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3030,'自制事务的使用和阻塞的报错','--set transaction\n\nDBMS_TRANSACTION\n',3494,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3031,'查看transaction开始的scn','--select xidusn,xidslot,xidsqn,start_scn from v$transaction;',3495,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3032,'查看DB中commit数','--select value from v$sysstat where name=\'user commits\';',3495,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3033,'dbms_flashback.get_system_change_number','查看系统scn号',3496,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3034,'普通用户查看系统参数---脚本','\"并不是所有参数都可以用这个脚本查看，如果看不到会显示*access denied* 拒绝访问\"',3497,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3035,'_DB_PERCENT_HOT_DEFAULT','热点区域里的缓冲区比例，默认值50',3498,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3036,'_DB_AGING_TOUCH_TIME','递增touch计数所需要的秒数，默认值3',3498,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3037,'_DB_AGING_HOT_CRITERIA','把缓冲区移到lru链的mru端的阈值，默认值2',3498,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3038,'DB_KEEP_CACHE_SIZE',NULL,3498,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3039,'DB_RECYCLE_CACHE_SIZE',NULL,3498,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3040,'_DB_AGING_STAY_COUNT','当移到mru端时把touch计数重置为该值，默认为0',3498,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3041,'_DB_AGING_COOL_COUNT','当移到lru段时把touch计数重置为该值',3498,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3042,'FAST_START_MTTR_TARGET','Parameter type	Integer\nDefault value	0\nModifiable	ALTER SYSTEM\nRange of values	0 to 3600 seconds\nBasic	No\nOracle RAC	Multiple instances can have different values, and you can change the values at run time.',3498,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3043,'TIMED_STATISTICS','value:true/false\n建议:不管是否调优都不这个参数打开true',3498,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3044,'LOG_CHECKPOINT_INTERVAL',NULL,3498,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3045,'resource_limit','--设置是否开启限制资源',3498,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3046,'recovery_parallelism','--设置 instance recovery的并行度',3498,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3047,'查看系统时间负荷分布','SELECT * FROM V$SYS_TIME_MODEL;',3499,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3048,'查看某SESSION的时间模型分布','SELECT * FROM V$SESS_TIME_MODEL;',3499,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3049,'查看本instance的运行时长','SELECT TO_CHAR(startup_time, \'DD-MON-YYYY HH24:MI:SS\') started_at,\n       TRUNC(SYSDATE - (startup_time)) || \'day(s).\' ||\n       TRUNC(24 *\n             ((SYSDATE - startup_time) - TRUNC(SYSDATE - startup_time))) ||\n       \'hour（s）.\' || MOD(TRUNC(1400 * ((SYSDATE - STARTUP_TIME) -\n                               TRUNC(SYSDATE - STARTUP_TIME))),\n                         60) || \'minute(s).\' ||\n       MOD(TRUNC(86400 *\n                 ((SYSDATE - STARTUP_TIME) - TRUNC(SYSDATE - STARTUP_TIME))),\n           60) || \'seconds\' uptime\n  FROM v$instance;',3499,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3050,'查看instance granules大小','--SELECT component,granule_size from v$sga_dynamic_components;\nselect * from v$sgainfo where name=\'Granule Size\';\n',3499,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3051,'查询当前SGA已经占用的内存size','--SELECT ((SELECT SUM(value) FROM V$SGA) -\n       (SELECT CURRENT_SIZE FROM V$SGA_DYNAMIC_FREE_MEMORY)) \"SGA_TARGET\"\n  FROM DUAL;',3499,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3052,'查看某个用户的系统使用情况','select a.username,c.name,sum(b.value) value\nfrom v$session a,v$sesstat b,v$statname c\nwhere a.sid =b.sid\nand b.statistic#=c.statistic#\nand b.value <>0\ngroup by name,username order by 1;',3500,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3053,'查看哪个用户被那个用户阻塞','select sid,blocking_session,username,blocking_session_status from v$session ;',3500,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3054,'v$system_event','--',3501,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3055,'各种审计操作','\"操作说明\"',3502,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3056,'help index','显示sqlplus命令.另外还可以在用help command，相应的命令来看参数\n例:\n    help set',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3057,'copy','从远端DB复制表,note:copy复制表，相比create xxx as select...创建有个优势，就是不会受到某些数据类型额限制，但是劣势就是速度慢。\n例:\nsql>copy from sys/oracle@tnsname -\n    create test - \n    using select * from employees;',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3058,'get','在sqlplus中读取文本,例子:\nget abc.sql\n还可以这样用get,可以同时执行多个脚本:\nsql> get abc.sql\n1.@cba.sql\n2.@dfd.sql\n\n',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3059,'remark','注释sqlplus脚本,例：\nremark select  * from employees;',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3060,'break','一种不适用group语句，但是达到group的显示效果的做法：见本文档。',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3061,'column xxx format axx HEADING \'XXX\'','1.格式化列在sqlplus中显示的长度\n2.加前导符号\n3.替换列名\n4.显示列宽(限制分字符和数字)\ncol[umn] xxx for[mat] axx HEADING \'XXX\'\n见文档',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3062,'repfooter','在报告底部当一个页脚,例子:\nrepfooter page right \'ccccccccccccccccccccccccccccccccccccc1\'\nnote:使用完记得关闭 sql>repfooter off',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3063,'repheader','在报告顶部打印页眉\nrepheader page right \'ccccccccccccccccccccccccccccccccccccc1\'\nnote:使用完记得关闭 sql>repheader off',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3064,'ttitle','在每一页的顶部打印:\nttitle \'abc\'\nnote:使用完记得关闭 sql>ttitle off',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3065,'btitle','在每一页的底部打印\nbtitle \'cba\'\nnote:使用完记得关闭 sql>btitle off',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3066,'save','保存sqlplus中buffer的内容. \nparameter：replace/APPEND #对已存在的文件追加和替换，文件中的内容,例子\nsql>save replace | append abc.txt\nnote:保存的是buffer内容，不是select出来的row的内容',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3067,'define/undefine','定义变量/撤销定义变量:\n例子：\ndefine dept = abc\nselect \'&dept\' aa from dual;\nundefine dept\n还可以在没有参数的情况下使用，例：\nsql>DEFINE',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3068,'define_editor','设置OS文本编辑器位置,可以使用edit来在sqlplus中调用：\ndefine_editor=\'/<full path>/myeditor.exe\'.',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3069,'clear','*清除屏幕信息。\nclear breaks/clear buffer/clear columns/clear sql/clear timing/clear screen',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3070,'show','*show recyclebin :显示回收站信息，可以确认哪些表，可以用于flashbak to befroe drop命令。\n*show errors:显示错误记录信息,show errors [procedure xxx],还可以在为运行plsql之前，检验一下语法。\n*show user:\n*show parameter\n*show 环境变量名:来看这个环境变量的值，例:show timing',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3071,'store','1.把当前sqlplus的环境变量保存在xx.sql\n2.把xx.sql里保存的换将变量，在当前环境生效。\n例子:保存=>store set xxx.sql,使用=>start xxx.sql',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3072,'spool','*输出记录在操作系统文本中\nspool {file_name[.ext] [CRE[ATE]|REP[LACE]|APP[END]]|OFF|OUT}\nFILE_NAME #存放的文件\ncre #crete创建新的文件\nREP #替换已有文件的内容，如果文件不再则创建\nAPP #加载到文件的最后\n例子\nspool xxx.txt\nselect * from talbe;\nspool off;\n',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3073,'accept','*在脚本中，输入，并把输入赋给变量\n例子\n    prompt Please enter employee number; #一般accept和prompt结合使用，prompt用于提示输入什么，accept用来接收值。\n    accept lastname;\n    set serveroutput on\n    exec dbms_output.put_line(\'&lastname\');\n    exit',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3074,'exec[ute]','*执行plsql\n例子:exec dbms_abc;',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3075,'compute','可以计算avg/sum/MAX/MIN例子:\nSQL> compute sum of sal on deptno;#根据不同的deptno组，来看sal的总计。\nSQL> select * from emp where deptno =20;',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3076,'edit','打开OS的文本编辑器，可以用define_editor来设置，使用那个文本编辑器。',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3077,'注释','/**/\n--\nREMARK',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3078,'buffer相关操作','替换buffer:c/XX/XX，插入/删除,具体见文档。',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3079,'recover','恢复命令',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3080,'archive log','archive log {start|stop|list}',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3081,'@/@@/run','执行脚本	SQL>@/@@/START/run\nstart @{url | file_name[.ext]} [arg ,,,]\nurl //可以运行远端的脚本，\nfile_name[.EXT] //可以代扩展名\narg //参数\n',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3082,'prompt','打印输出，例:prompt abc #打印了abc，一般用于脚本',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3083,'继续符\'-\'','#如果继续符在用于数字之间，会有误解.\nselect 200 -\n100 from dual;\n#继续符就是一个空格，结果是 select 200 100 from dual; 不是想要的select 200100 from dual;\n#另一个误解是减号\nselect 200 -\n100 from dual; #结果会报错\n#应该写成\nselect 200 - -\n100 from dual;',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3084,'desc[ribe]','*显示表或过程或函数的定义\nSQL> DESC[RIBE] table_or_view_name\nSQL> DESC afunc(PL/SQL 过程或函数的调用接口)\n',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3085,'new_value','--把查询结果传给变量',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3086,'CONN[ECT]','--CONN[ECT] [logon] [AS {SYSOPER | SYSDBA | SYSBACKUP | SYSDG | SYSKM}]\n    {username | /}[@connect_identifier] [edition={edition_name | DATABASE_DEFAULT}]\n        connect_identifier \"host[:port][/service_name][:server][/instance_name]\"\n            :server：dedicated, shared, and pooled，这写参数称为(service handler type)\n        edition={edition_name | DATABASE_DEFAULT}：指定一个版本，如果需要指定一个版本需要use权限。如果不指定，那么默认就是DATABASE_DEFAULT',3503,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3087,'sqlplus默认配置文件位置','--$ORACLE_HOME/sqlplus/admin/glogin.sql',3504,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3088,'sqlplus set','\"set相关设置\"',3505,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3089,'基本用法','\"...\"',3505,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3090,'限制oracle用户使用sqlplus来使用命令','--可以限制ALTER/BEGIN/CONNECT/DECLARE/EXEC/EXECUTE/GRANT/HOST/INSERT/SELECT/UPDATE命令，只有被限制的用户使用sqlplus才会被限制。',3505,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3091,'普通用户使用set autot trace','--SQL> grant select on v_$statname to goku\nSQL> grant select on v_$statname to goku;\nSQL> grant select on v_$mystat to goku;\nSQL> grant select on v_$sesstat to goku;\n\n',3505,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3092,'-F','允许SQL*PLUS从rac DB 接受FAN。',3506,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3093,'-S','静默模式',3506,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3094,'-L','无提示登录，若在第一次时未能登录，将不再提示输入新用户名和密码。',3506,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3095,'-M','从sqlplus中产生网页形式的输出。参数:\n-M HTML [ON|OFF] [HEAD text] [BODY text] [TABLE text] [ENTMAP {ON|OFF}] [SPOOL {ON|OFF}] [PRE[FORMAT] {ON|OFF}]\nHTML:是否生成网页\nHEAD:HEAD怎么写，可以自己来定义，直接写在这里.\nBODY:同HEAD\nTABLE:同HEAD\nENTMAP:是否把html的关键字,\'>\',\'<\'，替换成HTML的形式< >\nSPOOL：是否开启SQLUS来写<HTML> and <BODY>, 这两个标签.#开启的话自动格式化表格样式，还是不错的。\nPREFORMAT：是否开启<PRE>标签，如果开启为ON，那么不会生成以<table>形式的输出。',3506,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3096,'-R','*限制sqlplus使用command的能力，有3个级别，1、2、3，3为限制最高.\n*限制级别的具体实现见本文档。\n*level 3时，oracle不读取login.sql。',3506,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3097,'tnsname','--SQLPLUS hr@\\\"(DESCRIPTION=\n(ADDRESS=(PROTOCOL=tcp)(HOST=sales-server)(PORT=1521) )\n(CONNECT_DATA=\n(SERVICE_NAME=sales.us.acme.com) ) )\\\"',3506,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3098,'使用sqlplus输出html和excel','\"脚本使用方法\"',3507,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3099,'在sqlplus中限制用户使用DML/DDL','限制oracle用户使用sqlplus来使用以下命令ALTER/BEGIN/CONNECT/DECLARE/EXEC/EXECUTE/GRANT/HOST/INSERT/SELECT/UPDATE/命令,见文档',3507,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3100,'SQL标示符','--set sqlprompt _user-SQL>',3507,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3101,'set markup','key:sqlplus 网页\n把select结果生成html\nsql> set markup html on spool on;\nsql> commands ....\nsql> set markup html off spool off;',3508,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3102,'PAGES[IZE] {14|n}','--设置一页的行数.\n--什么是一页:sqlplus打印出的数据格式为、一行列名/N行数据/空行/一行列名/N行数据/空行，其中\'一行列名/N行数据/空行/\'就这个就代表一页，也就是说一页至少需要2行，如果查询是有数据的话，那么至少需要3行。',3508,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3103,'set newp[age] {1/n/none}','*制定每个新页顶部的空行数量,在sqlplus中表示，发送语句，到回返结果之间空行数。',3508,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3104,'set ti[me] {off/on}','*是否显示时间，这个时间不是执行时间，而是真是时间.\n例子:11:53:29 SQL>',3508,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3105,'set errorlogging on|off','*开启错误记录，用一个表，把sqlplus中用户执行sql产生的错误，都记录在里面\n*show errorlogging # 显示错误记录是否开启，以及如果开启后的记录(记录错误的表)位置。\n',3508,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3106,'set pause on|off','*在显示完一页后停顿，直到按回车再显示下一页。可以配合set pagesize 一起使用',3508,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3107,'SET AUTO[COMMIT] { OFF | ON | IMM[EDIATE] | n }','*设置自动提交\nset autocommit 10  执行10条DML语句，就自动提交，PLSQL block 算一条事务。建议off',3508,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3108,'set sqlprompt','连接用户的显示.变量：\n_connect_identifier #数据库名\n_date\n_editor 指定了使用edit命令启动那个编辑器。\n_o_version\n_o_release\n_privilege #显示权限\n_sqlplus_release\n_user #显示当前用户\n组合使用：set sqlprompt \"_connect_identifier\'@\'_user\'@\'_date >\"',3508,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3109,'set hea[ding]','*是否打印列标题\n*off/on',3508,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3110,'timi[ng] {off/on}','*显示sql执行时间',3508,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3111,'Set serveroutput on [WORD_WRAPPED|TRUNCATED]','*显示执行结果（PL/SQL）\n*parameter:\n    WORD_WRAPPED #这个参数受到set line 设置的影响，长出的部分会换行。\n    TRUNCATED #这个参数也受到set line的影响，但是长出的部分被截断。\nset serveroutput on size 100000 #设置缓存区大小',3508,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3112,'SET LONGCHUNKSIZE 200','这个参数与set long相关，他表示每一行显示的字符数(也会受到set line影响)。有例子',3508,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3113,'help set','--帮助',3508,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3114,'VER[IFY] {ON|OFF}','--可以关闭和打开提示确认信息old 1和new 1的显示. ',3508,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3115,'TRIM[OUT] {ON|OFF}','--去除标准输出每行的拖尾空格，缺省为off',3508,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3116,'TRIMS[POOL] {OFF|ON}','--去除重定向（spool）输出每行的拖尾空格，缺省为off',3508,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3117,'LIN[ESIZE] {80|n}','--每行的字符数，溢出部分换行，不会截断\n--设置WRA[P] {ON|OFF}可以设置多出部分截断',3508,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3118,'WRA[P] {ON|OFF}','--设置当行长度超过linesize时，是否截断显示。',3508,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3119,'NUM[WIDTH] {10|n}','--输出number类型域长度，缺省为10',3508,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3120,'NULL text','--设置把null的显示转换为text指定的字符',3508,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3121,'FEED[BACK] {6|n|ON|OFF}','--回显本次sql命令处理的记录条数，缺省为on',3508,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3122,'set echo {on|off}','--是否显示start启动的脚本中的每个sql命令，缺省为on',3508,'2016-04-06 23:27:47','2016-04-06 23:27:47',NULL),(3123,'TERM[OUT] {ON|OFF}','--是否显示sql命令结果',3508,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3124,'AUTOT[RACE] {OFF | ON | TRACE[ONLY]} \n  [EXP[LAIN]] [STAT[ISTICS]]','--开启统计信息或执行计划输出',3508,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3125,'autoprint{on|off}','--自动打印变量值',3508,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3126,'show {error | errors}','--显示错误，比如:plsql编译出错，他不直接显示在sqlplus中，需要show error才能把出错的地方显示出来。',3509,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3127,'show parameter xx','--查看参数',3509,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3128,'show CON_NAME','--查看当前使用的pdb',3509,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3129,'Thread 1 cannot allocate new log','--1.表示logfile切换时，导致，dbwr写脏数据太慢，导致当前logfile不能被释放，db无法写入logfile，导致db hang。\n2.第二种，logfile切换写archivelog，写的太慢，导致logfile不能释放，新的redolog条目无法写入logfile，导致db hang。',3510,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3130,'DIA-48448','ADRCI导致\n使用IPS CREATE PACKAGE;所显示的错误，由于ADRCI> SHOW HOMEPATH 指定了多个主目录所导致，HOMEPATH只有当指定一个目录时才能执行IPS CREATE PACKAGE。',3511,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3131,'INS-20802','grid安装\n安装grid报错-scan错误',3512,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3132,'INS-20802','rac安装\n\"netca错误\"',3512,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3133,'INS-40908','\"未记录\"',3512,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3134,'INS-32012','rac安装\n安装rac时碰到，问题出在/u01/app这个目录定义的组成员不能写。需修改成775',3512,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3135,'INS-13001','--原因:\n   Centos 6.5安装Oracle 12c r1执行到第二步Skip software updates报INS-13001，log的错误信息\n   WARNING: [WARNING] [INS-13001] Environment does not meet minimum requirements.\n   CAUSE: Minimum requirements were not met for this environment\n   ACTION: Either check the logs for more information or check the supported configurations for this product..\n--解决:\n    download the rh.noarch.tar from the oracle metalink note RHEL6: 12c OUI INS-13001: CVU Fails: Reference data is not available for verifying prerequisites on this operating system distribution (Doc ID 1567127.1)\n\n[1] install the rpm redhat-release-6Server-1.noarch.rpm\n\n[root@oracledb1 oracle]# rpm -ivh redhat-release-6Server-1.noarch.rpm\nPreparing...                ########################################### [100%]\n   1:redhat-release         ########################################### [100%]\n\nCheck the installed rpm \n[root@oracledb1 OraInstall2013-11-22_10-07-58AM]# rpm -qa | grep redhat-release\nredhat-release-server-6Server-6.4.0.4.el6.x86_64\nredhat-release-6Server-1.noarch\n[root@oracledb1 OraInstall2013-11-22_10-07-58AM]#',3512,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3136,'INS-30131','--原因:\n  安装程序产生的文件和/tmp下已有的文件产生冲突\n解决:\n  删除/tmp下的一些文件。',3512,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3137,'ORA-01547','ORA-01547ORA-01547: warning: RECOVER succeeded but OPEN RESETLOGS would get error below\n我是在archivelog模式下，热备份，但是没有备份archivelog，只备份了datafile，在恢复的时候导致不一致，无法用resetlogs打开数据库，可以使用_allow_resetlogs_corruption=TRUE这个隐藏参数解决。',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3138,'ORA-19813','ORA-19813ORA-19813: cannot have unavailable file /u01/app/flash_recovery_area/GOKU/backupset/2014_03_20/o1_mf_nnndf_TAG20140320T091951_9lnjkr5o_.bkp in DB_RECOVERY_FILE_DEST,在fra中不能为unavailable',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3139,'ORA-01543','ORA-01543创建分区时，分区的名字一样了，会包这个错误',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3140,'ORA-04150','ORA-04150DOC-1658',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3141,'ORA-01743','ORA-01743DOC-1660',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3142,'ORA-4031','ORA-4031共享内存碎片化导致宕机',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3143,'ORA-55610','ORA-55610在使用DROP TABLE XX;时报的错误.\nORA-55610: INVALID DDL STATEMENT ON HISTORY-TRACKED TABLE \n需要先关闭表的闪回数据归档。',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3144,'ora-12838','ora-12838\"直接路径插入错误\"',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3145,'ora-12014','ora-12014\"创建物化视图log报错\"',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3146,'ORA-27486','ORA-27486\"执行DBMS_PARALLEL_EXECUTE显示的权限不足\"',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3147,'ora-00257','ora-00257\"触发原因：执行impdp时所导致的错误\"',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3148,'ORA-01031','ORA-01031\"dbca安装DB报错\"',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3149,'ORA-15081','ORA-15081\"显示无法读取asm磁盘\"',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3150,'ORA-16047','ORA-16047\"配置DG时的错误\"',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3151,'ORA-16179','ORA-16179\"启动instance时错误。\"',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3152,'ORA-30052','ORA-30052\"闪回查询时的错误\"',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3153,'ORA-00257','impdp\"执行impdp时所导致的错误\"',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3154,'ORA-00845','ORA-00845\"启动时显示memory_target不支持所致\"',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3155,'ORA-30653','ORA-30653\"外部表创建完毕后，查询错误\"',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3156,'ORA-00376','ORA-00376ORA-00376: file cannot be read at this time\n这个解决方案:recover这个data file',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3157,'ORA-12537','ORA-12537在11.2.0.1中过DNS解析来配置的固定SCAN VIP和节点的VIP地址。这个错误是一个bug，在11.2.0.2修复.',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3158,'ORA-03137','--①  可以通过更换不同版本的JDBC驱动来避免该错误，也说明为什么同事在另外一套环境下，通过Weblogic的JDBC来访问数据库时，则不会遇到该错误；\n② 给数据库打patch,初步认为可以通过打Patch:9703463 来解决；\n③ 通过修改数据库参数来规避该错误：\n修改之后，同事用之前的Tomcat那个版本的驱动来重新访问数据库时，则不再报错；\n④ 直接升级数据库版本至11.2.0.3.0，通过导出导入的方式将刚项目组下的schema数据复制一份到一套11.2.0.3.0的库上，重新使用Tomcat那个版本的驱动来重新访问数据库时，亦不再报错。\n\nhttp://www.oracleonlinux.cn/2013/09/ora-17410_and_ora-03137/',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3159,'ora-01950','--用户x建表的时候提示：ora-01950：对表空间‘x’无权限\n原因：用户没有resource权限\n解决方法：连接sys用户，赋予用户x resource权限\n          grant resource to x;',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3160,'ORA-01031','----原因\n    远程tns登录报错(ORA-01031: insufficient privileges)\n--解决\n    创建口令文件Linux> ORAPWD ',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3161,'ORA-08181','--原因:执行scn_to_timestamp引发的\n处理:不能对于超过5天的数据(scn)执行这个操作\n--可以通过select min(scn) from sys.smon_scn_time来查询目前可以查到的最小的scn',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3162,'ORA-00054','--指定DDL语句会产生的错误，因为资源被锁导致\n--可以修改参数ddl_lock_timeout,使得DDL操作持续等待，直至操作成功。',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3163,'ORA-04095','--原因:trigger \'string\' already exists on another table, cannot replace it\n处理:Drop the trigger with the same name and re-create it.',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3164,'ORA-19550','--原因:\n   使用rman登录数据库报错\n处理:\n   将tnsname中的相应service name改为(SERVER = DEDICATED)，因为共享服务器链接模式是不能做备份的',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3165,'ORA-01732','--问题:\n    insert一个表时出现的错误\n    ORA-01732: data manipulation operation not legal on this view\n解决:\n   当你看见一个表时(dba_objects.object_type),他未必真的是一个表，当你创建一个物化视图的时候自动为你创建一个物化视图对象，同时在创建一个表，这个表是不能insert的。',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3166,'ORA-01950','--原因:\n    insert时报错。ORA-01950: no privileges on tablespace \'SALES\'\n解决:\n     执行insert用户对ts的使用权限(或者空间使用限制)不够， grant UNLIMITED TABLESPACE to lsss;之后正常。',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3167,'ORA-31693\nORA-00936','--原因:\n    expdp时发生的错误，expdp maclean/maclean directory=dump tables=estimate_me query=estimate_me:\"where t1<2000\"\n解决:\n    /* 不采用参数文件形式，没有加单引号的情况下出现ORA-00936: missing expression错误*/，要么使用参数文件，要么加上单引号\n   expdp maclean/maclean directory=dump tables=estimate_me query=estimate_me:\'\"where t1<2000\"\'',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3168,'ORA-12505','--错误:\n    ORA-12505, TNS:listener does not currently know of SID given in connect descriptor\n原因:\n    使用jdbc链接oracle时发生的错误\n解决:\n    把\"jdbc:oracle:thin:@107.167.13.130:1521:pdb_newandrstore\",\"newandrstore\",\"newandrstore_usa\"改成\"jdbc:oracle:thin:@107.167.13.130:1521/pdb_newandrstore\",\"newandrstore\",\"newandrstore_usa\"就可以了，语法问题，不是要使用sid，对于oracle链接来说只要3样东西，ip/端口/service_name',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3169,'ORA-01013 ','--官方文档对这个错误的解释,我还没碰到\nAfter ORA-01013 occurs, you must consider the instance to be in an unpredictable state. You must therefore continue the shutdown process by resubmitting a SHUTDOWN command. If subsequent SHUTDOWN commands continue to fail, you must submit a SHUTDOWN ABORT command to bring down the instance. You can then restart the instance.',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3170,'ORA-12545','--原因:\n   设置中转通过remote_listener参数，链接时出现ORA-12545: Connect failed because target host or object does not exist \n解决:\n   即使不能直接连接想要的数据库，但是客户端机器上hosts文件还是要设置要链接的database的hostname以及ip\n   文档3113',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3171,'ORA-01502','--报错:\n   ORA-01502:index ‘OTA.PK_TBLOTA’or partition of such index is in unusable state(猜测可能是DML时报错)\n解决:\n   rebuild，UNUSABLE索引。\n原理：\n   猜测普通的索引就算失效，也不会导致表不能DML，但是这个索引是一个主键，需要使用索引来保证唯一性，所以会产生索引不能用,DML不能执行的情况。',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3172,'ORA-30926','--使用merge语句出现的错误:\n    如果出现ORA-30926错误（无法获得稳定的行），这个错误针对update而言的，B表中Q列有和A表中A列相同的值，而且A表中A列和B的Q中的相同值还不只一个，所以无法判断用A表中的那个相同值的行来更新B中Q列相同值的行。主要是源表(也就是A不能有重复)',3513,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3173,'shutdown immediate hang住问题','\"解决方法\"',3514,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3174,'11.2.0.1 linux rac 重启节点(OS)后遇到asm磁盘组不能加载','此问题为11.2.0.1的bug\nWARNING: failed to online diskgroup resource ora.GI.dg (unable to communicate with CRSD/OHASD',3514,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3175,'莫名 | scheduler不能执行','--查看系统级别oracle进程是否过多，是的oracle不能启动process',3514,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3176,'RMAN-06564','\n数据库已经使用了SFPILE，就不能在$ORACLE_HOME/DBS/下恢复，只能回到其他位置。',3515,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3177,'RMAN-06172','--错误:\n    RMAN-06172: no AUTOBACKUP found or specified handle is not a valid copy or piece\n--原因:\n    restore spfile时出错\n--解决:\n    oracle对于指定的备份文件没有权限',3515,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3178,'TNS-12542/TNS-12560/TNS-00512','--原因:\n    启动lsnrctl start 报错(具体见文档)\n解决:\n    1.首先检查/etc/hosts 是否N个IP指向了同一个主机名\n    2.检查hostname是否存在于/etc/hosts 中。',3516,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3179,'TNS-01189: The listener could not authenticate the user','--原因:\n   lsnrctl status时报的错。\n   TNS-01189: The listener could not authenticate the user\n解决:\n   linux 6 中host文件中hostname和ip不符导致',3516,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3180,'LNS','--从SGA的重做缓冲区读取信息，交由ORACLE NET传输到备用DB。\n--在多备用配置中，每个LNS对应一个备用DB，所以LNS不止可以有一个。\n--而且有两种传输方法，同步和异步',3517,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3181,'RFS','--LSN传输的redo log，在备用DB这边由RFS接收',3517,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3182,'Start LOGICAL STANDBY SQL Apply','--SQL> ALTER DATABASE START LOGICAL STANDBY APPLY;\n--SQL> ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;\n',3518,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3183,'Stop LOGICAL standby Redo Apply','--SQL> ALTER DATABASE STOP LOGICAL STANDBY APPLY;',3518,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3184,'取消延迟应用redo log','--SQL> ALTER DATABASE START LOGICAL STANDBY APPLY NODELAY;\n--这是一个启动logical standby选项，如果要启用这条SQL必须关闭apply\n      [ALTER DATABASE STOP LOGICAL STANDBY APPLY]\n',3518,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3185,'查询logical standby gap 情况（在logical standby中查询）','--SQL> SELECT THREAD#, SEQUENCE#, FILE_NAME FROM DBA_LOGSTDBY_LOG L \n          WHERE NEXT_CHANGE# NOT IN (SELECT FIRST_CHANGE# \n                                         FROM DBA_LOGSTDBY_LOG WHERE L.THREAD# = THREAD#) \n          ORDER BY THREAD#, SEQUENCE#;\n--如果有的话用来注册到logical standby 中。\n--SQL> ALTER DATABASE REGISTER LOGFILE \'/physical_standby1/thread1_dest/arcr_1_7.arc\';\n',3519,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3186,'create a logical standby database','配置逻辑DG',3520,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3187,'create a physical standby database','配置物理DG',3520,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3188,'切换P->S(物理)','--',3520,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3189,'切换P->S(逻辑)','--',3520,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3190,'创建standby redo log file','--SQL> ALTER DATABASE ADD STANDBY LOGFILE (\'/oracle/dbs/slog3.rdo\') SIZE 500M;\n--当一个redo log增加到primary database中，同时也要加一个到standby database中。\n--否则primary switch log file之后standby 可能变成异步的。这样会引起零数据丢失失效，或者引起最大保护模式关闭。\n',3520,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3191,'创建standby redo log file thread（用于rac','--SQL> ALTER DATABASE ADD STANDBY LOGFILE THREAD 1 SIZE 500M;\n--SQL> ALTER DATABASE ADD STANDBY LOGFILE THREAD 2 SIZE 500M;\n',3520,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3192,'手动注册archivelog到DB中','--SQL> ALTER DATABASE REGISTER LOGFILE \'/physical_standby1/thread1_dest/arcr_1_7.arc\';',3520,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3193,'LOG_ARCHIVE_TRACE','--',3521,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3194,'log_archive_dest_state_n','--ENABLE/disable/ ALTERNATE	开启和关闭对应的log_archive_dest_n',3521,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3195,'db_unique_name','--',3521,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3196,'切换physical standby 为Real-time query\n（实时查询模式）','--SQL> SELECT open_mode FROM V$DATABASE;\n  --查询当前pyhsical当前模式。\n--SQL> ALTER DATABASE RECOVER MANAGED STANDBY DATABASE CANCEL;\n--SQL> ALTER DATABASE OPEN;\n--SQL> ALTER DATABASE RECOVER MANAGED STANDBY DATABASE USING CURRENT LOGFILE DISCONNECT;\n',3522,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3197,'Stopping physical standby Redo Apply','--SQL> ALTER DATABASE RECOVER MANAGED STANDBY DATABASE CANCEL;',3522,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3198,'强制real-time apply 同步到standby','--SQL> ALTER SESSION SYNC WITH PRIMARY;\n--需要在log_archive_dest_n中指定SYNC属性，不然会报ORA-3173。\n',3522,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3199,'建立触发器，自动执行同步','--CREATE TRIGGER adg_logon_sync_trigger\n AFTER LOGON ON user.schema\n  begin\n    if (SYS_CONTEXT(\'USERENV\', \'DATABASE_ROLE\')  IN (\'PHYSICAL STANDBY\')) then\n      execute immediate \'alter session sync with primary\';\n    end if;\n  end;\n--建立一个触发器来，当用户登录后，如果登录的是物理备库，那么执行\'alter session sync with primary\n',3522,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3200,'取消延迟应用redo log','--SQL> ALTER DATABASE RECOVER MANAGED STANDBY DATABASE NODELAY;',3522,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3201,'Start physical standby','--SQL> ALTER DATABASE RECOVER MANAGED STANDBY DATABASE; 前台启动(也就是当前窗口不能操作，冻结了)\n--SQL> ALTER DATABASE RECOVER MANAGED STANDBY DATABASE DISCONNECT;后台启动\n--SQL> ALTER DATABASE RECOVER MANAGED STANDBY DATABASE USING CURRENT LOGFILE;使用standby log file 来启动（real-time apply\n',3522,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3202,'STANDBY_MAX_DATA_DELAY','--SQL> ALTER SESSION SET STANDBY_MAX_DATA_DELAY=2\n--配置apply lag的允许落后数\n--这是一个可以在会话级别指定的参数(session parameter)，该参数指定了在Primary Database已commit提交的变化与standby Database数据库上涉及相关变化的查询之间所允许的时间延迟，单位为second 秒。\n--这个参数由非管理用户指定。\n--default value of NONE，如果指定这个值，那么standby 不管apply lag。\n--非零值，那么apply lag必须小于等于指定的值，如果超过，那么ORA3172错误。\n--如果值为0，那么保证和primary同步，除非落后于primary，那么ORA3172错误。\n',3523,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3203,'显示standby延迟应用apply的历史情况\n（standby）（直方图）	','--SQL> SELECT * FROM V$STANDBY_EVENT_HISTOGRAM WHERE NAME = \'apply lag\' AND COUNT > 0;\n--设定一个时间期间内的apply情况。\n',3524,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3204,'监视real-time查询中的apply 延迟\n（standby）\n','--SQL> SELECT  name, value, datum_time, time_computed FROM V$DATAGUARD_STATS WHERE name like \'apply lag\';\n--apply lag这个值是定期从primary收到数据\n--DATUM_TIME这个列包含最后被standby收到数据的时间戳。\n--TIME_COMPUTED这个列也是一个时间戳，他是apply lag背计算完成的时间戳。\n--这些列之间的差异应该小于30秒。如果大于30秒，那么apply可能不精确了。\n',3524,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3205,'查看保护级别','--SQL> select protection_level from v$database;',3525,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3206,'查看redo log file组和大小','--SQL> SELECT GROUP#, BYTES FROM V$LOG;',3525,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3207,'最近一次已归档的redo log file在各个归档目的地的状态\n(在源database执行)','--SQL> SELECT DESTINATION, STATUS, ARCHIVED_THREAD#, ARCHIVED_SEQ# \n       FROM V$ARCHIVE_DEST_STATUS  \n           WHERE STATUS <> \'DEFERRED\' AND STATUS <> \'INACTIVE\';\n--如果STATUS的状态不是VALID那么可能没有在standby完成归档。\n',3525,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3208,'在源DB查寻,与target DB对比\ntarget DB哪些archive redo log丢失\n(在源database执行)','--SQL> SELECT LOCAL.THREAD#, LOCAL.SEQUENCE#,NAME \n     FROM (SELECT THREAD#, SEQUENCE#,NAME FROM V$ARCHIVED_LOG WHERE DEST_ID=1) LOCAL \n     WHERE LOCAL.SEQUENCE# NOT IN \n         (SELECT SEQUENCE# FROM V$ARCHIVED_LOG WHERE DEST_ID=2 AND THREAD# = LOCAL.THREAD#);\n--这个查询需要修改DEST_ID=1源DB本地归档，DEST_ID=2目的DB归档。\n',3525,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3209,'查看standby redo log file 组和大小','--SQL> SELECT GROUP#, BYTES FROM V$STANDBY_LOG;',3525,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3210,'最近一次已归档的redo log file','--SQL> SELECT MAX(SEQUENCE#), THREAD# FROM V$ARCHIVED_LOG GROUP BY THREAD#;',3525,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3211,'查询sync在各个节点的同步的响应时间','--SQL> SELECT FREQUENCY, DURATION FROM  V$REDO_DEST_RESP_HISTOGRAM WHERE DEST_ID=2 AND FREQUENCY>1;\n--这个查询需要修改DEST_ID=2\n',3525,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3212,'在physical database查询archive redo log file gap','--SQL> SELECT * FROM V$ARCHIVE_GAP;\n--如果有的话进一步查询V$ARCHIVED_LOG\n--copy这些archive log file到pysical standby 来手动注册	\n--SQL> ALTER DATABASE REGISTER LOGFILE \'/physical_standby1/thread1_dest/arcr_1_7.arc\';',3525,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3213,'查询data guard等待事件','--SQL> select event from V$SYSTEM_EVENT where event like \'LNS%',3525,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3214,'查询database打开模式','--SQL> SELECT open_mode FROM V$DATABASE;',3525,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3215,'V$ARCHIVE_DEST','--',3526,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3216,'V$LOG','--',3526,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3217,'V$SYSTEM_EVENT','--',3526,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3218,'V$STANDBY_LOG','--',3526,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3219,'switch log file checkpoint','见文档',3527,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3220,'rba','--rba就是重做块地址,比如说,用户发出了一条update命令,更新了块A,块A现在变成了脏块,oracle会为他\n生成一条重做记录.这条重做记录在重做日志文件中的位置就是rba(redo block address)',3527,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3221,'control file','\"增加和减少控制文件\"',3528,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3222,'dbms_flashback.get_system_change_number','显示当前系统的scn号',3529,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3223,'startup','sql> startup [ MOUNT | NOMOUNT | RESTRICT | FORCE | OPEN RECOVER | read only ]\n    #start force #相当于shutdown abort+startup\n    #当前session不能在shared server下启动instance\n    #RESTRICT，只有RESTRICTED SESSION和CREATE SESSION权限才能登陆RESTRICT模式',3530,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3224,'alter database','sql> Alter database [db_name] { open [ read only | READ WRITE ] | mount | close };	\n    #mount进入open，* 可指定某个DB，也可以不指定\n    #RESETLOGS不能用在READ ONLY',3530,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3225,'restricted mode | 在open状态下修改','sql> ALTER SYSTEM [ {ENABLE|DISABLE} RESTRICTED SESSION ];	#open状态下进入和关闭restricted mode',3530,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3226,'pfile启动','sql> startup pfile = $oracle_home/dbs/initdba1.ora	#指定pfile来启动db',3530,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3227,'open read only','sql> alter database open [ read only | READ WRITE ];	#mount状态下打开只读模式\nsql> startup read only;',3530,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3228,'关闭数据库','sql> shutdown abort	        # 强行关闭数据库\nsql> shutdown immediate	        #关闭数据库触发checkpoint\nsql> shutdown transactional	#等待用户完成任务(commit/rollback)后断开\nsql> shutdown normal	        #等待用户连接断开后关闭DB\n#shared server链接是不能shutdown database的\n#Shutdown modes that wait for users to disconnect or for transactions to complete have a limit on the amount of time that they wait. If all events blocking the shutdown do not occur within one hour, the shutdown operation aborts with the following message: ORA-01013: user requested cancel of current operation. This message is also displayed if you interrupt the shutdown process, for example by pressing CTRL-C.',3530,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3229,'dismount','sql> alter database dismount;',3530,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3230,'静默模式','--ALTER SYSTEM { QUIESCE DATABASE | unquiesce };\n#这个模式只允许DBA操作，准确的说，只允许sys/system来操作，即使有dba角色的用户也不行。\n\n--alter system {quiesce restricted | UNQUIESCE}\n#ORA-25511: quiesce not supported for pluggable databases\n#ORA-25510: quiesce not supported for the root container\n',3530,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3231,'普通用户查看INSTANCE参数','见文档使用DBMS_UTILITY.GET_PARAMETER_VALUE',3531,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3232,'SPFILE设置','ALTER SYSTEM SET PARAMETER=VALUE <COMMENT=\'TEXT\'> <DEFERRED> <SCOPE=MEMORY|SPFILE|BOTH> <SID=\'SID|*\'>;\n#COMMENT=注释\n#scope=记录在spfile中还是memory还是这两个都记录\n#sid=可以指定sid，对于rac环境中*代表所有instance\n#deferred=某些参数需要这个设置这个参数，设置后，当前session不生效这个参数设置的值，之后的session生效.可以查看select name from v$parameter where issys_modifiable=\'DEFERRED\';',3531,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3233,'重置PARAMETER值','ALTER SYSTEM RESET PARAMETER <SCOPE=SPFILE|MEMORY|BOTH> SID=\'SID|*\';',3531,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3234,'SPFILE与PFILE相互转换','CREATE PFILE[=\'XXXX\'] FROM SPFILE[=\'XXXX\'];\nCREATE SPFILE[=\'XXXX\'] FROM PFILE[=\'XXXX\'];',3531,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3235,'从内存中创建SPFILE/PFILE','CREATE SPFILE FROM MEMORY;\nCREATE PFILE FROM MEMORY;',3531,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3236,'创建和转换参数文件','\"spfile转pfile，反之，instance参数启动顺序说明\"',3531,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3237,'口令文件的作用和位置',NULL,3532,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3238,'remote_login_passwordfile','--设置是否启动密码文件',3533,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3239,'SPFILE','设置spfile地址。例子:\nalert system set spfile=\'?/dbs/spfilesid.ora\'; #?是$ORACLE_HOME',3534,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3240,'instance_number','--设置instance号',3534,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3241,'instance启动选择parameter file过程',NULL,3535,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3242,'CONTROL_FILE_RECORD_KEEP_TIME','默认7天，设置为0表示控制文件内容不会被重用，控制文件无限增长。\n0为不做限制，可以无限增长。',3536,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3243,'CONTROL_FILES','指定控制文件的位置。',3536,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3244,'ARCHIVE_LAG_TARGET','这个参数强制一个log switch，在指定的时间。\n\nA 0 value disables the time-based thread advance feature; otherwise, the value represents the number of seconds. Values larger than 7200 seconds are not of much use in maintaining a reasonable lag in the standby database. The typical, or recommended value is 1800 (30 minutes). Extremely low values can result in frequent log switches, which could degrade performance; such values can also make the archiver process too busy to archive the continuously generated logs.',3537,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3245,'查看oracle当前进程相关信息','select addr,pid,spid,username,program from v$process;\naddr #进程地址/pid #oracle进程 id/spid #对应os的进程id号/username #进程的所属用户/program #进程名',3538,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3246,'查看当前进程等待的latch','select latchwait from v$process;',3538,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3247,'查看当前scn号-1','select dbms_flashback.get_system_change_number from dual;',3538,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3248,'查看当前scn号-2','select current_scn from v$database;',3538,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3249,'查看INSTANCE在ALERT LOG中记录的停机时间(包括崩溃)','查看停机时间,计算出的停机时间可能包括奔溃时间',3538,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3250,'查看oracle版本','linux>file $oracle_home/bin/oracle',3538,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3251,'查看instance状态','select status from v$instance;',3538,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3252,'查看哪些参数是之后登录SESSION生效','SELECT NAME FROM V$PARAMETER WHERE ISSYS_MODIFIABLE=\'DEFERRED\';',3539,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3253,'查看spfile文件上的参数值','select name,value from v$spparameter order by name;',3539,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3254,'查看instance内存中参数设置','select name,value from v$parameter order by name;',3539,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3255,'查看系统中所有的参数','select name,isinstance_modifiable from v$parameter;\n除此之外，还显示他们是否可以在，rac中的每个instance中，设置独立的参数值。',3539,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3256,'查看最近24小时中每小时的redo生成量','SELECT snap_id,\n	begin_TIME,end_TIME,\n	round(VALUE/1024/1024-(select value/1024/1024 \n							from dba_hist_sysstat \n							where snap_id=x.snap_id-1 and stat_name=\'redo size\')\n	,0)||\' MB\' redo_log_mb \nFROM (\n    select stat.\n        value,\n		to_char(snp.BEGIN_INTERVAL_TIME,\'YYYY-MM-DD HH24:MI\') begin_TIME,\n		to_char(snp.end_INTERVAL_TIME,\'YYYY-MM-DD HH24:MI\') end_TIME,\n        snp.snap_id\n    from dba_hist_sysstat stat,dba_hist_snapshot snp  \n    where stat_name=\'redo size\' and snp.snap_id=stat.snap_id \n    ORDER BY stat.SNAP_ID DESC\n) x  WHERE ROWNUM<24;\n--修改rownum可以增大或缩小小时数',3540,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3257,'查看redo file之间切换花费的时间(秒)','select b.recid,\n    to_char(b.first_time,\'dd-mm-yyyy hh24:mi:ss\') start_time,\n    a.recid,\n    to_char(a.first_time,\'dd-mm-yyyy hh24:mi:ss\') end_time,\n    round(((a.first_time-b.first_time)*25)*60,2) min \nfrom v$log_history a,v$log_history b where a.recid=b.recid+1 order by a.first_time asc;\n',3541,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3258,'查看redo log file信息','select a.member,b.*\nfrom v$logfile a,v$log b\nwhere a.group# = b.group#;',3541,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3259,'sysresv','管理oracle内存共享段,可以查看，和移除oracle内存共享段',3542,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3260,'DBMS_MONITOR.SESSION_TRACE_ENABLE','开启针对SESSION的跟踪',3543,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3261,'DBMS_MONITOR.SQL_TRACE','开启SQL TRACE',3543,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3262,'对跟踪文件标记','PARAMETER :  TRACEFILE_IDENTIFER',3544,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3263,'BACKGROUND_DUMP_DEST',NULL,3545,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3264,'USER_DUMP_DEST',NULL,3545,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3265,'_TRACE_FILES_PUBIC','设置是否所有用户都可以查看TRACE FILE\nTRUE/FALSE',3545,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3266,'TRACEFILE_IDENTIFER','对跟踪文件做标记',3545,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3267,'DIAGNOSTIC_DEST','设置TRACE的根目录',3545,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3268,'开启SESSION TRACE','ALTER SESSION SET EVENTS \'10046 TRACE NAME CONTEXT FOREVER ,LEVEL 12\';\n   或\ndoc 1612',3545,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3269,'DIAGNOSTIC_DEST','--',3545,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3270,'MAX_DUMP_FILE_SIZE','MAX_DUMP_FILE_SIZE Setting Trace File Segmentation \nUNLIMITED\nTrace files are not segmented.\n \nLarger than 15M\nTrace files are segmented on a boundary that is 1/5 of the MAX_DUMP_FILE_SIZE setting. Trace files with sizes that are less than this boundary in size are not segmented. For example, if the MAX_DUMP_FILE_SIZE setting is 100M, then the boundary is 20 MB (1/5 of 100 MB).\n \n15M or less\nTrace files are not segmented.\n',3545,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3271,'_TRANCE_FILES_PUBLIC','--是否允许所有人读取跟踪文件。',3545,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3272,'V$DIAG_INFO','查看TRACE FILE的结构.',3546,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3273,'v$parameter','查看instance内存中参数设置',3547,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3274,'v$spparameter','查看spfile文件中参数设置',3547,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3275,'v$controlfile_record_section','控制文件包含的内容',3548,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3276,'v$controlfile','列出当前instance里面control file 所有的信息',3548,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3277,'V$LOG',NULL,3549,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3278,'v$log_history','v$log_history displays log history information from the control file.',3549,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3279,'V$LOGFILE',NULL,3549,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3280,'RAISE_APPLICATION_ERROR','--自定义错误',3550,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3281,'exception | 定义异常变量','--declare\n	table_or_view_does_not_exist exception;--定义一个异常\n	pragma exception_init(table_or_view_does_not_exist,-942);\n        --捕获一个表不存在的错误，表不存在的错误就ORA-00942\nbegin\n   xxx\nend;\n/',3551,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3282,'自制事务--示例',NULL,3552,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3283,'锁定指定行,然后处理,并且需要多用户(并发进行)','目的:多个用户并发的查找第一个未锁定,未处理的记录(这里的未处理，指的是下面创建的表中processed_flag列为\'n\'值的记录,具体怎么才算是未处理可以根据实际情况来制定)，然后锁定，并处理这条记录。',3552,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3284,'skip locked','11g新个性，使用发发见doc-1568-方法二',3552,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3285,'pipelined','\"管道函数\"',3552,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3286,'example','--',3552,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3287,'SQL%ROWCOUNT','--上文中处理的sql数量',3553,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3288,'SQLERRM','--错误信息',3553,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3289,'%NOTFOUND','--',3553,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3290,'定义异常','--pragma exception_init(a,-942);',3554,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3291,'抛出异常','--Raise',3554,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3292,'pragma autonomous_transaction;','--自制事务\n',3555,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3293,'plsql_optimize_level','--',3556,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3294,'SERIALLY_REUSABLE','--禁止使用上下文。\n--在package中定义的变量，在package中的各个过程或函数中，没有关联，每次调用旗下的过程或函数，使用使用package中的默认值或null。',3557,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3295,'查看某个schema下的包','--select name from ALL_SOURCE where owner=\'FASTQ\' group by name;',3558,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3296,'查看不属于系统用户下用户的plsql包','--COl text for a100\nselect owner,text from ALL_SOURCE where owner not in (\'SYS\',\'APEX_030200\',\'SYSMAN\',\'MDSYS\',\'EXFSYS\',\'CTXSYS\',\'APSTSTAT\');',3558,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3297,'创建function','--create or replace function abc_fun (abc in int) \nreturn pls_integer\nas\nbegin\n	return abc;\nend;\n/\n\n--exec dbms_output.put_line(abc_fun(1));',3559,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3298,'ALL_SOURCE','--ALL_SOURCE describes the text source of the stored objects accessible to the current user.\n\nRelated Views\n\nDBA_SOURCE describes the text source of all stored objects in the database.\n\nUSER_SOURCE describes the text source of the stored objects owned by the current user. This view does not display the OWNER column.\n--可以查看plsql包源码',3560,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3299,'停止trigger','--ALTER TIGGER trigger_name [DISABLE | ENABLE ];\nALTER TABLE [schema.]table_name {ENABLE|DISABLE} ALL TRIGGERS;',3561,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3300,'语法','--CREATE [OR REPLACE] TRIGGER trigger_name\n{BEFORE | AFTER }\n{INSERT | DELETE | UPDATE [OF column [, column …]]}\n[OR {INSERT | DELETE | UPDATE [OF column [, column …]]}...]\nON [schema.]table_name | [schema.]view_name \n[REFERENCING {OLD [AS] old | NEW [AS] new| PARENT as parent}]\n[FOR EACH ROW ]\n[WHEN condition]\nPL/SQL_BLOCK | CALL procedure_name;',3561,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3301,'查看data file的物理读/写次数，物理读/写时间','select name,phyrds,phywrts,readtim,writetim from v$filestat a ,v$datafile b where a.file#=b.file# order by readtim desc;',3562,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3302,'file的寻道时间','select FILE#,round(SINGLEBLKRDTIM/SINGLEBLKRDS,1) from v$filestat;',3562,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3303,'V$FILESTAT','V$FILESTAT displays the number of physical reads and writes done and the total number of single-block and multiblock I/Os done at file level. As of Oracle Database 10g Release 2 (10.2), this view also includes reads done by RMAN processes for backup operations.',3563,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3304,'基于event调度','--',3564,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3305,'中断job','--exec dbms_ijob.broken(5,true);',3565,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3306,'移除job','--dbms_ijob.remove(70);',3565,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3307,'执行job','--exec dbms_job.run(5);',3565,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3308,'修改job(interval date)','--exec dbms_job.interval(5,\'sysdate+2\');',3565,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3309,'修改job(next_date)','--exec dbms_job.next_date(5,sysdate+1/24);',3565,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3310,'job_queue_processes','--',3566,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3311,'查看某个schema的job','--set line 180\ncol interval for a30\ncol what for a50\nselect job,SCHEMA_USER,WHAT,TO_CHAR(LAST_DATE,\'yyyy-mm-dd hh24:mi:ss\') LAST_DATE,TO_CHAR(NEXT_DATE,\'yyyy-mm-dd hh24:mi:ss\') NEXT_DATE,INTERVAL ,NEXT_SEC from dba_jobs where schema_user=\'FASTQ\' ORDER BY 3;\n',3567,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3312,'dbms_ijob','--这个DBMS是让sys用户执行其他用户的job操作。',3568,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3313,'DBMS_SCHEDULER.STOP_JOB','--关闭正在执行的job',3569,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3314,'dbms_scheduler.create_job','exec dbms_scheduler.create_job(\njob_name =>\'OTA_TOT_CN_02_JOB\',\njob_type=>\'STORED_PROCEDURE\',\njob_action=>\'OTA_TOT_CN_02_PRO\',\nstart_date=>sysdate,\nrepeat_interval=>\'FREQ=HOURLY;INTERVAL=1\');',3569,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3315,'dbms_scheduler.disable','--停止job\n--dbms_scheduler.disable(\'OTA_TOT_CN_02_JOB\');\n',3569,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3316,'DBMS_SCHEDULER.DROP_JOB','--',3569,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3317,'dbms_scheduler.enable','--dbms_scheduler.enable(\'user_day_access_date_job\')',3569,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3318,'执行带参数的job','--默认情况下存储过程在job中不能带参数。',3570,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3319,'create job','--',3571,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3320,'每小时的每隔五分钟执行一次','--FREQ=HOURLY;INTERVAL=1;byminute=0,5,15,25,30,35,40,45,50,55\'',3572,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3321,'运行状况','--col next_run_date for a40\ncol last_start_date for a40\ncol job_action for a40\nselect job_name,JOB_ACTION,RUN_COUNT,FAILURE_COUNT,LAST_START_DATE,NEXT_RUN_DATE from ALL_SCHEDULER_JOBS;',3573,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3322,'DBA_SCHEDULER_WINDOWS','查看时间窗口',3574,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3323,'DBA_SCHEDULER_WINGROUP_MEMBERS','查看窗口组成员',3574,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3324,'DBA_AUTOTASK_SCHEDULE','DISPLAYS THE SCHEDULE OF MAINTENANCE WINDOWS FOR THE NEXT 32 DAYS FOR EACH CLIENT.\n查看接下来32天的维护窗口的时间安排',3574,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3325,'ALL_SCHEDULER_JOBS','--查看job的定义\n--DBA_SCHEDULER_JOBS 显示DB中所有的job。\n--USER_SCHEDULER_JOBS  显示user下的job，所以这个视图没有owner字段',3574,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3326,'ALL_SCHEDULER_JOB_RUN_DETAILS','--ALL_SCHEDULER_JOB_RUN_DETAILS displays log run details for the Scheduler jobs accessible to the current user.\n\nRelated Views\n\n•DBA_SCHEDULER_JOB_RUN_DETAILS displays log run details for all Scheduler jobs in the database.\n\n•USER_SCHEDULER_JOB_RUN_DETAILS displays log run details for the Scheduler jobs owned by the current user.\n',3574,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3327,'ALL_SCHEDULER_JOB_LOG','--ALL_SCHEDULER_JOB_LOG displays log information for the Scheduler jobs accessible to the current user.\n\nRelated Views\n\n•DBA_SCHEDULER_JOB_LOG displays log information for all Scheduler jobs in the database.\n\n•USER_SCHEDULER_JOB_LOG displays log information for the Scheduler jobs owned by the current user.\n',3574,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3328,'*_scheduler_programs','--',3574,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3329,'user_scheduler_chain_rules','--',3574,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3330,'user_scheduler_chain_steps','--',3574,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3331,'*_scheduler_running_Jobs','--',3574,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3332,'user_scheduler_schedules','--',3574,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3333,'user_scheduler_chins','--',3574,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3334,'user_scheduler_running_chains','--',3574,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3335,'通过job查看program','--select owner,JOB_NAME,PROGRAM_NAME from ALL_SCHEDULER_JOBS where job_name=\'JOB_AUDITAPPST\';',3575,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3336,'查看当前job的运行记录/执行时间等等','--select job_name,status,log_date,error#,run_duration from user_scheduler_job_run_details;',3575,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3337,'V$MEMORY_TARGET_ADVICE','V$MEMORY_TARGET_ADVICE provides information about how the MEMORY_TARGET parameter should be sized based on current sizing and satisfaction metrics.',3576,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3338,'V$IOSTAT_CONSUMER_GROUP','消费组的I/O统计',3577,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3339,'V$IOStat_FILE','db DATA FILE的I/O统计',3577,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3340,'V$IOSTAT_FUNCTION','数据库功能的I/O统计 例如LGWR和dbwr',3577,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3341,'V$IOSTAT','单块读写和多块读写的操作',3577,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3342,'V$PARAMETER','此参数显示的信息关于，当前session所生效的parameter.\n新的session所继承的参数值，从v$system_parameter view来看。',3578,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3343,'gv$sort_segment','使用这个试图来查看当前和最大排序segment的统计信息',3579,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3344,'gv$tempseg_usage','使用这个视图来查看临时段的详细使用信息，如用户名，sql等.',3579,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3345,'V$TEMPFILE','显示temp file的信息',3579,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3346,'v$services','V$SERVICES displays information about the services in the database.',3580,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3347,'V$SERVICE_STATS','V$SERVICE_STATS displays a minimal set of performance statistics. These call rate statistics are used for making run-time routing decisions, for tracking service levels, and for per-instance diagnostics per call rate. The elapsed timing for each call provides a relative value across instances for how well a node is processing SQL calls issued under a service name.\n显示性能统计的最小集合。这里的信息统计比率，用于运行期间的路由判定，跟踪service level，并且每个instance诊断每个call率。\n\nWhen aggregation is enabled for the Service Name, then this view provides the timing and work done for calls issued for the whole service.',3580,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3348,'V$SERVICEMETRIC','V$SERVICEMETRIC displays metric values measured on the most recent time interval period for services executing inside the database. Service metrics are measured in 5-second and 1-minute intervals.',3580,'2016-04-06 23:27:48','2016-04-06 23:27:48',NULL),(3349,'V$LOG','显示从control file中的log file信息',3581,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3350,'V$LOGFILE','关于redo log的信息',3581,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3351,'查看Oracle当前版本中所有的动态性能视图','select * from v$fixed_table;\n--这个查询包括V$/X$/GV$',3582,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3352,'查询系统中V$/GV$视图的定义(组成视图的sql语句)','select * from v$fixed_view_definition;',3582,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3353,'查询系统中DD的定义(组成dd的sql语句)','select text from dba_views where view_name=\'DBA_IND_PARTITIONS\';',3582,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3354,'V$WAITSTAT',NULL,3583,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3355,'v$session','V$SESSION displays session information for each current session\nFootnote 1 The P1RAW, P2RAW, and P3RAW columns display the same values as the P1, P2, and P3 columns, except that the numbers are displayed in hexadecimal.\n显示当前连接的session，以及这个session正在等待的event',3583,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3356,'V$PROCESS','V$PROCESS displays information about the currently active processes.',3583,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3357,'V$SQL_PLAN_STATISTICS_ALL','V$SQL_PLAN_STATISTICS_ALL contains memory usage statistics for row sources that use SQL memory (sort or hash-join). This view concatenates information in V$SQL_PLAN with execution statistics from V$SQL_PLAN_STATISTICS and V$SQL_WORKAREA.',3584,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3358,'v$sql','V$SQL lists statistics on shared SQL areas without the GROUP BY clause and contains one row for each child of the original SQL text entered. Statistics displayed in V$SQL are normally updated at the end of query execution. However, for long running queries, they are updated every 5 seconds. This makes it easy to see the impact of long running SQL statements while they are still in progress.',3584,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3359,'V$SORT_SEGMENT','V$SORT_SEGMENT displays information about every sort segment in a given instance. The view is only updated when the tablespace is of the TEMPORARY type.',3585,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3360,'V$TRANSACTION','系统中所有活跃的transaction/事务',3586,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3361,'v$lock','V$LOCK lists the locks currently held by the Oracle Database and outstanding requests for a lock or latch.\nV$LOCK 列出当前oracle DB 和\'未完成的请求\'所持有的锁，这所可能是lock或latch\n文档内是锁的类型.',3586,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3362,'V$SEGMENT','V$SEGMENT_STATISTICS displays information about segment-level statistics.\n显示信息关于segment-level统计./关于segment的统计信息/统计segment的event',3587,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3363,'data pump缺省目录','--DIRECTORY_NAME：\n    DATA_PUMP_DIR \n--DIRECTORY_NAME\n    /u01/app/admin/goku/dpdump/\n--Oracle给data pump在DB中创建了缺省的目录，可以直接使用，而不用在expdp或impdp指定目录',3588,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3364,'expdp对sequence的影响','--1.执行expdp时，已经被cache的sequence是不会被导出的。意思是，当前nextval=10，cache设置的是20，那么导出的sequence是从30开始的，不过，被expdp的DB也会从30开始，cache的值都被抛弃。',3588,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3365,'expdp | [query]','--用于指定过滤导出数据的where条件.语法如下:\n--配合[table]参数可以一起使用\n--QUERY=[schema.][table_name:]query_clause\n--schema 用于指定方案名,table_name用于指定表名,\n  query_clause用于指定条件限制子句.\n  QUERY选项不能 与 CONNECT=METADATA_ONLY,EXTIMATE_ONLY,TRANSPORT_TABLESPACES等选项同时使用,示例如下:\n--expdp scott/tiger directory=dump dumpfiel=a.dmp Tables=emp query=\'WHERE deptno=20\'\n--例子\n--expdp scott/tigger full=y query=ota.TBLOTACLIENTINFO:\"\n                                       where updatedate>=trunc(sysdate)\",\n                                   ota.TBLDOWNUPDATELOG:\"\n                                       where createdate>=trunc(sysdate)\",\n                                   ota.TBLOTACLIENTINFO_OLD:\"\n                                       where updatedate>=trunc(sysdate)\",\n                                   ota.TBLDOWNUPDATELOG_OLD:\"\n                                       where createdate>=trunc(sysdate)\"  ',3589,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3366,'expdp | [logfile]','--expdp test/test schemas=TEST,hr directory=TEST_DIR dumpfile=TEST.dmp logfile=expdpTEST.log;',3589,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3367,'expdp | [parfile]','--可以把命令写在parfile参数指定的文件中，来执行，相当于脚本\n--例子:\n--expdp parfile=/home/oracle/expdp_script/back_dump.par',3589,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3368,'expdp | [full]','--指定数据库模式导出,默认为N.语法如下:\n--FULL={Y | N}\n--为Y时,标识执行数据库导出.\n',3589,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3369,'expdp | [reuse_dumpfiles]','--覆盖具有相同dump名的文件，如果在导出时转储文件已经存在，使用REUSE_DUMPFILES参数可以预防错误发生。\n--REUSE_DUMPFILES={Y | N}\n  设置为“Y”时，现在的转储文件将被覆盖，当使用默认值“N”时，如果转储文件已经存在就会产生一个错误。\n--例子\n  expdp test/test schemas=TEST directory=TEST_DIR dumpfile=TEST.dmp logfile=expdpTEST.log reuse_dumpfiles=y',3589,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3370,'expdp | [EXCLUDE]','--排除表employees\n    EXCLUDE=TABLE:\"in(\'employees\')\"',3589,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3371,'expdp | [DIRECTORY]','--指定目录',3589,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3372,'expdp | [TABLES]','--到处指定的表\n  expdp  DUMPFILE=expfull.dmp  userid=HR/hr reuse_dumpfiles=y DIRECTORY=DATA_PUMP_DIR TABLES=employees,abc',3589,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3373,'expdp | [include]','--只导出存储过程\n   include=PROCEDURE;   ',3589,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3374,'expdp | [SCHEMAS]','--指定导出的schemas\n    expdp test/test schemas=TEST,hr directory=TEST_DIR dumpfile=TEST.dmp logfile=expdpTEST.log;\n    --可以指定一个或多个schemas',3589,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3375,'expdp | [tablespaces]','----按TS导出\n--expdp userid=hr/hr directory=xxx dumpfile=expdp.dmp tablespaces=temp,example;',3589,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3376,'expdp | [CONTENT]','--该选项用于指定要导出的内容.默认值为ALL\n--CONTENT={ALL | DATA_ONLY | METADATA_ONLY}\n--当设置CONTENT为ALL时,将导出对象定义及其所有数据.为DATA_ONLY时,只导出对象数据,为METADATA_ONLY时,只导出对象定义\n--Expdp scott/tiger DIRECTORY=dump DUMPFILE=a.dump CONTENT=METADATA_ONLY',3589,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3377,'expdp | [PARALLEL]','--?1?��??',3589,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3378,'impdp | [REMAP_SCHEMA]','--该选项用于将源方案的所有对象装载到target schema中.\n--REMAP_SCHEMA=source_schema:target_schema\n--impdp userid=system/oracle SCHEMAS=iii REMAP_SCHEMA=iii:uuuii\n--这个参数被指定时，只会导入taret_schema的用户,不会导入iii用户，并且DB中可以不用是新创建uuuii用户，impdp会自动创建，执行完毕后只要修改密码即可.\n--此外加入了schemas选项后，不管dmp文件是不是整个数据库导出dmp，导致会使用iii来导入，同时，指定了remap_schema，iii不会被导入，而是导入了uuuii\n',3590,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3379,'impdp | [SCHEMAS]','----按schema导入（可以将用户信息直接导入，即如果用户信息不存在的情况下也可以直接导入）\n--impdp gwm/gwm@fgisdb schemas=gwm dumpfile =expdp_test.dmp logfile=expdp_test.log directory=dir_dp',3590,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3380,'impdp | [table_exists_action]','--对于导入表的4个选项\n    1.skip：导入作业会跳过已存在表处理下一个对象;\n    2.replace：先drop表，然后创建表，最后插入数据\n    3.append：在原来数据的基础上增加数据\n    4.truncate：先truncate，然后再插入数据',3590,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3381,'impdp | [PARALLEL]','--并行',3590,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3382,'impdp | [EXCLUDE]','--排除dmp中的某些对象，可以是table或index，或者是具体的对象object_type:\"in(\'object_name\')\"\n--impdp ex/ex@ota EXCLUDE=index,table:\"IN(\'ABC\')\" DIRECTORY=ex_dir dumpfile=ex.dmp\n--Exclude specific object types.\n    For example, EXCLUDE=SCHEMA:\"=\'HR\'\".\n注意:shell下执行impdp双引号和单引号需要转义，除非进入impdp的命令行，或者把命令保存到impdp的参数文件中执行。\n    impdp ex/ex@ota EXCLUDE=TABLE:\\\"=\\\'ABC\\\'\\\" DIRECTORY=ex_dir dumpfile=ex.dmp\n',3590,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3383,'impdp | [include]','--这个在impdp好像没有作用，比如:dmp中有一个index和table，但是include=table，index也会被导入进去。',3590,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3384,'impdp | [remap_tablespace]','--导入时，转换存放的表空间\n--impdp ex/ex remap_tablespace=users:users2[,ts_name:ts_name] DIRECTORY=ex_dir dumpfile=ex.dmp\n',3590,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3385,'查看目录','--select * from dba_directories;',3591,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3386,'创建目录','--create directory dir_dp as \'D:/oracle/dir_dp\';',3592,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3387,'dba_directories','--',3593,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3388,'使用sqlldr来创建外部表创建语句','\"包含简单的语法解释\"',3594,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3389,'外部表操作','\"多数据文件加载/只加载符合的数据\"',3594,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3390,'外部表语法图','\"未完\"',3594,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3391,'使用外部表卸载数据,并且移植到另一台oracle',NULL,3594,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3392,'plsql加载lob数据','\"使用方法，和字符集转换包\"',3595,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3393,'普通插入','\"大致流程\"',3596,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3394,'测试sqlldr中exceeds maximum length','\"重演和解决\"',3596,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3395,'测试加载定界数据','\"使用某个符号来划分数据(划分列与列)\"',3596,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3396,'sql-load控制文件语法','\"语法图\"',3596,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3397,'测试定界数据--制表符X\'09\'和WHITESPACE区别','\"测试两个制表符的区别\"',3596,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3398,'关键字filler测试','\"忽略数据中的某列的数据\"',3596,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3399,'测试加载固定格式数据','\"关键字position/char/*/偏移量/:的作用\"',3596,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3400,'加载日期','\"date关键字使用\"',3596,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3401,'使用函数加载','\"这里演示upper/连接符||/case函数\"',3596,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3402,'加载有换行符的数据','\"有4种方法和注意事项\"',3596,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3403,'加载内联的lob数据','\"lob数据在数据文件中。\"',3596,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3404,'加载外联的lob数据','\"lob数据是单独存放在文件中\"',3596,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3405,'sqlldr命令参数','\"解释\"',3596,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3406,'orapwd','\"创建密码文件/参数/操作说明\"',3597,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3407,'db link','\"数据库链接/创建/基本使用方法\"',3598,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3408,'listener命令','\"listener参数解释\"',3599,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3409,'1','--1',3600,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3410,'asm基本概念','主要详细解释: \n1.au和extent是什么,以及他们的关系 \n2.asm条带，细粒度和粗粒度的区别。',3601,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3411,'asm权限和OS组的关系','sysasm\nsysoper\n等等',3601,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3412,'asm file type/alias/template/','asm file type  alias  template',3601,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3413,'DBMS_FILE_TRANSFER.COPY_FILE','从asm中拷贝文件到本地system file',3602,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3414,'disk group/create/alter/属性/','\"操作说明\"',3603,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3415,'asmcmd','\"参数说明\"',3603,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3416,'advm','\"创建/设置相关\"',3603,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3417,'acfs和advm与linux版本兼容表','\"某些linux版本不能使用advm和acfs\"',3603,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3418,'oracleasm','\"配置asm环境/创建asm磁盘/初始化asm配置\"',3603,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3419,'asmca',NULL,3603,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3420,'mount/dismount disk group','alter diskgroup mount/Dismount;',3603,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3421,'manage instance','startup asm instance / shutdown asm instance / instance 密码文件 password',3603,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3422,'常用查询',NULL,3603,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3423,'BACKGROUND_DUMP_DEST',NULL,3604,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3424,'ASM_DISKSTRING','Note:\nThis parameter may only be specified in an Oracle Automatic Storage Management (Oracle ASM) instance.\n\nASM_DISKSTRING specifies an operating system-dependent value used by Oracle ASM to limit the set of disks considered for discovery. When a new disk is added to a disk group, each Oracle ASM instance that has the disk group mounted must be able to discover the new disk using the value of ASM_DISKSTRING.\n\nIn most cases, the default value will be sufficient. Using a more restrictive value may reduce the time required for Oracle ASM to perform discovery, and thus improve disk group mount time or the time for adding a disk to a disk group. A \"?\" at the beginning of the string gets expanded to the Oracle home directory. Depending on the operating system, wildcard characters can be used. It may be necessary to dynamically change ASM_DISKSTRING before adding a disk so that the new disk will be discovered.\n\nAn attempt to dynamically modify ASM_DISKSTRING will be rejected and the old value retained if the new value cannot be used to discover a disk that is in a disk group that is already mounted.',3604,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3425,'ASM_DISKSTRING','note:这个参数只能指定在asm instance中。\n\nasm_diskstring指定一个依赖OS的值，这个值让asm发现asm disk所在的位置。当一个新的asm disk增加到disk group，每个oracle asm instance 必须能够从asm_disstring来发现新的asm disk.\n\n A \"?\" at the beginning of the string gets expanded to the Oracle home directory. Depending on the operating system, wildcard characters can be used. It may be necessary to dynamically change ASM_DISKSTRING before adding a disk so that the new disk will be discovered.\n大多数情况下，这个参数的默认值将足够。使用一个明确的值(也就是目录),可以减少disk group mount的时间，已经寻找disk的时间。可以使用问号\'?\'通配符，他放在值的开头。\n\n动态的修改这个参数，如果在新值下找不到已经被mount的disk那么将失败，继续使用旧的值。',3604,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3426,'ASM_POWER_LIMIT','从11.2.0.2开始，如果COMPATIBLE.ASM disk group属性设置为11.2.0.2或更高，那么这个值的范围是0 ~ 1024.\n\nnote:这个参数只能指定在asm instance中。\n\nASM_POWER_LIMIT 指定最大pwer在一个ASM instance对于disk 再平衡。值越高，再平衡完成的速度越快，值越低，完成再平衡的时间越长，但是消耗较少的处理和I/O资源。\n\n如果power在asm相关操作中没有明确指定，那么这个参数的值，作为这些操作的默认值。',3604,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3427,'INSTANCE_TYPE','instance_TYPe指定一个instance的类型，database instance/asm instance/asm proxy instance\n\nValues:\n1.RDBMS:The instance is a database instance.\n2.ASM:The instance is an Oracle ASM instance.\n3.ASMPROXY:The instance is an Oracle ASM proxy instance.',3604,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3428,'MEMORY_TARGET','MEMORY_TARGET specifies the Oracle systemwide usable memory. The database tunes memory to the MEMORY_TARGET value, reducing or enlarging the SGA and PGA as needed.\n\nMEMORY_TARGET should be set higher than or equal to the sum of the current sizes of the SGA and PGA.\n\nIn a text-based initialization parameter file, if you omit MEMORY_MAX_TARGET and include a value for MEMORY_TARGET, then the database automatically sets MEMORY_MAX_TARGET to the value of MEMORY_TARGET. If you omit the line for MEMORY_TARGET and include a value for MEMORY_MAX_TARGET, the MEMORY_TARGET parameter defaults to zero. After startup, you can then dynamically change MEMORY_TARGET to a nonzero value, provided that it does not exceed the value of MEMORY_MAX_TARGET.\n\nTotal memory usage can grow beyond the value of MEMORY_TARGET. For example, memory is allocated to PL/SQL tables and varrays regardless of the value of MEMORY_TARGET as long as memory is available at the operating system level.\n\nIn the Default value field, IMMEDIATE mode autotuning requests are necessary to avoid ORA-04031 errors. The DEFERRED and IMMEDIATE modes are reflected in the OPER_MODE column of the V$MEMORY_RESIZE_OPS view.',3604,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3429,'MEMORY_MAX_TARGET','MEMORY_MAX_TARGET specifies the maximum value to which a DBA can set the MEMORY_TARGET initialization parameter. See the description of MEMORY_TARGET for more information about how the settings of MEMORY_MAX_TARGET and MEMORY_TARGET affect each other.\n\nSee Also:\nOracle Database Administrator\'s Guide for more information about managing memory',3604,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3430,'ASM_DISKGROUPS','note:这个参数只能指定在asm instance中。\n\n这个参数指定一个disk group name 列表，当执行alter diskgroup all mount 语句时，可以被mount上的.asm instance启动时执行alter diskgroup all mount.\n\nasm 自动增加一个disk group到这个参数值中，当，disk group完成创建或被mount,并且自动的remove 一个disk group 从这个参数中，档disk group 被drop或dismount.\n\nIssuing the ALTER DISKGROUP...ALL MOUNT or ALTER DISKGROUP...ALL DISMOUNT command does not 影响 the value of this parameter.\n\nSupporting Up to 511 Disk Groups for an Oracle ASM Instance\n\nIn Oracle Database 12c, Oracle ASM supports up to 511 disk groups for an Oracle ASM instance.',3604,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3431,'DB_CACHE_SIZE','DB_CACHE_SIZE specifies the size of the DEFAULT buffer pool for buffers with the primary block size (the block size defined by the DB_BLOCK_SIZE initialization parameter).\n\nThe value must be at least 4M * number of cpus (smaller values are automatically rounded up to this value). A user-specified value larger than this is rounded up to the nearest granule size. A value of zero is illegal because it is needed for the DEFAULT memory pool of the primary block size, which is the block size for the SYSTEM tablespace.\n\nSee Also:\nOracle Database Performance Tuning Guide and Oracle Database Administrator\'s Guide for more information on setting this parameter',3604,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3432,'DIAGNOSTIC_DEST','As of Oracle Database 11g Release 1 (11.1), the diagnostics for each database instance are located in a dedicated directory, which can be specified through the DIAGNOSTIC_DEST initialization parameter. The structure of the directory specified by DIAGNOSTIC_DEST is as follows:\n\n<diagnostic_dest>/diag/rdbms/<dbname>/<instname>\nThis location is known as the Automatic Diagnostic Repository (ADR) Home. For example, if the database name is proddb and the instance name is proddb1, the ADR home directory would be <diagnostic_dest>/diag/rdbms/proddb/proddb1.\n\nThe following files are located under the ADR home directory:\n\nTrace files - located in subdirectory <adr-home>/trace\n\nAlert logs - located in subdirectory <adr-home>/alert. In addition, the alert.log file is now in XML format, which conforms to the Oracle ARB logging standard.\n\nCore files - located in the subdirectory <adr-home>/cdumd\n\nIncident files - the occurrence of each serious error (for example, ORA-600, ORA-1578, ORA-7445) causes an incident to be created. Each incident is assigned an ID and dumping for each incident (error stack, call stack, block dumps, and so on) is stored in its own file, separated from process trace files. Incident dump files are located in <adr-home>/incident/<incdir#>. You can find the incident dump file location inside the process trace file.',3604,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3433,'LARGE_POOL_SIZE','LARGE_POOL_SIZE specifies (in bytes) the size of the large pool allocation heap. The large pool allocation heap is used in shared server systems for session memory, by parallel execution for message buffers, and by backup processes for disk I/O buffers. Parallel execution allocates buffers out of the large pool only when SGA_TARGET is set.\n\nCaution:\nWhen Oracle derives a default value, it adds 250K for each session for the shared server if DISPATCHERS is configured. The final derived value also includes a port-specific amount of memory for backup I/O buffers. The total derived default value can either be too large to allocate or can cause performance problems. In that case, set LARGE_POOL_SIZE to a number sufficiently small so that the database can start.\nYou can specify the value of this parameter using a number, optionally followed by K or M to specify kilobytes or megabytes, respectively. If you do not specify K or M, then the number is taken as bytes.\n\nSee Also:\nOracle Database Performance Tuning Guide for more information on setting this parameter',3604,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3434,'PROCESSES','PROCESSES specifies the maximum number of operating system user processes that can simultaneously connect to Oracle. Its value should allow for all background processes such as locks, job queue processes, and parallel execution processes.\n\nThe default values of the SESSIONS and TRANSACTIONS parameters are derived from this parameter. Therefore, if you change the value of PROCESSES, you should evaluate whether to adjust the values of those derived parameters.\n\nSee Also:\nYour operating system-specific Oracle documentation for the range of values',3604,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3435,'REMOTE_LOGIN_PASSWORDFILE','REMOTE_LOGIN_PASSWORDFILE specifies whether Oracle checks for a password file.\n\nValues:\n\nshared\n\nOne or more databases can use the password file. The password file can contain SYS and non-SYS users.\n\nWhen REMOTE_LOGIN_PASSWORDFILE is set to shared:\n\nThe SYS password cannot be changed. If you try, the password change ooperation fails with \"ORA-28046: Password change for SYS disallowed.\"\n\nThe password of any user who has SYS* admin privileges (SYSDBA, SYSOPER, SYSASM, SYSBACKUP, SYSDG, SYSKM) cannot be changed. If you try, the password change operation fails with \"ORA-01999: password file cannot be updated in SHARED mode.\"\n\nGrants of SYS* admin privileges (SYSDBA, SYSOPER, SYSASM, SYSBACKUP, SYSDG, SYSKM) to individual users are not allowed. For example, grant sysdba to scott fails with \"ORA-01999: password file cannot be updated in SHARED mode.\" Similarly, revoke of SYS* admin privileges fails.\n\nIf the password file does not exist, then the behavior is the same as setting REMOTE_LOGIN_PASSWORDFILE to none.\n\nexclusive\n\nThe password file can be used by only one database. The password file can contain SYS and non-SYS users.\n\nWhen REMOTE_LOGIN_PASSWORDFILE is set to exclusive, if the password file does not exist, then the behavior is the same as setting REMOTE_LOGIN_PASSWORDFILE to none.\n\nnone\n\nOracle ignores any password file. Therefore, privileged users must be authenticated by the operating system.\n\nWhen remote login is attempted (such as sqlplus sys/password_for_sys@tns_name_of_database as sysdba), then:\n\nIf a password file does not exist, error \"ORA-01031: insufficient privileges\" will be raised.\n\nIf the password is incorrect, error \"ORA-01017: invalid username/password; logon denied\" will be raised.\n\nIf the username is incorrect, error \"ORA-01031: insufficient privileges\" will be raised.\n\nNotes:\nIf you change REMOTE_LOGIN_PASSWORDFILE to exclusive or shared from none, then ensure that the password file is synchronized with the dictionary passwords. See Oracle Database Administrator\'s Guide for more information.',3604,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3436,'SHARED_POOL_SIZE','SHARED_POOL_SIZE specifies (in bytes) the size of the shared pool. The shared pool contains shared cursors, stored procedures, control structures, and other structures. If you set PARALLEL_AUTOMATIC_TUNING to false, then Oracle also allocates parallel execution message buffers from the shared pool. Larger values improve performance in multiuser systems. Smaller values use less memory.\n\nYou can monitor utilization of the shared pool by querying the view V$SGASTAT.\n\nSee Also:\nOracle Database Performance Tuning Guide for more information on setting this parameter\nOracle Database Upgrade Guide for information on parallel execution message buffers\n\"PARALLEL_AUTOMATIC_TUNING\" and \"V$SGASTAT\"\n#设置asm sga中 shard pool的大小。',3604,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3437,'查看asm磁盘\nfree_mb/used_mb/tot_mb/disk_path/disk_name','select os_mb,total_mb,free_mb,name,path,group_number from v$asm_disk;',3605,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3438,'V$ASM_CLIENT','识别DB正在使用的由asm instance管理的disk group。\n在一个DB instance，V$ASM_CLIENT显示信息关于Oracle asm instance 如果database有任何打开的oracle asm file.\n\n在 ASM instance上显示所有连接到他的instance(可能是DB，也可能是ASM，因为他自己)\n在 DB  instance上显示DB连接的disk group，已经disk group所在的asm instance.',3606,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3439,'V$ASM_ATTRIBUTE','v$asm_atiribute显示每个属性有一个row.此外，属性被指定在CREATE DISKGROUP 和 ALTER DISKGROUP，这个视图可能还会显示其他属性，这些属性是create是自带的.\n\nnoge:属性是只被显示在disk groups COMMPATIBLE.ASM设置为11.1或更高。',3606,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3440,'V$ASM_DISK','V$ASM_DISK displays one row for every disk discovered by the Oracle Automatic Storage Management (Oracle ASM) instance, including disks that are not part of any disk group.\nv$ASM_DISK显示由asm instance找到的每个磁盘，包括还不属于disk group的磁盘的磁盘。\n\nNote:\nThe GROUP_NUMBER and DISK_NUMBER columns will only be valid if the disk is part of a disk group which is currently mounted by the instance. Otherwise, GROUP_NUMBER will be 0, and DISK_NUMBER will be a unique value with respect to the other disks that also have a group number of 0.',3606,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3441,'V$ASM_DISK_STAT','Contains the same columns as V$ASM_DISK, but to reduce overhead, does not perform a discovery when it is queried. It only returns information about any disks that are part of mounted disk groups in the storage system. To see all disks, use V$ASM_DISK instead.\n\nV$ASM_DISK_STAT displays performance statistics in the same way that V$ASM_DISK does, but without performing discovery of new disks. This results in a less expensive operation. However, since discovery is not performed, the output of this view does not include any data about disks that are new to the system.\n\nThe columns for V$ASM_DISK_STAT are the same as those for V$ASM_DISK.\n这个view与V$ASM_DISK相同。所以可以放弃它了',3606,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3442,'V$ASM_DISKGROUP_STAT','V$ASM_DISKGROUP_STAT displays performance statistics in the same way that V$ASM_DISKGROUP does, but without performing discovery of new disk groups. This results in a less expensive operation. However, since discovery is not performed, the output of this view does not include any data about disk groups that are new to the system.\n\nThe columns for V$ASM_DISKGROUP_STAT are the same as those for V$ASM_DISKGROUP.\n这个视图等同于V$ASM_DISKGROUP,但是访问V$ASM_DISKGROUP会对性能产生影响，所以一般情况下，只要访问这个视图就可以了，但是这个视图不会涉及磁盘发现，也就是为什么V$ASM_DISKGROUP会对性能产生影响。',3606,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3443,'V$ASM_USER','V$ASM_USER displays the effective operating system user names of connected database instances and of file owners.',3606,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3444,'V$ASM_USERGROUP','V$ASM_USERGROUP displays the creator for each Oracle Automatic Storage Management (Oracle ASM) File Access Control group.',3606,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3445,'V$ASM_USERGROUP_MEMBER','V$ASM_USERGROUP_MEMBER displays the members for each Oracle Automatic Storage Management (Oracle ASM) File Access Control group.',3606,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3446,'V$ASM_DISKGROUP','V$ASM_DISKGROUP displays one row for every Oracle Automatic Storage Management (Oracle ASM) disk group discovered by the Oracle ASM instance on the node.\n\nNote:\nThe GROUP_NUMBER, TOTAL_MB, and FREE_MB columns are only meaningful if the disk group is mounted by the instance. Otherwise, their values will be 0.',3606,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3447,'V$ASM_OPERATION','这个视图显示每个在asm instance中正在执行的操作，这个操作可能执行时间很长。在DB中这个视图显示no row',3606,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3448,'V$ASM_ESTIMATE','V$ASM_ESTIMATE displays an estimate of the work involved in execution plans for Oracle Automatic Storage Management (Oracle ASM) disk group rebalance and resync operations.\n显示asm disk grep rebalance和resync执行计划的工作估计.',3606,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3449,'V$ASM_FILE','V$ASM_FILE显示每个被asm instance mount的disk group的每个file。在DB中v$ASM_FILE显示no row.',3606,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3450,'V$ASM_DISK_IOSTAT','V$ASM_DISK_IOSTAT displays information about disk I/O statistics for each Oracle Automatic Storage Management (Oracle ASM) client. If this view is queried from the database instance, only the rows for that instance are shown.\n显示信息关于DISK I/O同喜，对于每个ASM client.如果这个查询在DB instance ，那么只显示当前instance对于asm的I/O统计.',3606,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3451,'V$ASM_TEMPLATE','In an Oracle Automatic Storage Management (Oracle ASM) instance, V$ASM_TEMPLATE displays one row for every template present in every disk group mounted by the Oracle ASM instance. In a database instance, V$ASM_TEMPLATE displays one row for every template present in every disk group mounted by the Oracle ASM instance with which the database instance communicates.\n\n在asm instance中，这个是view显示instance中每个disk group中存在的template。在DB instance中，显示与这些在asm instance显示的template通讯的template.',3606,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3452,'V$ASM_CLIENT','--',3606,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3453,'创建队列','见文档',3607,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3454,'查看是否配置了stream','select * from dba_streams_administrator;',3608,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3455,'查看当前schema下那些表的外键没有加索引','\"显示表和这个表的外键/因为外键不加索引，会引起某些阻塞\"',3609,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3456,'big_table','\"创建big_table脚本\"',3610,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3457,'show space','\"输出segment空间利用率脚本\"',3610,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3458,'通过alert log 文件来看DB启动和关闭时间，以及运行时间','\"脚本使用方法\"',3610,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3459,'操作系统认证和密码文件认证优先级','Operating system authentication takes precedence over password file authentication',3611,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3460,'创建口令文件','ORAPWD FILE=orapwsid PASSWORD=ROBERT ENTRIES=20 force=<y/n> ignorecase=<y/n> nosysdba=<y/n>;\n#force:if(y)覆盖已经存在的密码文件\n#ignorecase:if(y)密码区分大小写\n#ENTRIES:密码文件中保存账户的数量\n#format - use format=12 for new 12c features like SYSBACKUP, SYSDG and SYSKM support, longer identifiers, etc.If not specified, format=12 is default (optional),\n--远程连接使用的是设置密码文件的密码，而不是sys或system的用户密码',3612,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3461,'REMOTE_LOGIN_PASSWORDFILE','设置是否使用密码文件，如果使用，是否在多个数据库共享这个密码文件.\nNONE/SHARED/EXCLUSIVE  #非动态参数。',3613,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3462,'V$PWFILE_USERS','--V$PWFILE_USERS lists all users in the password file, and indicates whether the user has been granted the SYSDBA, SYSOPER, SYSASM, SYSBACKUP, SYSDG, and SYSKM privileges.',3614,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3463,'过程赋给给某个用户需要注意的地方','如果一个过程由A创建，里面有显示A的表中的内容,那么当A把这个过程赋给B后，B来执行这个过程他也能显示这个过程中A用户的表，即使他没有获得这个表的select权限。',3615,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3464,'current of','--游标中使用的语句\ndeclare\n   cursor cc is select * from tmp where rownum<10;\nbegin\n   update tmp set a=\'b\' where current of cc;\nend;\n/\n--更新游标中的条目',3616,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3465,'for update [of]','----for update是对符合谓词的条件进行锁定。\n--详情doc',3616,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3466,'笛卡尔乘积(cross join)','SELECT EMP.ENAME,DEPT.DNAME FROM EMP,DEPT;--oracle语法\nselect emp.ename,dept,dname from emp cross join dept;--ANSI-语法',3617,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3467,'通过子节点找到父节点','--此sql是错误的，未完成的结果。放在这里为以后继续。',3618,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3468,'每15秒内删除重复的记录','--',3618,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3469,'<','小于',3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3470,'<=','小于等于',3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3471,'ANY','与一个列表中的任意值进行比较',3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3472,'LIKE',NULL,3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3473,'IS NULL',NULL,3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3474,'IS NAN',NULL,3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3475,'IS INFINITE',NULL,3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3476,'NOT IN',NULL,3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3477,'NOT BETWEEN',NULL,3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3478,'AND/OR/NOT','AND的优先级高于OR/比较操作符的优先级高于AND',3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3479,'笛卡尔乘积','假设一个表50行，另一个表100行，那么回返回5000行',3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3480,'||','连接符',3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3481,'+ - * /','算数运算',3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3482,'=','等于',3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3483,'<>或!=','不等于',3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3484,'>','大于',3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3485,'>=','大于等于',3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3486,'SOME','等同于ANY操作符。应该使用ANY来代替SOME，因为ANY使用的更为广泛，且更易阅读',3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3487,'ALL','与一个列表中的所有值进行比较',3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3488,'IN',NULL,3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3489,'BETWEEN',NULL,3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3490,'NOT LIKE',NULL,3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3491,'IS NOT NULL',NULL,3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3492,'IS NOT NAN',NULL,3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3493,'IS NOT INFINITE',NULL,3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3494,'ORDER BY','ASC:升序/DESC:降序/可以用数字表达排序select中指定的column',3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3495,'for update [nowait]','锁住查询出来的记录,如果查询的记录已经被锁住，是否一致等待直至可以获取。反之直接返回错误.ORA-00054: resource busy and acquire with NOWAIT specified or timeout expired',3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3496,'for update skip locked','--查询出第一条没有被锁住的记录',3619,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3497,'创建sequence语法','序列/参数解释',3620,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3498,'ALL_SEQUENCES','--ALL_SEQUENCES describes all sequences accessible to the current user.\n\nRelated Views\n\nDBA_SEQUENCES describes all sequences in the database.\n\nUSER_SEQUENCES describes all sequences owned by the current user. This view does not display the SEQUENCE_OWNER column.',3621,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3499,'MERGE例子','--BEGIN\nMERGE INTO   bbb b\n    USING aaa a\n    ON(a.a = b.q)\n    WHEN MATCHED THEN\n    UPDATE SET\n    b.w =   a.b,\n    b.e =   a.c,\n    b.r =   a.d,\n    b.t =   a.e\nWHEN NOT MATCHED THEN\nINSERT VALUES(a.a,a.b,a.c,a.d,a.e);   \nEND;\n/\n\nMerge是insert和update的集合。\n用法：\nINTO B表，A为原表，基于ON（）中的两列是否相同，来做插入。PS:ON中的 = 号两边位置可以互换，无所谓。\nWHEN MATCHED THEN，当ON中的两列中有相同的值，那就基于此值的行，来更新数据。\nPs：update set中不能包含ON（）中的列，否者会出现错误ORA-38104，同时update set中的 =号两边固定格式，左边是into的，右边是using的。\nWHEN NOT MATCHED THEN，当ON中的两列中没有相同的值，那就使用A表数据插入B表。\n如果出现ORA-30926错误（无法获得稳定的行），这个错误针对update而言的，B表中Q列有和A表中A列相同的值，而且A表中A列和B的Q中的相同值还不只一个，所以无法判断用A表中的那个相同值的行来更新B中Q列相同值的行。主要是源表(也就是A不能有重复)',3622,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3500,'NVL','把null替换为一个你指定的值:select NVL(salary,\"abc\") from employees;',3623,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3501,'NLS_INITCAP','首字母大写',3623,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3502,'LEFT OUTER JOIN','\"左外连接\"',3623,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3503,'to_char','\"数据转换\"',3623,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3504,'mod','\"取余\"',3623,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3505,'distinct','去掉重复行',3623,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3506,'cast','\"数据类型转换\"',3623,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3507,'instr','\"返回要截取的字符串在源字符串中的位置\"',3623,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3508,'ORA_HASH','\"把某个值或列hash\"',3623,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3509,'ratio_to_report() over()','分析列占列的百分比',3623,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3510,'minus','--找出两条sql语句中不同的内容',3623,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3511,'replace(a,\'x\',\'z\')','--select replace(\'abc\',\'b\',\'c\') from dual;#acc\n--替换字符串\n',3623,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3512,'decode','--判断',3623,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3513,'CASE','--SELECT CASE \n    WHEN xxx then xxx \n    when xxx then xxx\n    else xxx end \n  from dual;',3623,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3514,'sys_guid()','--类似于sequence作用的函数',3623,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3515,'trunc','--',3623,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3516,'多列分组','--select product_id,customer_id from purchases group by product_id,customer_id;',3624,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3517,'group by与聚合函数','--select avg(x) from abc group by c;\n--select count(x) from abc group by c;\n--group by中有null的字段，oracle同样把他当做一个一值来计算,见文档',3624,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3518,'having使用','--为什么使用having',3624,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3519,'lag','\"显示一个字段中的值的前N行，是什么值。\"',3625,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3520,'Rank() over()','Rank() over()的用法',3625,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3521,'count(*) over([partition by] COL_NAME)','--',3625,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3522,'max(x)over()','--select max(b)over()a from a;\n--每一行显示B列的总数',3625,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3523,'sys_connect_by_path','--',3625,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3524,'CHR(x)','转换ASCII码为它的字符',3626,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3525,'CONCAT(x,y)','合并x列和y列，和||作用一样',3626,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3526,'nvl(x,value)','x为null，就返回value，反之返回x',3626,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3527,'RTRIM(x，width[,pad_string])','与LTRIM()类似，不过要对x的右边截去',3626,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3528,'SOUNDEX(x)','--返回一个包含x的发音的字符串。该函数用于对英文发音不同但却比较近的单词进行比较。\n--SOUNDEX函数返回字符串参数的语音表示形式，相对于比较一些读音相同，但是拼写不同的单词是非常有用的。 ',3626,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3529,'SUBSTR(x,start[,length])','返回x中的一个子字符串，这个子字符串从start开始，还可以为这个子字符串指定长度，用length参数',3626,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3530,'TRIM([trim_charFROM]x)','从x的左边和右边同时截去一些字符。可以使用参数trim_string来指定要截去的字符:如果不指定trim_string，默认截去空格',3626,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3531,'ASCII(x)','转换字符为它的ASCII码',3626,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3532,'INITCAP(x)','将x的每个单词的首字母转换成大写',3626,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3533,'INSTR(x,find_string[,start][,occurrence])','在x中查找字符串find_string，然后返回find_string所在的位置。可以提供一个start位置来指定该函数从这个位置开始查找。也可以指定occurrence参数，来说明应该返回find_string第几次出现的位置。',3626,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3534,'LENGTH(x)','返回x中的字符个数',3626,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3535,'LOWER(x)','将x中的字母转换成小写。',3626,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3536,'LPAD(x,width[,pad_string])','在x的左边补齐空格，得到总长width个字符的字符串。pad_string，可以指定重复使用哪个字符串来补齐左边的空位',3626,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3537,'LTRIM(x,[,trim_string])','从x的左边街区一些字符。可以使用trim_string来指定要截去的字符，如果不指定这个参数，则默认截去空格。',3626,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3538,'NANVL(x,value)','如果x匹配NAN这个特殊值(非数字)，就返回value；否则返回x。',3626,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3539,'NVL2(x,value1,value2)','如果x非空，就返回value1;反之返回value2',3626,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3540,'REPLACE(X，search_string,replace_string)','在x中查找search_string,并替换为replace_string',3626,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3541,'RPAD(x,width[,pad_string])','与LPAD类似，不过要对x的右边补齐',3626,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3542,'upper(x)','将x中的字母转换为大些。',3626,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3543,'substrb','--与SUBSTR一样，但是substrb是按照字节来计算的',3626,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3544,'lengthb','--返回字节的个数',3626,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3545,'INSTRB（string1, string2[a,[b]]）','--和INSTR相同,只是操作的对参数字符使用的位置的是字节.',3626,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3546,'ACOS(x)','--返回x的反余弦;ACOS(1)=0/ACOS(-1)=3.14159265',3627,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3547,'ASIN(x)','--返回x的反正弦;ASIN(1)=1.57079633/ASIN(-1)=-1.5707963',3627,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3548,'BITAND(X,Y)','--返回x和y进行位与(and)操作的结果',3627,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3549,'COS(x)','--返回x的余弦，其中x是弧度;COS(90*3.1415926)=1/COS(45*3.1415926=-1)',3627,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3550,'COSH(x)','--返回x的双曲余弦函数;COSH(3.1415926)=11.919527',3627,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3551,'floor(x)','--返回小于或等于x的最大整数',3627,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3552,'ROUND(X[,y])','--返回x取整的结果，y是可选参数，说明对第几位小数取整，没有指定Y说明第0位小数取整。如果y是负数，则对x的小数点的左边的第|Y|为取整',3627,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3553,'SIN(X)','--返回x的正弦函数;SIN(0)=0',3627,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3554,'SQRT(X)','--返回x的平方根;SQRT(25)=5',3627,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3555,'TAN(X)','--返回X的正切函数，TAN(0)=0',3627,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3556,'ABS(x)','--返回绝对值',3627,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3557,'ATAN(x)','--返回x的反正切;ATAN(1)=.785398163/ATAN(-1)=-.78539816',3627,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3558,'ATAN2(x,y)','--返回x和y的反正切;ATAN2(1,-1)=2.35619449',3627,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3559,'CEIL(X)','--返回大于或等于x的最小整数',3627,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3560,'EXP(Z)','--返回E的x次幕，其中e约等于2.71828183;EXP(1)=2.71828183/EXP(2)=7.3890561',3627,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3561,'LOG(X,Y)','--返回以x为底y的对数;LOG(2,4)=2/LOG(2,5)=5.32192809',3627,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3562,'LN(X)','--返回x的自然对数;LN(2.71828183)=1',3627,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3563,'MOD(X,Y)','--返回x除以y的余数',3627,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3564,'POWER(X,Y)','--返回x的y次幂',3627,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3565,'SIGN(X)','--获取符号，如果x是负数，返回-1;如果x是正数返回1，x是0返回0',3627,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3566,'TANH(X)','--返回x的双曲正切函数;TANH(1)=.761594156',3627,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3567,'TRUNC(X[,Y])','--返回对x阶段的结果:y为可选参数，说明对第几位小数截断。如果y没有指定，则对x在0位小数处阶段:如果y是负数，则对x在小数点左边的第|Y|位处截断',3627,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3568,'NUMTODSINTERVAL ','--用于systimestamp的时间加减\nselect systimestamp + NUMTODSINTERVAL(1,\'hour\') from dual;\n替换参数;\n　　\'DAY\'\n　　\'HOUR\'\n　　\'MINUTE\'\n　　\'SECOND\'',3628,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3569,'REGEXP_COUNT','--REGEXP_COUNT(x,pattern[,start,[match_option]])\n--在x中查找pattern，并返回pattern在x中的次数。',3629,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3570,'REGEXP_INSTR','--REGEXP_INSTR(x,pattern[,start[,occurrence[,return_option[,match_option]]]])\n--在x中查找pattern，并返回pattern所在的位置。',3629,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3571,'REGEXP_REPLACE','--REGEXP_REPLACE(x,pattern[,replace_string[,start[,occurrence[,match_option]]]])\n--在x中查找pattern，并将其替换为replace_string。其他选项的意思与regexp_instr()函数的参数完全相同\n',3629,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3572,'REGEXP_SUBSTR','--regexp_substr(X,PATTERN[,START[,OCCURRENCE[,MATCH_OPTION]]])\n--返回x中可以匹配pattern的一个字字符串',3629,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3573,'REGEXP_LIKE','--REGEXP_LIKE(x,pattern[,match_option])\n--在x中查找pattern参数中定义的正则表达式',3629,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3574,'元字符','--',3629,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3575,'AVG(X)','--返回x的平均值',3630,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3576,'MAX(X)','--返回x的最大值',3630,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3577,'MIN(X)','--返回x的最小值',3630,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3578,'SUM(X)','--返回x的和',3630,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3579,'COUNT(X)','--返回一个包含x的查询返回的行数',3630,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3580,'MEDIAN(X)','--返回x的中间值',3630,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3581,'STDDEV(X)','--返回x的标准差',3630,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3582,'variance(X)','--返回x的方差',3630,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3583,'scn_to_timestamp','--select to_char(scn_to_timestamp(7012),\'YYYY-MM-DD HH24:MI:SS\') from dual;',3631,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3584,'bin_to_num(x)','--将二进制数字x转换成number类型',3631,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3585,'to_char(x,[,format])','--将x转换为字符串',3631,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3586,'to_number(x,[,format])','--select to_number(\'970.13\')+25 from dual;',3631,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3587,'CAST(x AS type)','--将x转换为由type指定的兼容数据库类型',3631,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3588,'scn_to_timestamp(ORA_ROWSCN)','--scn转时间',3631,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3589,'Optimizer','\"优化器相关知识\"',3632,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3590,'ACCESS PATHS','\"访问路径概念\"',3632,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3591,'hints','所有hints的使用介绍',3632,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3592,'STATISTICS','\"statistics相关概念\"',3632,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3593,'join','\"join相关概念\"',3632,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3594,'SID','--SELECT USERENV(\'SID\') FROM DUAL;--查看当前SID',3633,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3595,'CON_NAME','--SELECT SYS_CONTEXT (\'USERENV\', \'CON_NAME\') FROM DUAL;--查看当前CDB/PDB的名字',3633,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3596,'CON_id','--SELECT SYS_CONTEXT (\'USERENV\', \'CON_id\') FROM DUAL;--查看当前CDB/PDB ID',3633,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3597,'CURRENT_SCHEMA','--SELECT SYS_CONTEXT(\'USERENV\', \'CURRENT_SCHEMA\') FROM DUAL;',3633,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3598,'SESSION_USER','--SELECT SYS_CONTEXT(\'USERENV\', \'SESSION_USER\') FROM DUAL;',3633,'2016-04-06 23:27:49','2016-04-06 23:27:49',NULL),(3599,'ORA_ROWSCN','--显示行的scn号\n--select ORA_ROWSCN rowscn from rangel where rownum<10;\n--可以用scn_to_timestamp把scn转换成时间',3634,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3600,'statspack安装和执行','\"操作说明\"',3635,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3601,'DBMS_ADVISOR.SET_DEFAULT_TASK_PARAMETER','--EXECUTE DBMS_ADVISOR.SET_DEFAULT_TASK_PARAMETER(\n                     \'ADDM\', \'DBIO_EXPECTED\', 8000);\n',3636,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3602,'DBMS_ADDM.ANALYZE_DB','--',3636,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3603,'DBMS_ADDM.ANALYZE_INST','--',3636,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3604,'DBMS_ADDM.ANALYZE_PARTIAL ','--',3636,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3605,'DBMS_ADDM.GET_REPORT','--DBMS_ADDM.GET_REPORT (task_name IN VARCHAR2 RETURN CLOB);',3636,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3606,'手动运行ADDM(Instance)','--VAR tname VARCHAR2(30);\nBEGIN\n  :tname := \'my ADDM for 7PM to 9PM\'; //设置ADDM名字，输出ADDM报告时需要指定这个名字。\n  DBMS_ADDM.ANALYZE_INST(:tname, 137, 145, 1);\nEND;\n/',3637,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3607,'手动运行ADDM(Partial Mode | 局部模式)','--VAR tname VARCHAR2(30);\nBEGIN\n  :tname := \'my ADDM for 7PM to 9PM\';\n  DBMS_ADDM.ANALYZE_PARTIAL(:tname, \'1,2,4\', 137, 145);\nEND;\n/',3637,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3608,'Dispaly ADDM Report','--SET LONG 1000000 PAGESIZE 0;\nSELECT DBMS_ADDM.GET_REPORT(:tname) FROM DUAL;',3637,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3609,'手动运行ADDM(Database)','VAR tname VARCHAR2(30);\nBEGIN\n  :tname := \'ADDM for 7PM to 9PM\'; //设置ADDM名字，输出ADDM报告时需要指定这个名字。\n  DBMS_ADDM.ANALYZE_DB(:tname, 137, 145);\nEND;\n/',3637,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3610,'control_management_pack_access','--3个参数\n DIAGNOSTIC\n DIAGNOSTIC+TUNING \n NONE //关闭addm\n',3638,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3611,'STATISTICS_LEVEL','--',3638,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3612,'DBA_ADVISOR_FINDING_NAMES','--This view lists all finding names registered with the advisor framework.',3639,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3613,'DBA_ADVISOR_FINDINGS','--',3639,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3614,'DBA_ADVISOR_RECOMMENDATIONS','--',3639,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3615,'DBA_ADVISOR_TASKS','--',3639,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3616,'DBA_ADDM_FINDINGS','--这个视图显示了DBA_ADVISOR_FINDINGS中所有关于ADDM执行任务的条目。',3639,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3617,'创建快照','--EXEC DBMS_WORKLOAD_REPOSITORY.CREATE_SNAPSHOT ();',3640,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3618,'修改快照收集策略','--DBMS_WORKLOAD_REPOSITORY.MODIFY_SNAPSHOT_SETTINGS(retention => 43200,interval => 30, topnsql => 100, dbid => 3310949047);\n--retention:保留时间（分钟）\n--interval:间隔（分钟）\n',3640,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3619,'生成快照报告(本地DB)','--@?/rdbms/admin/awrrpt.sql	 \n',3640,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3620,'生成快照报告(指定DB)','--@?/rdbms/admin/awrrpti.sql	 \n',3640,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3621,'生成快照报告(RAC/指定DB)','--@?/rdbms/admin/awrgrpti.sql\n',3640,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3622,'生成快照报告(sql/本地DB)','--@?/rdbms/admin/awrsqrpt.sql',3640,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3623,'生成对比快照报告(RAC本地/指定DB)','--@?/rdbms/admin/awrgdrpi.sql',3640,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3624,'生成快照报告(ASH:本地DB)','--@?/rdbms/admin/ashrpt.sql\n',3640,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3625,'删除快照','--exec DBMS_WORKLOAD_REPOSITORY.DROP_SNAPSHOT_RANGE(\n    low_snap_id => 22,\n    high_snap_id => 32, \n    dbid => 3310949047\n    );	\n--注意相关的ASH数据也会被drop\n',3640,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3626,'基线--创建基准快照','--DBMS_WORKLOAD_REPOSITORY.CREATE_BASELINE(\n    start_snap_id => 270, \n    end_snap_id => 280,\n    baseline_name => \'peak baseline\',\n    dbid => 3310949047,\n    expiration => 30);	\n--start_snap_id:快照开始id\n--end_snap_id:快照结束id\n--baseline_name:快照名字。\n',3640,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3627,'基线--删除基准','--DBMS_WORKLOAD_REPOSITORY.DROP_BASELINE(baseline_name => \'peak baseline\', cascade => FALSE, dbid => 3310949047);\n',3640,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3628,'基线--重命名','--DBMS_WORKLOAD_REPOSITORY.RENAME_BASELINE(old_baseline_name => \'peak baseline\',new_baseline_name => \'peak mondays\',dbid => 3310949047);	 \n',3640,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3629,'生成快照报告(RAC/本地DB)','--@?/rdbms/admin/awrgrpt.sql\n',3640,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3630,'生成快照报告(sql/指定DB)','--@?/rdbms/admin/awrsqrpi.sql  ',3640,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3631,'生成对比快照报告(本地/指定DB)','--@?/rdbms/admin/awrddrpt.sql',3640,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3632,'awr--提取','--@?/rdbms/admin/awrextr.sql',3640,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3633,'awr--载入','--@?/rdbms/admin/awrload.sql\n',3640,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3634,'生成快照报告(ASH:RAC)','--@?/rdbms/admin/ashrpti.sql',3640,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3635,'生成快照报告(ASH:指定DB)','--@?/rdbms/admin/ashrpti.sql',3640,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3636,'statistics_level','--设置statistics_level为TYPICAL或ALL开启awr',3641,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3637,'查看awr保留期','select dbms_stats.get_stats_history_retention from dual;',3642,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3638,'查询已收集的快照','--col begin_interval_time for a30\n--col STARTUP_TIME for a30\n--select snap_id, to_char(begin_interval_time,\'YYYY-MM-DD HH24:MI\') BEGIN_TIME , to_char(END_INTERVAL_TIME,\'YYYY-MM-DD HH24:MI\') END_TIME from dba_hist_snapshot order by 1;',3642,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3639,'查看awr占sysaux TS空间','--select occupant_name,SPACE_USAGE_KBYTES from v$sysaux_occupants where occupant_name like \'%AWR%\';',3642,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3640,'查看差异','--col baseline_name for a10\nSelect baseline_name,metric_name,num_interval,interval_size From Table(dbms_workload_repository.select_baseline_metric(l_baseline_name => \'goku\'));\n',3642,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3641,'查看基线差异','--Select baseline_name,metric_name,num_interval,interval_size From Table(dbms_workload_repository.select_baseline_metric(l_baseline_name => \'goku\'));\n',3642,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3642,'dba_hist_sysstat','--DBA_HIST_SYSSTAT displays historical system statistics information. This view contains snapshots of V$SYSSTAT.\n--也就是awr快照信息',3643,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3643,'dba_hist_snapshot','--DBA_HIST_SNAPSHOT displays information about the snapshots in the Workload Repository',3643,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3644,'DBA_HIST_UNDOSTAT','--Contains statistical snapshots of V$UNDOSTAT information.',3643,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3645,'DBA_HIST_WR_CONTROL','--',3643,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3646,'DBA_HIST_BASELINE_TEMPLATE','--',3643,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3647,'DBA_HIST_BASELINE_METADATA','--',3643,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3648,'DBA_HIST_BASELINE','--',3643,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3649,'DBA_HIST_BASELINE_DETAILS','--',3643,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3650,'dba_hist_database_instance','--查看instance历史启动信息',3643,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3651,'ADRCI> SPOOL /XXX/XXX/XX\nADRCI> SHOW  ALERT\nADRCI> SPOOL OFF','捕获ALERT文件内容到另一个文件中。',3644,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3652,'DESCRIBE INCIDENT','显示INCIDENT中所有的字段，可以用于SHOW INCIDENT来详细显示某个事件的谓词。另外这个命令也只能在SHOW HOMEPATH显示中指定一个主目录不然会报错DIA-48448.',3644,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3653,'SHOW INCIDENT [-P \"INCIDENT_ID-XXXX\"] \n              [-MODE DETAIL|BASIC|BRIEF]','-P指定谓词，显示指定的事件号\n-MODE显示这个事件的详细信息,他的三个选项用于显示详细信息不同的程度。',3644,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3654,'SHOW PROBLEM','显示ADR可用的主目录中的问题',3644,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3655,'LINUX> ADRCI EXEC=\"SHOW HOMES;show incident\"','在SHELL下执行ADRCI内的命令,如果执行多个命令用分好隔开.',3644,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3656,'SHOW TRACEFILE','显示每个adr主目录中所有的TRACE FILE',3644,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3657,'IPS CREATE PACKAGE;','打包主目录，有一个问题，这个打包命令只能应用于SHOW HOMEPATH只有一个主目录的情况下，如果SHOW HOMEPATH有多个主目录那么会报错 DIA-48448: THIS COMMAND DOES NOT SUPPORT MULTIPLE ADR HOMES',3644,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3658,'SHOW/SET BASE','显示/设置ADRCI根目录',3644,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3659,'SHOW HOMES','显示ADR可用的主目录',3644,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3660,'SHOW ALERT [-P][-tail 100]\nshow alert -p \"message_text like \'%ORA%\'\"','#-P \"XXX\" 显示指定的字符行\n#-tail 100 显示alert文件后100行数据\n#使用通配符来搜索alert文件',3644,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3661,'SHOW/SET HOMEPATH XXXX','#显示和设置当前ADR主目录的位置.你可以在show home看到很多个instance的主目录(当你的机器上面运行多个DB时)，如果你设置这个参数，也就是这个参数为空，那么oracle认为show home显示出来的所有目录都为\"当前\"状态，即为可用状态，如果你只想应用某一个路径，则可以在这个参数中指定。\n#SET HOMEPATH diag/rdbms/goku/goku diag/tnslsnr/localhost/listener 如果要同时激活多个主目录就用空格分隔，加在后面',3644,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3662,'DIAGNOSTIC_DEST','定义diag目录的位置.',3645,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3663,'OPTIMIZER_CAPTURE_SQL_PLAN_BASELINES',NULL,3646,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3664,'查看awr使用sysaux TS的空间','select occupant_name,occupant_desc,space_usage_kbytes/1024 USAGE_MB from v$sysaux_occupants where occupant_name like \'%AWR%\';',3647,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3665,'创建runtats','\"比较两个sql或plsql的性能，输出指标，latch，redo，cpu等等\"',3648,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3666,'RUNTATS使用方法','\"介绍\"',3648,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3667,'增加外键','--alter table b add foreign key(b) REFERENCES a(a);',3649,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3668,'创建外键','--drop table a;\n--create table a (a int primary key);\n--drop table b;\n--create table b (a int primary key,b int ,foreign key(b) references a(a));\n--外键可以引用primary key和unique key',3649,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3669,'查看表的外键约束名/引用的表/引用的列/','   col column_name for a20\n   col TABLE_NAME for a20\n   SELECT F.TABLE_NAME, F.COLUMN_NAME, F.CONSTRAINT_NAME  \n   FROM dba_CONSTRAINTS R, dba_CONS_COLUMNS F \n   WHERE  R.TABLE_NAME = \'B\'\n   AND R.CONSTRAINT_TYPE = \'R\' \n   AND R.R_CONSTRAINT_NAME = f.CONSTRAINT_NAME ;\n--替换B查询，或者增加OWNER列筛选用户',3650,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3670,'constraint','create/alter/drop constraint',3651,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3671,'使用本地索引，来对分区表建立约束','--如果想使用一个局部分区索引来保证这个约束(uniue/primary key),那么分区键必须包括在约束中。',3651,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3672,'drop主键','--alter table USER_TOT_BASE drop PRIMARY KEY [CASCADE];',3652,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3673,'约束/not null/索引/3者关系实验','\"对not null 列，建立约束并开启DEFERRABLE后，对这列建立index，索引在需要使用count(*)时无效。\"',3653,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3674,'ALL_CONS_COLUMNS','--ALL_CONS_COLUMNS describes columns that are accessible to the current user and that are specified in constraints.',3654,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3675,'ALL_CONSTRAINTS','--ALL_CONSTRAINTS describes constraint definitions on tables accessible to the current user.',3654,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3676,'dbms_lock.sleep(5);','停顿5秒',3655,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3677,'latch','\"lathc的请求过程。绑定变量对latch的减少效果。\"',3656,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3678,'外键未加索引死锁','\"展示这个过程\"',3657,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3679,'lock','\"悲观和乐观锁定使用方法\"',3657,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3680,'lock基本概念','\"锁的概念，丢失更新，阻塞，死锁，锁的类型。资料源于TOM\"',3657,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3681,'弥补insert阻塞','\"带有主键的表，两个session同时插入相同的值，导致阻塞的弥补方法。\"',3657,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3682,'外键未加索引死锁','\"实验展示\"',3657,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3683,'LOCK TABLE','SQL> LOCK TABLE TABLE_NAME IN LOCKMODE MODE[WAIT|NOWAIT];\n#TABLE_NAME:表名\n#LOCKMODE:锁的模式,如:EXCLUSIVE(独有)\n#WAIT|NOWAIT为等或不等待这个锁。',3658,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3684,'DDL_LOCK_TIMEOUT','DDL语句等待DML锁的时间。',3659,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3685,'lock','\"锁相关查询\"',3660,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3686,'查看锁类型','--SELECT /*+ FIRST_ROWS ORDERED */ username,\ns.osuser osuser , s.sid sid , s.serial# serial, l.lmode lmode ,\ndecode(L.LMODE,1,\'No Lock\',\n2,\'Row Share\',\n3,\'Row Exclusive\',\n4,\'Share\',\n5,\'Share Row Exclusive\',\n6,\'Exclusive\',\'NONE\') lmode_desc, l.type type ,\ndecode(l.type,\n\'BL\',\'Buffer hash table instance lock\',\n\'CF\',\' Control file schema global enqueue lock\',\n\'CI\',\'Cross-instance function invocation instance lock\',\n\'CS\',\'Control file schema global enqueue lock\',\n\'CU\',\'Cursor bind lock\',\n\'DF\',\'Data file instance lock\',\n\'DL\',\'Direct loader parallel index create\',\n\'DM\',\'Mount/startup db primary/secondary instance lock\',\n\'DR\',\'Distributed recovery process lock\',\n\'DX\',\'Distributed transaction entry lock\',\n\'FI\',\'SGA open-file information lock\',\n\'FS\',\'File set lock\',\n\'HW\',\'Space management operations on a specific segment lock\',\n\'IN\',\'Instance number lock\',\n\'IR\',\'Instance recovery serialization global enqueue lock\',\n\'IS\',\'Instance state lock\',\n\'IV\',\'Library cache invalidation instance lock\',\n\'JQ\',\'Job queue lock\',\n\'KK\',\'Thread kick lock\',\n\'MB\',\'Master buffer hash table instance lock\',\n\'MM\',\'Mount definition gloabal enqueue lock\',\n\'MR\',\'Media recovery lock\',\n\'PF\',\'Password file lock\',\n\'PI\',\'Parallel operation lock\',\n\'PR\',\'Process startup lock\',\n\'PS\',\'Parallel operation lock\',\n\'RE\',\'USE_ROW_ENQUEUE enforcement lock\',\n\'RT\',\'Redo thread global enqueue lock\',\n\'RW\',\'Row wait enqueue lock\',\n\'SC\',\'System commit number instance lock\',\n\'SH\',\'System commit number high water mark enqueue lock\',\n\'SM\',\'SMON lock\',\n\'SN\',\'Sequence number instance lock\',\n\'SQ\',\'Sequence number enqueue lock\',\n\'SS\',\'Sort segment lock\',\n\'ST\',\'Space transaction enqueue lock\',\n\'SV\',\'Sequence number value lock\',\n\'TA\',\'Generic enqueue lock\',\n\'TD\',\'DDL enqueue lock\',\n\'TE\',\'Extend-segment enqueue lock\',\n\'TM\',\'DML enqueue lock\',\n\'TT\',\'Temporary table enqueue lock\',\n\'TX\',\'Transaction enqueue lock\',\n\'UL\',\'User supplied lock\',\n\'UN\',\'User name lock\',\n\'US\',\'Undo segment DDL lock\',\n\'WL\',\'Being-written redo log instance lock\',\n\'WS\',\'Write-atomic-log-switch global enqueue lock\') type_desc ,\nrequest , block\nFROM v$lock l, v$session s\nWHERE s.sid = l.sid\nAND l.type <> \'MR\'\nAND s.type <> \'BACKGROUND\'\nORDER BY username\n/',3660,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3687,'剩余空间不足\n','SELECT *\n  FROM (select b.tablespace_name,\n               round(a.bytes / 1024 / 1024) free_MB,\n               round(b.bytes / 1024 / 1024) userd_MB,\n               round(b.maxbytes / 1024 / 1024) max_MB\n          from (select sum(bytes) bytes, tablespace_name\n                  from dba_free_space\n                 group by tablespace_name) a,\n               (select TABLESPACE_NAME,\n                       sum(bytes) bytes,\n                       decode(sum(MAXBYTES), 0, sum(bytes), sum(maxbytes)) maxbytes\n                  from dba_data_files\n                 group by TABLESPACE_NAME) b\n         where a.tablespace_name = b.tablespace_name)\n WHERE ((USERD_MB - FREE_MB) / USERD_MB * 100) > par1\n   AND (USERD_MB / MAX_MB * 100) > par2',3661,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3688,'10min -- 查看参数undo_retention是否符合oracle推荐的值','select tuned_undoretention,\n       (select value from v$parameter where name = \'undo_retention\') undo_retention_value\n  from v$undostat\n where tuned_undoretention >\n       (select value from v$parameter where name = \'undo_retention\')\n   AND BEGIN_TIME > sysdate - 1 / 24 / 60 * 10;\n\n#log:最近10分钟,undo_retuention参数的推荐值小于Oracle的推荐值，建议增大.',3662,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3689,'10min -- 尝试或已经使用了未到期的undo的次数','select UNXPSTEALCNT, UNXPBLKREUCNT\n  from v$undostat\n where (UNXPSTEALCNT > 0 or UNXPBLKREUCNT > 0)\n   and BEGIN_TIME > sysdate - 1 / 24 / 60 * 10;',3662,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3690,'10min -- undo TS没有可用空间的次数','select NOSPACEERRCNT\n  from v$undostat\n where NOSPACEERRCNT > 0\n   and BEGIN_TIME > sysdate - 1 / 24 / 60 * 10;\n',3662,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3691,'10MIN -- ORA-01555出现的次数','select SSOLDERRCNT\n  from v$undostat\n where SSOLDERRCNT > 0\n   and BEGIN_TIME > sysdate - 1 / 24 / 60 * 10;\n',3662,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3692,'ORA-04098','--goldengate的DDL触发器导致\nORA-04098: trigger \'SYS.GGS_DDL_TRIGGER_BEFORE\' is invalid and failed\n解决方式:\nALTER TRIGGER sys.GGS_DDL_TRIGGER_BEFORE DISABLE; ',3663,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3693,'edit params mgr','--起因:\n    edit params mgr\n    Cannot load ICU resource bundle \'ggMessage\', error code 2 - No such file or directory\n--解决:\n    不能在非ogg_home下执行此命令',3663,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3694,'无法启动dp1','OGG-01224  TCP/IP error 113 (No route to host)\n现象：\n2012-04-23 06:19:32  ERROR   OGG-01224  TCP/IP error 113 (No route to host).\n2012-04-23 06:19:32  ERROR   OGG-01668  PROCESS ABENDING.\n解决方法：\n检查网络情况，此处是因为启用了本机防火墙。关掉防火墙 :\nchkconfig –level 235 iptables off\n或者 service iptables stop',3663,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3695,'Script_Install_Linux_5_5_64_bit_Oracle_11g_R2','\"安装oracle脚本\"',3664,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3696,'oracle_11_2_64_bit_静默安装配置文件','\"示例文件\"',3664,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3697,'Linux_5_5_64_bit_Oracle_Rac_11g_r2安装文档','大致流程',3664,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3698,'12c(linux 6.4) rpm','--yum install compat-libstdc++-33 compat-libcap1 binutils gcc gcc-c++ glibc glibc-devel ksh libgcc libstdc++ libstdc++-devel libaio libaio-devel libXext libX11 libXau libXi make systat \n',3664,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3699,'Linux_6_5_64_bit_Oracle_12c_r1','--安装前rpm和参数设置',3664,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3700,'11GR2静默安装','--dbca -silent -createDatabase -templateName General_Purpose.dbc -gdbName weather -sid weather -sysPassword oracle -systemPassword oracle -emConfiguration none -disableSecurityConfiguration none -characterSet AL32UTF8\n',3664,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3701,'修复ORAINVENTORY(含RAC)',NULL,3665,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3702,'升级线路','--9.0.1.3 (or earlier) -> 9.0.1.4 -> 10.2.0.4 -> 11.2\n9.2.0.8 | 10.1.0.5 | 10.2.0.2 | 11.1.0.6 -> 11.2\n{10.2.0.2 | 10.2.0.3 | 10.2.0.4 | 10.1.0.5 -> 10.2.0.5} | 11.1.0.7 | {9.2.0.8 | 11.2.0.1 | 11.1.0.6 -> 11.2.0.2}| {9.2.0.8 -> 11.2.0.3} | 12.1.0.1 -> 12.1',3666,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3703,'升级前事项 01','--When upgrading to a new release, back up your existing production environment, both software and database, before installation.',3666,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3704,'db_file_multiblock_read_count','                                                                                     doc-12c',3667,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3705,'REMOTE_OS_AUTHENT','是否开启远端OS验证',3668,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3706,'_db_block_hash_buckets','Number of database block hash buckets.',3669,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3707,'_db_block_lru_latches','number of lru latches',3669,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3708,'ddl_lock_timeout','用于指定DDL操作的等待时间',3670,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3709,'instance_number','INSTANCE_NUMBER is an Oracle RAC parameter that can be specified in parallel mode or exclusive mode. It specifies a unique number that maps the instance to one free list group for each database object created with storage parameter FREELIST GROUPS.\n//instance number 是一个Oracle RAC参数，这个参数可以指定在parallel mode or exclusive mode.他指定一个唯一的number，这个number\n\nThe INSTANCE parameter of the ALTER TABLE ... ALLOCATE EXTENT statement assigns an extent to a particular free list group. If you set INSTANCE_NUMBER to the value specified for the INSTANCE parameter, the instance uses that extent for inserts and for updates that expand rows.\n//ALTER TABLE ... ALLOCATE EXTENT 命令的INSTNCE 参数分配一个extent到一个指定的free list group.如果你设置instance_number\n\n这个参数的最大值是在CREATE DATABASE命令中制定的max instance number.The absolute maximum is operating system-dependent.\n',3671,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3710,'thread','THREAD已经被INSTANCE_NAME和INSTANCE_NUMBER参数取代，并且将废弃在未来的Oracle Database.\n    既然废弃了，就不设置对应的文档.',3671,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3711,'CLUSTER_INTERCONNECTS','这个参数可以被用在rac 环境中用来指明node之间的通讯地址.可以使用这个参数来压倒，默认的node间的配置,他是存储在cluster registry.\n这个程序也可用于数据仓库系统，来提高的node间相互连接的通讯的带宽需求。\n\n指定这个参数将重写并压倒以下：:\n•Network classifications stored by oifcfg in the OCR.\n•The default interconnect chosen by Oracle.\n\n\nIf you want to load-balance the interconnect, then Oracle recommends that you use link-bonding at the operating system level, even if you have two databases on the same server, so that multiple interconnects use the same address. Note that multiple private addresses provide load balancing, but do not provide failover unless bonded. If you specify multiple addresses in init.ora using CLUSTER_INTERCONNECTS, instead of bonding multiple addresses at the operating system level, then typically availability is reduced, because each network interface card failure will take down that instance.\n如果你在node间增加load-balance ,那么oracle推荐，你使用link-bonding在操作系统级别，即使你有两个DB在相同的服务器上，所以\n\nRefer to your vendor documentation for information about bonding interfaces. Some vendor bonding architectures may require the use of this parameter.\n\nIf you have multiple database instances on Oracle Real Application Clusters nodes and want to use a specific interface for each instance, then you can set the CLUSTER_INTERCONNECTS initialization parameter to the IP address for each database instance. For example:\nhr1.init.ora.cluster_interconnects=\"192.0.2.111\"\noltp3.init.ora.cluster_interconnects=\"192.0.2.112\"\n\n\nIf the Oracle RAC interconnect is configured to run on a different interface than the Oracle Clusterware interconnect, then this configuration can cause reduced availability, as failovers or instance evictions can be delayed if the Oracle RAC interconnect fails while the Oracle Clusterware NIC remains up.\n',3671,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3712,'CLUSTER_DATABASE_INSTANCES','这个参数是一个Oracle rac参数，指定rac database中instance数量。你必须设置这个参数对于每个instance。正常情况下你应该设置这个参数在rac中。合理的设置这个参数可以改善内存的使用情况。\n\nOracle使用这个参数值来计算默认的LARGE_POOL_SIZE的值，当PARALLEL_AUTOMATIC_TUNING设置为true的时候。\n   note:PARALLEL_AUTOMATIC_TUNING 参数已经被废弃。\n\nrac手册:在管理员管理的DB中这个参数的默认值是instane 数量，在基于策略的管理中，这个参数默认值为16,Oracle会使用这个参数值来计算其他一些的参数值，例如large_pool_size.',3671,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3713,'DML_LOCKS','A DML lock is a lock obtained on a table that is undergoing a DML operation (insert, update, delete). DML_LOCKS specifies the maximum number of DML locks—one for each table modified in a transaction. The value should equal the grand total of locks on tables currently referenced by all users. For example, if three users are modifying data in one table, then three entries would be required. If three users are modifying data in two tables, then six entries would be required.\n一个DML lock是一个获得table的lock，这个表接收一个DML操作(insert,update,delete).\nDML_LOCKS指定DML的最大数，这个数是对于在一个transaction中修改的每一个表的DML。这个值应该等于当前所有用户引用的表上的lock总数。例如如果3个用户正在修改一个表上的数据，那么3个entries将来被需求。如果3个用户正在修改两个表中的数据，那么6个entries在将来被需求。\n\nThe default value assumes an average of four tables referenced for each transaction. For some systems, this value may not be enough.\n默认值假设一个每个transaction引用4个表的平均值。对于某些系统这个值可能不够。\n\nenqueues是共享内存结构，这个结构连续访问database资源。如果你设置DML_LOCK为0，enqueues是disabled并且性能略微增强。然而，你应该明白以下限制，对于设置为0：\n\n•你不能使用DROP TABLE,CREATE INDEX命令\n\n•你不能使用使用明确的lock命令，例如LOCK TABLE 在EXCLUSIVE MODE中。\n\n•如果DML_LOCK设置为0，那么EM不能运行在恩赫instance上。\n\nOracle在并行DML的时候比串行DML的时候持有更多的lock.因此，如果你的database支持大量的并行DML，你可能需要来增加这个参数值。',3671,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3714,'INSTANCE_GROUPS','note:instance_groups参数是弃用的。他是保留用于向后兼容。\n\nINSTANCE_GROUPS is an Oracle RAC parameter that you can specify only in parallel mode. Used with the PARALLEL_INSTANCE_GROUP parameter, it lets you restrict parallel query operations to a limited number of instances.\n\nThis parameter specifies one or more instance groups and assigns the current instance to those groups. If one of the specified groups is also specified in the PARALLEL_INSTANCE_GROUP parameter, then Oracle allocates query processes for a parallel operation from this instance.\n',3671,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3715,'PARALLEL_INSTANCE_GROUP','PARALLEL_INSTANCE_GROUP is an Oracle RAC parameter that you can specify in parallel mode only. Used in conjunction with services or with the INSTANCE_GROUPS parameter, it lets you restrict parallel query operations to a limited number of instances. Note that the INSTANCE_GROUPS parameter has been deprecated.\n\nThis parameter identifies the parallel instance group Oracle will use for spawning parallel execution processes. If used in conjunction with services, then parallel operations will spawn parallel execution processes only on instances defined in the service. If used in conjunction with INSTANCE_GROUPS, then parallel operations will spawn parallel execution processes only on instances that specify a matching group in their INSTANCE_GROUPS parameter.\n\nIf the value assigned to PARALLEL_INSTANCE_GROUP is the name of a service or group that does not exist, then the operation runs serially. No parallelism is used.\n',3671,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3716,'CLUSTER_DATABASE','这是一个rac参数，这个参数指定oracle rac是否被启动。',3671,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3717,'gcs_server_process','Footnote 1 For Oracle RAC instances with less powerful CPUs, the RDBMS spawns fewer GCS server processes than indicated in the Default value description.\n\nGCS_SERVER_PROCESSES specifies the number of background GCS server processes (LMS0, ... LMS9 and LMSa, ... LMSz) to serve the inter-instance traffic among Oracle RAC instances. GCS server processes are only seen in an Oracle RAC environment.\n',3671,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3718,'GCS_SERVER_PROCESSES','For Oracle RAC instances with less powerful CPUs, the RDBMS spawns fewer GCS server processes than indicated in the Default value description.\n\nGCS_SERVER_PROCESSES specifies the number of background GCS server processes (LMS0, ... LMS9 and LMSa, ... LMSz) to serve the inter-instance traffic among Oracle RAC instances. GCS server processes are only seen in an Oracle RAC environment.',3671,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3719,'RECOVERY_PARALLELISM','执行instance recovery的进程数量',3672,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3720,'FAST_START_MTTR_TARGET','instance recovery时间',3672,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3721,'DB_RECOVERY_FILE_DEST_SIZE','这个参数指定bytes，用于限制fast recovery file的总大小。\n注意:每个oracle file中既没有block 0也没有OS block header包含在这个设置的大小中，在计算真实的被用于fast recovery file的磁盘使用空间时，给予额外的10%.(goku：这句话理解有问题，待确定)',3672,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3722,'DB_RECOVERY_FILE_DEST','指定默认fast recovery area的位置.fast recovery area包含当前control file和redo log file的多个副本,就像 archived redo logs, flashback logs, and RMAN backups.\n指定此参数，而不指定DB_RECOVERY_FILE_DEST_SIZE，是不可以的.',3672,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3723,'DB_FLASHBACK_RETENTION_TARGET','执行闪回DB可以闪回的时间，以分钟为单位。\n这个参数间接的指定了多少flashback log 数据存放在recovery area。',3672,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3724,'DB_LOST_WRITE_PROTECT','执行是否开启，或开启那个级别的写侦测检查。\nNONE | TYPICAL | FULL \n    NOTE：不执行侦测\n    TYPICAL：对读写表空间侦测\n    FULL:对只读或读写表空间侦测\n\n开启后性能开销在5 to 10% \n\n这个参数更有效于DG，当Primary DB SCN小于standby DB，那么oracle抛出外部错误ORA-752.如果standby DB SCN小于primary DB那么抛出ORA 600[3020]错误，这些错误都是油standby DB发现，并记录在她的alert和trace file中。\n\n这个参数也适用于非DG环境下.',3672,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3725,'PROCESSES','在asm instance来确定process的数量',3673,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3726,'DBA_RSRC_CONSUMER_GROUPS','DISPLAYS INFORMATION ABOUT ALL RESOURCE CONSUMER GROUPS IN THE DATABASE.\n显示关于DB中所有的资源消费组。',3674,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3727,'REMOTE_OS_AUTHENT','--用来控制是否允许远端操作系统验证',3675,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3728,'os_authent_prefix','--远程OS认证的前缀设置',3675,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3729,'nls_language','--设置instance语言',3676,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3730,'nls_territory','--设置instance的地理位置。',3676,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3731,'nls_database_parameters','--NLS_DATABASE_PARAMETERS lists permanent NLS parameters of the database.',3677,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3732,'从文件上体现sid和dbname的区别','--我用dbca创建数据库sid是ipppxppp dbname是dpppxppp\n[root@localhost rlwrap-0.41]# find / -name ipppxppp\n/u01/app/diag/rdbms/dpppxppp/ipppxppp\n[root@localhost rlwrap-0.41]# find / -name dpppxppp\n/u01/app/diag/rdbms/dpppxppp\n/u01/app/fast_recovery_area/dpppxppp\n/u01/app/oradata/dpppxppp\n/u01/app/cfgtoollogs/dbca/dpppxppp\n/u01/app/admin/dpppxppp',3678,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3733,'db_domain','--设置全局唯一的名称、域名',3679,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3734,'db_name','--设置数据库名称',3679,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3735,'db_unieque_name','--设置唯一的名字',3679,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3736,'compatible','--设置版本号',3679,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3737,'v$option','V$OPTION displays Oracle Database options and features. Typically, although not always, options must be separately licensed, whereas features come with the product and are enabled based on the product that is running (Standard Edition, Enterprise Edition, and so on).',3680,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3738,'V$VERSION','--',3680,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3739,'PRODUCT_COMPONENT_VERSION','--PRODUCT_COMPONENT_VERSION contains version and status information for component products.',3680,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3740,'NLS_DATE_FORMAT','--',3681,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3741,'注意事项1','--If you create your database with Database Configuration Assistant (DBCA) and choose the basic installation option, automatic memory management is enabled when system memory is less than or equal to 4 gigabytes. When system memory is greater than 4 gigabytes, automatic memory management is disabled, and automatic shared memory management is enabled. If you choose advanced installation, then DBCA enables you to select automatic memory management or automatic shared memory management.',3682,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3742,'dbms_utility.db_version','--显示DB的版本，和兼容性版本',3683,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3743,'dbms_utility.port_string','--查看db的OS平台版本、内核版本 SQL> select dbms_utility.port_string from dual;\n',3683,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3744,'dbms_utility.get_cpu_time','--',3683,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3745,'配置CDB em(HTTP)','--1.配置端口\n    exec DBMS_XDB_CONFIG.SETHTTPPORT(http_port_number);\n2.浏览器中打开em\n    http://database_hostname:http_port_number/em/\n$$$Database Administrator\'s Guide.37 Creating and Configuring a CDB',3684,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3746,'配置CDB em(HTTPS)','----1.配置端口\n    exec DBMS_XDB_CONFIG.SETHTTPSPORT(http_port_number);\n2.浏览器中打开em\n    https://database_hostname:http_port_number/em/\n$$$Database Administrator\'s Guide.37 Creating and Configuring a CDB',3684,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3747,'EM_EXPRESS_BASIC','--',3685,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3748,'EM_EXPRESS_ALL','--',3685,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3749,'CDB中最大的PDB数量','--A CDB can contain up to 253 PDBs, including the seed',3686,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3750,'查看db中的cdb','--SELECT NAME, CDB, CON_ID FROM V$DATABASE;',3687,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3751,'CDB的3个组成部分','1.Root，他被命名为CDB$ROOT，存储由oracle提供的元数据和公共用户。Oracle提供的plsql包就是元数据的一种。一个公共用户是一个数据库用户，他存在于每一个容器中(CDB/PDB),一个CDB只有一个root\n2.Seed，他被命名为PDB$SEED，他是一个模板，用于创建PDB，不能对SEED增加或修改其中的object。一个CDB只有一个seed。\n3.PDB，就是实际数据库，就是non-cdb\n上面这些组建叫做容器。因此，root是容器，seed是容器，每个pdb是一个容器。每个容器在CDB中有一个唯一的容器id和名字\n$$$Database Administrator\'s Guide.36 Overview of Managing a Multitenant Environment',3688,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3752,'Common user和local user','--common user是一个用户，他在cdb和pdb中的身份都是一样的。一些管理任务只能是由公共用户执行的，比如create pdb，或unplug pdb。Cdb也支持本地用户。\n$$$Database Administrator\'s Guide.36 Overview of Managing a Multitenant Environment',3688,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3753,'non-CDB的概念','--所有用12c之前的版本创建的数据库都称为non-CDB，到了12c数据库只分为3种，CDB/PDB/non-CDB，不属于CDB和PDB就是non-CDB\n$$$Database Administrator\'s Guide.36 Overview of Managing a Multitenant Environment',3688,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3754,'CDB的作用','--container database (CDB) 是一个容器数据库，他可以管理0个，1个，或多个pluggable databases (PDBs)(可拔插数据库)，更准确的说他是一个存放多个PDB数据库的容器。\n$$$Database Administrator\'s Guide.36 Overview of Managing a Multitenant Environment',3688,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3755,'CDB创建PDB的数量','--A CDB can contain up to 253 PDBs, including the seed.',3688,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3756,'PDB_FILE_NAME_CONVERT ','--',3689,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3757,'ENABLE_PLUGGABLE_DATABASE','--',3689,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3758,'创建PDB | 克隆PDB','--CREATE PLUGGABLE DATABASE pdb2 FROM goku2 [FILE_NAME_CONVERT=(\'goku2\',\'pdb2\')];\n--goku2需要read only',3690,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3759,'连接指定的PDB','--ALTER SESSION SET CONTAINER =PDB_NAME;',3690,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3760,'instance | Opens the PDB in migrate mode.','--ALTER PLUGGABLE DATABASE goku2 OPEN UPGRADE [RESTRICTED];\n',3690,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3761,'启动pdb','-- STARTUP PLUGGABLE DATABASE pdb2 ;\n',3690,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3762,'创建PDB | 通过non-CDB','--',3690,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3763,'创建PDB | 通过SEED创建','--CREATE PLUGGABLE DATABASE hrpdb ADMIN USER dba1 IDENTIFIED BY password;\n[ROLES=(DBA)]\n[FILE_NAME_CONVERT=(\'seed\',\'hrpdb\')] #赋予PDB_DBA\n[STORAGE (MAXSIZE 2G MAX_SHARED_TEMP_SIZE 100M)]\n[DEFAULT TABLESPACE sales DATAFILE \'/disk1/oracle/dbs/salespdb/sales01.dbf\' SIZE 250M AUTOEXTEND ON]\n[PATH_PREFIX = \'/disk1/oracle/dbs/salespdb/\']\n[TEMPFILE REUSE]\n\n',3690,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3764,'创建PDB | 插入unplug pdb','--CREATE PLUGGABLE DATABASE salespdb USING \'/disk1/usr/financepdb.xml\' NOCOPY\n--NOCOPY 表示拔掉的pdb的data file不需要重命名。',3690,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3765,'instance | read only/read write pdb','--ALTER PLUGGABLE DATABASE goku2 OPEN { READ WRITE | READ ONLY } [RESTRICTED] [FORCE];',3690,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3766,'instance | shudown pdb','--ALTER PLUGGABLE DATABASE goku2 CLOSE [IMMEDIATE]\n--IMMEDIATE 不加表示normal 模式关闭\n',3690,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3767,'instance | mount','--ALTER PLUGGABLE DATABASE goku2 mount;',3690,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3768,'pdb相关操作','--ALTER PLUGGABLE DATABASE ALL OPEN [ READ WRITE ] [ FORCE ];\n--ALTER PLUGGABLE DATABASE ALL EXCEPT salespdb, hrpdb CLOSE IMMEDIATE;\n',3690,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3769,'CREATE PLUGGABLE DATABASE ','--创建拔插数据库权限',3691,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3770,'CDB_SERVICES ','--',3692,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3771,'V$CONTAINERS','--',3692,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3772,'DBA_PDBS','--',3692,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3773,'V$PDBS','--',3692,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3774,'查看当前session不关闭和重启DB就可以设置的参数','select name，value，isdefault，isses_modifiable,issys_modifiable from v$parameter where issys_modifiable =\'IMMEDIATE\';',3693,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3775,'查看只对新session生效的参数','select name，value，isdefault，isses_modifiable,issys_modifiable from v$parameter where isses_modifiable =\'DEFERRED\';',3693,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3776,'查看不为默认值的参数','select name，value，isdefault，isses_modifiable,issys_modifiable from v$parameter where ISDEFAULT =\'FALSE\';',3693,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3777,'查看隐藏参数','SELECT   ksppinm, ksppstvl, ksppdesc\nFROM   x$ksppi x, x$ksppcv y\nWHERE   x.indx = y.indx AND TRANSLATE (ksppinm, \'_\', \'#\') LIKE \'#%\';\n\nselect ksppinm,ksppstvl,ksppstdf \nfrom x$ksppi a, x$ksppcv b \nwhere a.indx=b.indx;\n--ksppinm 参数名称\n--ksppstvl参数的当前值，\n--ksppstdp参数的默认值 \n',3693,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3778,'以下进程是不能KILL掉的','RDBMS部分\n	DBWR/LGWR/CKPT/PMON/SMON/RECO/MMAN/PSP0\nASM部分\n	ASMB/RBAL/DBW0/SMON/CKPT/PSP0/GMON/\n',3694,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3779,'SMON概念','--',3694,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3780,'processes','--',3695,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3781,'v$bgprocess','--V$BGPROCESS displays information about the background processes.',3696,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3782,'查看database版本信息','select * from v$version;',3697,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3783,'查看database中安装的产品','select * from v$option;',3697,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3784,'kill session','----alter system kill session \'14,397\';\n--SID    SERIAL#',3698,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3785,'LICENSE_MAX_SESSIONS','弃用',3699,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3786,'session','--设置连接到instance的最大会话数量',3699,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3787,'查看系统中当前的session','select * from v$license;',3700,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3788,'查询session执行进度','--select SOFAR,TOTALWORK from V$SESSION_LONGOPS where  SOFAR<>TOTALWORK;',3700,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3789,'v$license','正在运行的database的session信息\nNote:\nThe availability of the CPU core count and CPU socket count statistics is subject to the operating system platform on which the Oracle Database is running. If a statistic is unavailable, the view will return NULL for the statistic value.',3701,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3790,'V$SESSION_LONGOPS','--执行时间超过6秒的操作都记录在这，而且可以查看进度',3701,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3791,'v$open_cursor','--',3701,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3792,'1462240.1','--',3702,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3793,'854428.1','--Patch Set Updates for Oracle Products',3702,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3794,'查看辅助TS使用空间','select sum(space_usage_kbytes) from v$sysaux_occupants ',3703,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3795,'授权视图给某个用户','授权v$fixed_table给hr用户\nSQL> grant select on v_$fixed_table to hr;',3704,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3796,'dba_registry_database','--Oracle所在的OS平台信息',3705,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3797,'v$version','--oracle版本信息',3705,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3798,'database_properties','--DATABASE_PROPERTIES lists Permanent database properties.',3705,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3799,'v$fixed_view_definition','这个视图包含所有fixed view的定义.',3706,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3800,'v$fixed_table','V$FIXED_TABLE displays all dynamic performance tables, views, and derived tables in the database. Some V$ tables (for example, V$ROLLNAME) refer to real tables and are therefore not listed.',3706,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL),(3801,'ALL_VIEWS','ALL_VIEWS describes the views accessible to the current user.\nRelated Views:\nDBA_VIEWS describes all views in the database.\nUSER_VIEWS describes the views owned by the current user. This view does not display the OWNER column.',3706,'2016-04-06 23:27:50','2016-04-06 23:27:50',NULL);
/*!40000 ALTER TABLE `content` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `document`
--

DROP TABLE IF EXISTS `document`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `document` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `dtype` varchar(5) DEFAULT NULL,
  `state` int(11) NOT NULL,
  `createdata` datetime NOT NULL,
  `updatedata` datetime NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `document`
--

LOCK TABLES `document` WRITE;
/*!40000 ALTER TABLE `document` DISABLE KEYS */;
/*!40000 ALTER TABLE `document` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2016-04-07 21:49:59
